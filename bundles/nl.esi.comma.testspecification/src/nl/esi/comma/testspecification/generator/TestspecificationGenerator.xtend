/*
 * generated by Xtext 2.29.0
 */
package nl.esi.comma.testspecification.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.EcoreUtil2
import nl.esi.comma.inputspecification.inputSpecification.APIDefinition
import nl.esi.comma.testspecification.testspecification.TestDefinition
import nl.esi.comma.actions.actions.AssignmentAction
import nl.esi.comma.actions.actions.RecordFieldAssignmentAction
import nl.esi.comma.expressions.expression.ExpressionRecordAccess
import nl.esi.comma.expressions.expression.ExpressionVariable
import nl.esi.comma.types.types.VectorTypeDecl
import nl.esi.comma.expressions.expression.Expression
import nl.esi.comma.inputspecification.inputSpecification.SUTDefinition
import java.util.HashMap
import java.util.List
import java.util.ArrayList
import java.util.Map
import com.google.common.base.Splitter
import com.google.gson.Gson
import nl.esi.comma.testspecification.testspecification.TSMain
import com.google.gson.JsonParser
import com.google.gson.GsonBuilder
import com.google.gson.JsonElement
import nl.esi.comma.inputspecification.inputSpecification.TWINSCANKT
import nl.esi.comma.inputspecification.inputSpecification.LISVCP
import java.util.regex.Pattern
import nl.esi.comma.testspecification.testspecification.AbstractTestDefinition
import nl.esi.comma.testspecification.testspecification.ContextMap
import nl.esi.comma.testspecification.testspecification.AbstractStep

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TestspecificationGenerator extends AbstractGenerator 
{

	var Resource _resource
	
	// In-Memory Data Structures corresponding *.tspec (captured in resource object)
	var mapLocalDataVarToDataInstance = new HashMap<String, List<String>>
	var mapLocalStepInstance = new HashMap<String, List<String>>
	var mapLocalSUTVarToDataInstance = new HashMap<String, List<String>>
	var mapDataInstanceToFile = new HashMap<String, List<String>>
	var mapSUTInstanceToFile = new HashMap<String, List<String>>
	var listStepInstances = new ArrayList<Step>
		
	// On save of TSPEC file, this function is called by Eclipse Framework
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		mapLocalDataVarToDataInstance = new HashMap<String, List<String>>
		mapLocalStepInstance = new HashMap<String, List<String>>
		mapLocalSUTVarToDataInstance = new HashMap<String, List<String>>
		mapDataInstanceToFile = new HashMap<String, List<String>>
		mapSUTInstanceToFile = new HashMap<String, List<String>>
		listStepInstances = new ArrayList<Step>

		if(resource.allContents.head instanceof TSMain) {
			_resource = resource
			val modelInst = resource.allContents.head as TSMain
			/*if(modelInst.model instanceof AbstractTestDefinition)
				generateAbstractTest(fsa)*/
			if(modelInst.model instanceof TestDefinition)
				generateContents(fsa) // Parsing and File Generation
			
			if(modelInst.model instanceof AbstractTestDefinition)
				(new FromAbstractToConcrete).doGenerate(resource, fsa, context)
			
			System.out.println("\n")
			System.out.println(" ******* TEST DOCUMENTATION GENERATOR *********")
			System.out.println("\n")
			(new TestDocumentationGenerator).generateDocumentationForAllVariants(resource,fsa)
		}		
	}
	
	// This function was specifically written for transformation of abstract test cases
	// to concrete test specification. Consider moving it somewhere dedicated!
	def generateAbstractTest(IFileSystemAccess2 fsa) 
	{
		val modelInst = _resource.allContents.head as TSMain // This is our abstract test spec
		var testDefFilePath = new String
		var mapActToStepSequence = new HashMap<String,nl.esi.comma.testspecification.testspecification.StepSequence>
		
		for(imp : modelInst.imports) {
			// expect: import of only context map type.
			// Assumption: At most one
			val inputCMResource = EcoreUtil2.getResource(_resource, imp.importURI)
			var inputCM = inputCMResource.allContents.head
			if(inputCM instanceof TSMain) {
				if(inputCM.model instanceof ContextMap) {
					mapActToStepSequence = getCMStepRef(inputCM.model as ContextMap)
					// now we will recursively parse this files imports
					var TSMain _inputTSpec
					for(cm_imp : inputCM.imports) {
						// Assumption: At most one import
						val inputTSRes = EcoreUtil2.getResource(_resource, cm_imp.importURI)
						var inputTSpec = inputTSRes.allContents.head
						if(inputTSpec instanceof TSMain) {
							_inputTSpec = inputTSpec
							// Process TSPEC Imports.
							for(_imp : inputTSpec.imports) {
								val inputResource = EcoreUtil2.getResource(_resource, _imp.importURI)
								var input = inputResource.allContents.head
								if( input instanceof nl.esi.comma.inputspecification.inputSpecification.Main) {
									if(input.model instanceof APIDefinition) {
										val apidef = input.model as APIDefinition
										for(api : apidef.apiImpl) {
											for(elm : api.di)
												addMapDataInstanceToFile(elm.^var.name, api.path + elm.fname)
										}
									} 
									else if(input.model instanceof SUTDefinition) { } 
									else { System.out.println("Error: Unhandled Model Type! ")}
								}
							}
						}
					}
					
					if(_inputTSpec !== null)
					{
						// Parse TSPEC Test Definition
						val model = _inputTSpec.model
						val abstract_model = modelInst.model
						if(model instanceof TestDefinition) 
						{
							if(abstract_model instanceof AbstractTestDefinition) 
								testDefFilePath = abstract_model.filePath
							//for(gpars : model.gparams) { addMapLocalDataVarToDataInstance(gpars.name, new String) }
							for(steppars : model.stepparams) { 
								addMapLocalStepInstance(steppars.name, steppars.type.type.name)
							}
							//for(sutpars : model.sutparams) { addMapLocalSUTVarToDataInstance(sutpars.name, new String) }
							for(act : model.gparamsInitActions) {
								var mapLHStoRHS = generateInitAssignmentAction(act)
								addMapLocalDataVarToDataInstance(mapLHStoRHS.key, mapLHStoRHS.value)
							}
							for(act : model.sutInitActions) {
								var mapLHStoRHS = generateInitAssignmentAction(act)
								addMapLocalSUTVarToDataInstance(mapLHStoRHS.key, mapLHStoRHS.value)
							}
							
							// Parse Step Sequence 
							val stepSequence = getAbstractStepSequence((abstract_model as AbstractTestDefinition), mapActToStepSequence)
							for(s : stepSequence) {
								var stepInst = new Step
								stepInst.id = s.inputVar.name //stepVar.name // was identifier
								stepInst.type = s.type.name
								stepInst.inputFile = mapDataInstanceToFile.get(s.stepVar.name).head
								// check if additional data was specified in a step
								for(ref : s.refStep) {
								//if(s.input!==null) {
									for(act : ref.input.actions) {
										if(	act instanceof AssignmentAction || act instanceof RecordFieldAssignmentAction) 
										{
											var mapLHStoRHS = generateInitAssignmentAction(act)
											stepInst.parameters.add(mapLHStoRHS)
											var lhs = getLHS(act) // note key = record variable, and value = recExp
											stepInst.variableName = lhs.key
											stepInst.recordExp = lhs.value
										}
									}
								}
								listStepInstances.add(stepInst)
							}
						}
						
						// update step file names based on checking if additional data was specified. 
						for(step : listStepInstances) {
							if(!step.parameters.isEmpty) {
								step.inputFile = step.inputFile.replaceAll(".json", "_" + step.id + ".json")
							}
						}
						
						// Turn off during production!
						displayParseResults
						
						// generate data.kvp file
						fsa.generateFile(testDefFilePath + "data.kvp", generateFASTScenarioFile)
						
						// Generate JSON data files and vfd.xml
						generateJSONDataAndVFDFiles(testDefFilePath, fsa, _inputTSpec)
					}
				}
			}	
		}
	}
	
	// Generate data.kvp and referenced JSON files
	def generateContents(IFileSystemAccess2 fsa) 
	{
		val modelInst = _resource.allContents.head as TSMain
		var testDefFilePath = new String
		
		// Process TSPEC Imports.
		for(imp : modelInst.imports) {
			val inputResource = EcoreUtil2.getResource(_resource, imp.importURI)
			var input = inputResource.allContents.head
			if( input instanceof nl.esi.comma.inputspecification.inputSpecification.Main) {
				if(input.model instanceof APIDefinition) {
					val apidef = input.model as APIDefinition
					for(api : apidef.apiImpl) {
						for(elm : api.di)
							addMapDataInstanceToFile(elm.^var.name, api.path + elm.fname)
					}
				} else if(input.model instanceof SUTDefinition) {
					/*val sutdef = input.model as SUTDefinition
					for(sut : sutdef.sutImpl) {
						for(elm : sut.di) {
							addMapSUTInstanceToFile(elm.^var.name, sut.path + elm.fname)	
						}
					}*/ // assumption is its a standard vfd.xml file. See dedicated generator later.
				} else { System.out.println("Error: Unhandled Model Type! ")}
			}
		}
		
		// Parse TSPEC Test Definition
		val model = modelInst.model
		if(model instanceof TestDefinition) 
		{
			testDefFilePath = model.filePath
			//for(gpars : model.gparams) { addMapLocalDataVarToDataInstance(gpars.name, new String) }
			for(steppars : model.stepparams) { 
				addMapLocalStepInstance(steppars.name, steppars.type.type.name)
			}
			//for(sutpars : model.sutparams) { addMapLocalSUTVarToDataInstance(sutpars.name, new String) }
			for(act : model.gparamsInitActions) {
				var mapLHStoRHS = generateInitAssignmentAction(act)
				addMapLocalDataVarToDataInstance(mapLHStoRHS.key, mapLHStoRHS.value)
			}
			for(act : model.sutInitActions) {
				var mapLHStoRHS = generateInitAssignmentAction(act)
				addMapLocalSUTVarToDataInstance(mapLHStoRHS.key, mapLHStoRHS.value)
			}
			
			// Parse Step Sequence
			val stepSequence = getStepSequence(model)
			for(s : stepSequence) {
				var stepInst = new Step
				stepInst.id = s.inputVar.name //stepVar.name // was identifier
				stepInst.type = s.type.name
				stepInst.inputFile = mapDataInstanceToFile.get(s.stepVar.name).head
				// check if additional data was specified in a step
				for(ref : s.refStep) {
				//if(s.input!==null) {
					for(act : ref.input.actions) {
						if(	act instanceof AssignmentAction || act instanceof RecordFieldAssignmentAction) 
						{
							var mapLHStoRHS = generateInitAssignmentAction(act)
							stepInst.parameters.add(mapLHStoRHS)
							var lhs = getLHS(act) // note key = record variable, and value = recExp
							stepInst.variableName = lhs.key
							stepInst.recordExp = lhs.value
						}
					}
				}
				listStepInstances.add(stepInst)
			}
		}
		
		// update step file names based on checking if additional data was specified. 
		for(step : listStepInstances) {
			if(!step.parameters.isEmpty) {
				step.inputFile = step.inputFile.replaceAll(".json", "_" + step.id + ".json")
			}
		}
		
		// Turn off during production!
		displayParseResults
		
		// generate data.kvp file
		fsa.generateFile(testDefFilePath + "data.kvp", generateFASTScenarioFile)
		
		// Generate JSON data files and vfd.xml
		generateJSONDataAndVFDFiles(testDefFilePath, fsa, modelInst)
	}
	
	def getCMStepRef(ContextMap cm) {
		var mapActToStepSequence = new HashMap<String,nl.esi.comma.testspecification.testspecification.StepSequence>
		for(elm : cm.TMap) {
			mapActToStepSequence.put(elm.name,elm.stepSeqId)
		}
		return mapActToStepSequence
	}
	
	def getAbstractStepSequence(AbstractTestDefinition atd, 
		Map<String,nl.esi.comma.testspecification.testspecification.StepSequence> mapActToStepSequence
	) {
		var listStepSequence = new ArrayList<nl.esi.comma.testspecification.testspecification.Step>
		for(elm: atd.testSeq) {
			for(s : elm.step) {
				if(s instanceof AbstractStep) {
					if(mapActToStepSequence.get(s.name)!== null)
						for(st: mapActToStepSequence.get(s.name).step)
							listStepSequence.add(st)
				}
			}
		}
		return listStepSequence
	}
	
	def getStepSequence(TestDefinition td) {
		var listStepSequence = new ArrayList<nl.esi.comma.testspecification.testspecification.Step>
		if(td.testSeq.empty) {
			for(ss : td.stepSeq) {
				for(step : ss.step) listStepSequence.add(step)
			}
		}
		else {
			for(ts : td.testSeq) {
				for(ss : ts.stepSeqRef) {
					for(step : ss.step) listStepSequence.add(step)
				}
			}
		}
		return listStepSequence
	}
	
	def dispatch KeyValue getLHS(AssignmentAction action) {
		var kv = new KeyValue
		kv.key = action.assignment.name
		kv.value = new String
		return kv
	}
	
	def dispatch KeyValue getLHS(RecordFieldAssignmentAction action) {
		return getLHSRecAssignment(action.fieldAccess as ExpressionRecordAccess, action.exp)
	}
	
	def KeyValue getLHSRecAssignment(ExpressionRecordAccess eRecAccess, Expression exp) {
		var record = eRecAccess.record
        var field = eRecAccess.field
        var recExp = ''''''
             
        while(! (record instanceof ExpressionVariable)) {
        	if(recExp.empty) recExp = '''«(record as ExpressionRecordAccess).field.name»'''
            else recExp = '''«(record as ExpressionRecordAccess).field.name».''' + recExp
            record = (record as ExpressionRecordAccess).record
        }
		val varExp = record as ExpressionVariable
		var kv = new KeyValue
		kv.key = varExp.variable.name
		kv.value = recExp
		return kv
	}
	
	// Expression Handler //
	def dispatch KeyValue generateInitAssignmentAction(AssignmentAction action) {
		var mapLHStoRHS = new KeyValue //HashMap<String,String>
		mapLHStoRHS.key =  action.assignment.name
		mapLHStoRHS.value = ExpressionsParser::generateExpression(action.exp, '''''').toString
		/*if(mapLHStoRHS.value.contains('''platform:''') || mapLHStoRHS.value.contains('''setup.suts''')) 
			{
				System.out.println(" DETECTED PLATFORM: " + mapLHStoRHS.value)
				mapLHStoRHS.value = mapLHStoRHS.value.replaceAll("^\"|\"$", "")
				
				}*/
		// replace references to global variables with FAST syntax
		for(elm : mapLocalDataVarToDataInstance.keySet) {
			if(mapLHStoRHS.value.contains(elm)) {
				mapLHStoRHS.value = mapLHStoRHS.value.replaceAll(elm, "global.params['" + elm + "']")
			}	
		}
		return mapLHStoRHS
	}
	
	def dispatch KeyValue generateInitAssignmentAction(RecordFieldAssignmentAction action) {
		return generateInitRecordAssignment(action.fieldAccess as ExpressionRecordAccess, action.exp, '''''')
	}

	def generateInitRecordAssignment(ExpressionRecordAccess eRecAccess, Expression exp, CharSequence ref) {
		var mapLHStoRHS = new KeyValue
		
        var record = eRecAccess.record
        var field = eRecAccess.field
        var recExp = ''''''
             
        while(! (record instanceof ExpressionVariable)) {
        	if(recExp.empty) recExp = '''«(record as ExpressionRecordAccess).field.name»'''
            else recExp = '''«(record as ExpressionRecordAccess).field.name».''' + recExp
            record = (record as ExpressionRecordAccess).record
        }
		val varExp = record as ExpressionVariable
		mapLHStoRHS.key = field.name
		mapLHStoRHS.value = ExpressionsParser::generateExpression(exp, ref).toString

		// modify key value data structure to JSON
		/*mapLHStoRHS.value = mapLHStoRHS.value.replaceAll("\"key\" : ","")
		mapLHStoRHS.value = mapLHStoRHS.value.replaceAll(", \"value\"","")		
		// check references to SUT and replace with FAST syntax
		for(elm : mapLocalSUTVarToDataInstance.keySet) {
			if(mapLHStoRHS.value.contains(elm+"."))
				mapLHStoRHS.value = mapLHStoRHS.value.replaceFirst(elm, "setup.suts['" + elm + "']")
		}*/
		
		// check references to Step outputs and replace with FAST syntax
		for(elm : mapLocalStepInstance.keySet) {
			if(mapLHStoRHS.value.contains(elm+".output")) {
				mapLHStoRHS.value = mapLHStoRHS.value.replaceAll(elm+".output", "steps.out['" + elm + "']")
				// Custom String Updates for FAST Syntax Peculiarities! TODO investigate solution?
				// map-var['key'] + "[0]" -> map-var['key'][0] 
				mapLHStoRHS.value = mapLHStoRHS.value.replaceAll(Pattern.quote("] + \"["), "][") // ("\\] + \"\\[","\\]\\[")
				mapLHStoRHS.value = mapLHStoRHS.value.replaceAll("\\]\"","]")
			}
		}
		// replace references to global variables with FAST syntax
		for(elm : mapLocalDataVarToDataInstance.keySet) {
			if(mapLHStoRHS.value.contains(elm)) {
				mapLHStoRHS.value = mapLHStoRHS.value.replaceAll(elm, "global.params['" + elm + "']")
			}
		}
		// name of variable instance: varExp.variable.name
		return mapLHStoRHS
	}
	// End Expression Handler //
	
	def addMapSUTInstanceToFile(String key, String value) {
		if(mapSUTInstanceToFile.containsKey(key)) 
			mapSUTInstanceToFile.get(key).add(value)
		else { 
			mapSUTInstanceToFile.put(key, new ArrayList)
			mapSUTInstanceToFile.get(key).add(value)	
		}
	}
		
	def addMapDataInstanceToFile(String key, String value) {
		if(mapDataInstanceToFile.containsKey(key)) 
			mapDataInstanceToFile.get(key).add(value)
		else { 
			mapDataInstanceToFile.put(key, new ArrayList)
			mapDataInstanceToFile.get(key).add(value)	
		}
	}
	
	def addMapLocalSUTVarToDataInstance(String key, String value) {
		if(mapLocalSUTVarToDataInstance.containsKey(key)) 
			mapLocalSUTVarToDataInstance.get(key).add(value)
		else { 
			mapLocalSUTVarToDataInstance.put(key, new ArrayList)
			mapLocalSUTVarToDataInstance.get(key).add(value)
		}
	}
	
	def addMapLocalStepInstance(String key, String value) {
		if(mapLocalStepInstance.containsKey(key)) 
			mapLocalStepInstance.get(key).add(value)
		else {
			mapLocalStepInstance.put(key, new ArrayList)
			mapLocalStepInstance.get(key).add(value)
		}
	}
	
	def addMapLocalDataVarToDataInstance(String key, String value) {
		if(mapLocalDataVarToDataInstance.containsKey(key)) 
			mapLocalDataVarToDataInstance.get(key).add(value)
		else { 
			mapLocalDataVarToDataInstance.put(key, new ArrayList)
			mapLocalDataVarToDataInstance.get(key).add(value)
		}
	}

	def generateJSONDataAndVFDFiles(String testDefFilePath, IFileSystemAccess2 fsa, TSMain modelInst) {
		var txt = ''''''
		// val modelInst = _resource.allContents.head as TSMain
		
		// Process TSPEC Imports and parse them
		for(imp : modelInst.imports) {
			val inputResource = EcoreUtil2.getResource(_resource, imp.importURI)
			var input = inputResource.allContents.head
			var JSONDataFileContents = new ArrayList<JSONData>
			if( input instanceof nl.esi.comma.inputspecification.inputSpecification.Main) {
				if(input.model instanceof APIDefinition) {
					val apiDef = input.model as APIDefinition
					var dataInst = new JSONData
					for(act : apiDef.initActions) {
						if(	act instanceof AssignmentAction || 
							act instanceof RecordFieldAssignmentAction) {
							var mapLHStoRHS = generateInitAssignmentAction(act)
							dataInst.getKvList.add(mapLHStoRHS)
						}
					}
					// dataInst.display
					JSONDataFileContents.add(dataInst)
				} else if(input.model instanceof SUTDefinition) {
					val sutDef = input.model as SUTDefinition
					// generate XML-File! => vfd.xml
					fsa.generateFile(testDefFilePath + "vfd.xml", generateVFDFile(sutDef))
				}
			}

			// Merge Contents and Generate JSON File //
			
			// ASSUMPTION: Data Extensions on Record Fields of Steps API should not overlap 
			// with their initialization in *.params, i.e. should not init same record field. 
			for(dataInst : JSONDataFileContents) {
				for(mapLHStoRHS : dataInst.kvList) {
					// System.out.println("Chekcing " + mapLHStoRHS.key)
					var mapLHStoRHS_ = getExtensions(mapLHStoRHS.key)
					// System.out.println(" Got Extension for Key: " + mapLHStoRHS.key)
					//for(elm: mapLHStoRHS_) elm.display
					// check that mapLHStoRHS_ is not empty => get file name from step instance list
					// else call function to get file name
					// Reason: 
					//		the map data structure SUT to File name, 
					// 		does not consider new data files due to data extension in steps 
					var String fileName = new String
					
					if(!mapLHStoRHS_.isEmpty) {
						for(stepId : mapLHStoRHS_.keySet) {
							fileName = getStepInstanceFileName(stepId)
							var fileContents = mapLHStoRHS.value
							System.out.println("Generating File" + fileName+ " For Step " + stepId)
							for(elm : mapLHStoRHS_.get(stepId)) 
							{
								var str = '''"«elm.key»" : «elm.value»'''
								//var StringBuilder b = new StringBuilder(mapLHStoRHS.value);
								var StringBuilder b = new StringBuilder(fileContents);
								//b.replace(mapLHStoRHS.value.lastIndexOf("}"), mapLHStoRHS.value.lastIndexOf("}"), "," + str);
								b.replace(fileContents.lastIndexOf("}"), fileContents.lastIndexOf("}"), "," + str);
								fileContents = b.toString();
								//mapLHStoRHS.value = b.toString();
							}
							//fsa.generateFile(fileName, mapLHStoRHS.value)
							fsa.generateFile(fileName, fileContents)
						}
					} else { 
						fileName = getFileName(mapLHStoRHS.key)
						fsa.generateFile(fileName, mapLHStoRHS.value)
					}
				}
				dataInst.display
			}
		}
		
		return txt
	}
	
	def String getStepInstanceFileName(String step_id) {
		for(elm : listStepInstances) {
			if(elm.id.equals(step_id)) {
				return elm.inputFile
			}
		}
		return new String
	}
	
	def String getFileName(String varName) {
		for(step : listStepInstances) {
			if(step.variableName.equals(varName)) {
				return step.inputFile.replaceAll(".json", "_" + step.id + ".json")
			}
		}
		for(key : mapDataInstanceToFile.keySet) {
			if(key.equals(varName)) {
				return mapDataInstanceToFile.get(key).head
			}
		}
		for(key : mapSUTInstanceToFile.keySet) {
			var fname = mapSUTInstanceToFile.get(key).head
			//System.out.println("Checking: " + fname + " map key entry: " + key)
			if(key.equals(varName)) {
				return fname
			}
		}
		return "undefined.json"
	}
	
	def getExtensions(String varName) {
		var mapListOfKeyValue = new HashMap<String,List<KeyValue>>
		//System.out.println(" Getting Extension for Variable: " + varName)
		for(step : listStepInstances) {
			if(step.variableName.equals(varName)) {
				mapListOfKeyValue.put(step.id,step.parameters)
				// return step.parameters
			}
		}
		/*for(k : mapListOfKeyValue.keySet) {
			System.out.println(" ++ KEY : " + k)
			for(elm : mapListOfKeyValue.get(k)) {
				System.out.println(" ++ Value : " + elm.key + " -> " + elm.value)
			}
		}*/
		//System.out.println(" Extension: " + mapListOfKeyValue)
		return mapListOfKeyValue //new ArrayList<KeyValue>
	}
	
	def String getFileExtension(String varName) {
		for(step : listStepInstances) {
			if(step.variableName.equals(varName))
				return step.inputFile			
		}
		return new String
	}
	
	def generateFASTScenarioFile() {
		var txt = 
		'''
		in.data.global_parameters = {
			«FOR key : mapLocalDataVarToDataInstance.keySet SEPARATOR ''','''»
				"«key»" : «mapLocalDataVarToDataInstance.get(key).head»
			«ENDFOR»
		}
		
		in.data.suts = [
			«FOR elm : mapLocalSUTVarToDataInstance.keySet SEPARATOR ''','''»
				«mapLocalSUTVarToDataInstance.get(elm).head»
			«ENDFOR»
		]
		
		in.data.steps = [
			«FOR elm : listStepInstances SEPARATOR ''','''»
				{ "id" : "«elm.id»", "type" : "«elm.type.replaceAll("_",".")»", "input_file" : "«elm.inputFile»" }
			«ENDFOR»
		]
		'''
		return txt
	}
	
	def generateVFDFile(SUTDefinition sDef) {
		var def = sDef.generic.virtualFabDefinition
		var xsi = sDef.generic.XSI
		var loc = sDef.generic.schemaLocation
		var title = sDef.generic.title
		var sutsname = sDef.sut.name
		var sutsdesc = sDef.sut.desc
		'''
		<?xml version="1.0" encoding="UTF-8"?>
		<VirtualFabDefinition:VirtualFabDefinition xmlns:VirtualFabDefinition="«def»" xmlns:xsi="«xsi»" xsi:schemaLocation="«loc»">
		  <Header>
		    <Title>«title»</Title>
		    <CreateTime>2022-03-03T09:12:12</CreateTime>
		  </Header>
		  <Definition>
		    <Name>«sutsname»</Name>
		    <Description>«sutsdesc»</Description>
		    <SUTList>
		    «FOR sut : sDef.sut.sutDefRef»
		    	«IF sut instanceof TWINSCANKT»
		    		«generateTwinScanTxt(sut)»
		    	«ELSEIF sut instanceof LISVCP»
		    		«generateLisTxt(sut)»
		    	«ENDIF»
		    «ENDFOR»
		    </SUTList>
		  </Definition>
		</VirtualFabDefinition:VirtualFabDefinition>
		'''
	}
	
	def generateTwinScanTxt(TWINSCANKT ts) {
		var name = ts.name
		var type = ts.type
		var scn_param_name = ts.scenarioParameterName
		var machine_id = ts.machineID
		var cpu = ts.CPU
		var memory = ts.memory
		var machine_type = ts.machineType
		var useExisting = ts.useExisting
		var swbaseline = ts.baseline
		
		'''
		<SUT>
			<SutType>«type»</SutType>
			<Name>«name»</Name>
		    <ScenarioParameterName>«scn_param_name»</ScenarioParameterName>
		    <TWINSCAN-KT>
		    	<MachineID>«machine_id»</MachineID>
		        <CPU>«cpu»</CPU>
		        <Memory>«memory»</Memory>
		        <MachineType>«machine_type»</MachineType>
		        <UseExisting>«useExisting»</UseExisting>
		        <Baseline>«swbaseline»</Baseline>
		        «IF !ts.options.empty»
		        <OptionList>
		        «FOR elm : ts.options»
		        	<Option>
		        		<OptionName>«elm.optionname»</OptionName>
		        		<OptionValue>«elm.value»</OptionValue>
		        		<IsSVP>«elm.isIsSVP»</IsSVP>
		        	</Option>
		        «ENDFOR»
		        </OptionList>
		        «ENDIF»
		        «IF !ts.commands.empty»
		        <RunCommands>
		        	<PostConfiguration>
		            	<CommandList>
		                	«FOR elm : ts.commands»
		                	<Command>«elm»</Command>
		                	«ENDFOR»
		              	</CommandList>
		            </PostConfiguration>
		         </RunCommands>
		         «ENDIF»
			</TWINSCAN-KT>
		</SUT>
		'''
	}
	
	def generateLisTxt(LISVCP lis) {
		var name = lis.name
		var type = lis.type
		var scn_param_name = lis.scenarioParameterName
		var address = lis.address
		
		'''
		      <SUT>
		        <SutType>«type»</SutType>
		        <Name>«name»</Name>
		        <ScenarioParameterName>«scn_param_name»</ScenarioParameterName>
		        <LIS-VCP>
		          <Address>«address»</Address>
		          <JobConfigList>
		          «FOR elm : lis.jobConfigList»
		            <JobConfig>
		              <ApplicationId>«elm.appID»</ApplicationId>
		              <FunctionId>«elm.fnId»</FunctionId>
		              <ActiveDocumentCollection>«elm.isActDocColl»</ActiveDocumentCollection>
		            </JobConfig>
		          «ENDFOR»
		          </JobConfigList>
		        </LIS-VCP>
		      </SUT>
		'''
	}
	
	def displayParseResults() {
		System.out.println(" ---- Map Data Instance To File ---- ")
		for(key : mapDataInstanceToFile.keySet) {
			System.out.println(" 	Key: " + key + " Value: " + mapDataInstanceToFile.get(key))
		}
		
		System.out.println(" ---- Map SUT Instance To File ---- ")
		for(key : mapSUTInstanceToFile.keySet) {
			System.out.println(" 	Key: " + key + " Value: " + mapSUTInstanceToFile.get(key))
		}
		
		System.out.println(" ---- Map Local Data Var To Data Instance ---- ")
		for(key : mapLocalDataVarToDataInstance.keySet) {
			System.out.println(" 	Key: " + key + " Value: " + mapLocalDataVarToDataInstance.get(key))
		}
		
		System.out.println(" ---- Map SUT Var To Data Instance ---- ")
		for(key : mapLocalSUTVarToDataInstance.keySet) {
			System.out.println(" 	Key: " + key + " Value: " + mapLocalSUTVarToDataInstance.get(key))
		}
		
		System.out.println(" ---- Map Step Instance ---- ")
		for(key : mapLocalStepInstance.keySet) {
			System.out.println(" 	Key: " + key + " Value: " + mapLocalStepInstance.get(key))
		}
		
		System.out.println(" ------------------ STEPS ------------------")
		for(st : listStepInstances) {
			System.out.println("	step-id: " + st.id + " type: " + st.type)
			System.out.println("	input: " + st.inputFile)
			System.out.println("	var: " + st.variableName)
			for(param : st.parameters)
				System.out.println("	parameters: " + param.key + " -> " + param.value)
		}		
	}
}