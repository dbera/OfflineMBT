/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.scenarios.validation

import nl.esi.comma.actions.actions.AnyEvent
import nl.esi.comma.scenarios.scenarios.Scenario
import nl.esi.comma.scenarios.scenarios.Scenarios
import nl.esi.comma.scenarios.scenarios.ScenariosPackage
import nl.esi.comma.types.types.Import
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ScenariosValidator extends AbstractScenariosValidator {
	
	@Check
	override checkImportForValidity(Import imp){
		
	}
	
	@Check
	def checkDuplicatedNamesInScenarios(Scenarios s){
		checkForNameDuplications(s.scenarios, "scenario", null)
	}

	// Check Disabled: DB
	// Command can be follwed by Arguments and then a reply.
	// TODO Fix and Enable
	/*
	@Check
	def checkReply(CommandReply r){
		if(r.command !== null){
			error("Reference to command is not allowed", ActionsPackage.Literals.COMMAND_REPLY__COMMAND)
		}
		
		val scenario = r.eContainer as Scenario 
		val index = scenario.events.indexOf(r)
		
		if( (index == 0) || !(scenario.events.get(index - 1) instanceof CommandEvent) ){
			error("Reply must be preceded by a command", scenario, ScenariosPackage.Literals.SCENARIO__EVENTS, index)
		}
	}
	*/
	
	// Check Disabled: DB
	// Command can be follwed by Arguments and then a reply.
	// TODO Fix and Enable
	/*
	@Check
	def checkCommand(CommandEvent c){
		val scenario = c.eContainer as Scenario 
		val index = scenario.events.indexOf(c)
		
		if( (index < scenario.events.size - 1) && !(scenario.events.get(index + 1) instanceof CommandReply) ){
			error("Command must be followed by a reply", scenario, ScenariosPackage.Literals.SCENARIO__EVENTS, index)
		}
	}*/
	
	@Check
	def checkAny(AnyEvent a){
		val scenario = a.eContainer as Scenario 
		val index = scenario.events.indexOf(a)
	
		error("AnyEvent cannot be used in scenarios", scenario, ScenariosPackage.Literals.SCENARIO__EVENTS, index)
	}
}
