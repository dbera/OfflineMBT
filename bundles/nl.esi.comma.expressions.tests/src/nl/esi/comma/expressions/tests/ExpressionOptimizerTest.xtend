/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.tests

import com.google.inject.Inject
import nl.esi.comma.expressions.evaluation.ExpressionOptimizer
import nl.esi.comma.expressions.expression.Expressions
import nl.esi.comma.types.utilities.EcoreUtil3
import org.eclipse.xtext.resource.SaveOptions
import org.eclipse.xtext.serializer.ISerializer
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

@ExtendWith(InjectionExtension)
@InjectWith(ExpressionInjectorProvider)
class ExpressionOptimizerTest {
    @Inject
    ParseHelper<Expressions> parser

    @Inject
    ISerializer serializer

    val SAVE_OPTIONS = SaveOptions.newBuilder.format.options

    protected def void assertOptimize(String expected, String input) {
        val expressions = parser.parse(input)
        Assertions.assertTrue(expressions.eResource.errors.isEmpty, '''Unexpected errors in input: «expressions.eResource.errors.join(", ")»''')
        Assertions.assertEquals(expressions.variables.size, expressions.variables.map[variable.name].toSet.size, 'Variables cannot be declared multiple times')
        val optimizer = new ExpressionOptimizer()
        val context = expressions.variables.toMap([variable], [expression])
        for (assignment : expressions.variables.reject[expression === null]) {
            assignment.expression = optimizer.optimize(assignment.expression) [ varExpr |
                return context.get(varExpr.variable)
            ]
//            context.put(assignment.variable, assignment.expression)
        }
        val actualFormatted = serializer.serialize(EcoreUtil3.unformat(expressions), SAVE_OPTIONS)
        val expectedExprs = parser.parse(expected)
        Assertions.assertTrue(expectedExprs.eResource.errors.isEmpty, '''Unexpected errors in input: «expectedExprs.eResource.errors.join(", ")»''')
        val expectedFormatted = serializer.serialize(EcoreUtil3.unformat(expectedExprs), SAVE_OPTIONS)
        Assertions.assertEquals(expectedFormatted, actualFormatted)
    }

    @Test
    def void complexExpression() {
        val types = '''
            record T {
                int ti
                bool tb
                int[] tv
            }
        '''
        assertOptimize('''
            «types»
            bool a
            bool b = not a

            T t = T {
                ti = 5,
                tb = true or ((not a) and true)
            }
        ''', '''
            «types»
            bool a
            bool b = not a

            T t = T {
                ti = (1 + 2) * 3 - 4,
                tb = (1 == 1 and 2 == 2) or (b and 3 == 3)
            }
        ''')
//        assertOptimize('''
//            «types»
//            T step1 = T {
//                tb = true
//            }
//            T step2 = T {
//                tv = <int[]> [ step1.ti ]
//            }
//            T step3 = T {
//                ti = step1.ti
//            }
//            T step4 = T {
//                ti = step1.ti + 1
//            }
//        ''', '''
//            «types»
//            T step1 = T {
//                tb = true
//            }
//            T step2 = T {
//                tv = <int[]> [ step1.ti ]
//            }
//            T step3 = T {
//                ti = get(step2.tv, 0)
//            }
//            T step4 = T {
//                ti = step3.ti + 1
//            }
//        ''')
//        assertOptimize('''
//            «types»
//            T step1 = T {
//                tv = <int[]> [ ]
//            }
//            T step2 = T {
//                ti = get(step1.tv, 5)
//            }
//            T step3 = T {
//                ti = get(step1.tv, 5) + 1
//            }
//        ''', '''
//            «types»
//            T step1 = T {
//                tv = <int[]> [ ]
//            }
//            T step2 = T {
//                ti = get(step1.tv, 1 + 4)
//            }
//            T step3 = T {
//                ti = step2.ti + 1
//            }
//        ''')
    }

    @Test
    def void expressionVariable() {
        // Resolved variable
        assertOptimize('''
            bool a = false
            bool b = false
        ''', '''
            bool a = false
            bool b = a
        ''')
        // Unresolved variable
        assertOptimize('''
            bool a
            bool b = a
            bool c = a
        ''', '''
            bool a
            bool b = a
            bool c = b
        ''')
    }

    @Test
    def void expressionRecordAccess() {
        val types = '''
            record T {
                int ti
                bool tb
            }
        '''
        // Resolved variable
        assertOptimize('''
            «types»
            int a = 1
            T b = T {
                ti = 1
            }
            int c = 1
        ''', '''
            «types»
            int a = 1
            T b = T {
                ti = a
            }
            int c = b.ti
        ''')
        // Unresolved variable
        assertOptimize('''
            «types»
            T a
            int b = a.ti
        ''', '''
            «types»
            T a
            int b = a.ti
        ''')
        // Unresolved field
        assertOptimize('''
            «types»
            T a = T {
                tb = false
            }
            T b = T {
                ti = a.ti
            }
            int c = a.ti
        ''', '''
            «types»
            T a = T {
                tb = false
            }
            T b = T {
                ti = a.ti
            }
            int c = b.ti
        ''')
    }

    // ExpressionUnary

    @Test
    def void expressionBracket() {
        // Constants
        assertOptimize('int a = 1', 'int a = (1)')
        // Resolved variable
        assertOptimize('''
            bool a = true
            bool b = true
        ''', '''
            bool a = true
            bool b = (a)
        ''')
        // Unresolved variable
        assertOptimize('''
            bool a
            bool b = a
        ''', '''
            bool a
            bool b = (a)
        ''')
    }

    @Test
    def void expressionMinus() {
        assertOptimize('int a = -1', 'int a = -1')
        assertOptimize('int a = -1.0', 'int a = -1.0')
    }

    @Test
    def void exprNot() {
        assertOptimize('bool b = false', 'bool b = not true')
        assertOptimize('bool b = true', 'bool b = not false')
        // Resolved variable
        assertOptimize('''
            bool a = false
            bool b = true
            bool c = false
        ''', '''
            bool a = false
            bool b = not a
            bool c = not b
        ''')
        // Unresolved variable
        assertOptimize('''
            bool a
            bool b = not a
        ''', '''
            bool a
            bool b = not a
        ''')
    }

    @Test
    def void expressionPlus() {
        assertOptimize('int a = 1', 'int a = +1')
        assertOptimize('int a = 1.0', 'int a = +1.0')
        // Resolved variable
        assertOptimize('''
            int a
            int b = a
        ''', '''
            int a
            int b = +a
        ''')
        // Unresolved variable
        assertOptimize('''
            int a
            int b = a
        ''', '''
            int a
            int b = +a
        ''')
    }
}
