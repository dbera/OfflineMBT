/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.tests

import com.google.inject.Inject
import nl.esi.comma.expressions.evaluation.ExpressionEvaluator
import nl.esi.comma.expressions.expression.Expressions
import nl.esi.comma.types.utilities.EcoreUtil3
import org.eclipse.xtext.resource.SaveOptions
import org.eclipse.xtext.serializer.ISerializer
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

@ExtendWith(InjectionExtension)
@InjectWith(ExpressionInjectorProvider)
class ExpressionEvaluatorTest {
    @Inject
    ParseHelper<Expressions> parser

    @Inject
    ISerializer serializer

    val SAVE_OPTIONS = SaveOptions.newBuilder.format.options

    protected def void assertEval(String expected, String input) {
        val expressions = parser.parse(input)
        Assertions.assertTrue(expressions.eResource.errors.isEmpty, '''Unexpected errors in input: «expressions.eResource.errors.join(", ")»''')
        Assertions.assertEquals(expressions.variables.size, expressions.variables.map[variable.name].toSet.size, 'Variables cannot be declared multiple times')
        val evaluator = new ExpressionEvaluator()
        val context = expressions.variables.toMap([variable], [expression])
        for (assignment : expressions.variables.reject[expression === null]) {
            assignment.expression = evaluator.evaluate(assignment.expression) [ varExpr |
                return context.get(varExpr.variable)
            ]
        }
        val actualFormatted = serializer.serialize(EcoreUtil3.unformat(expressions), SAVE_OPTIONS)
        val expectedExprs = parser.parse(expected)
        Assertions.assertTrue(expectedExprs.eResource.errors.isEmpty, '''Unexpected errors in input: «expectedExprs.eResource.errors.join(", ")»''')
        val expectedFormatted = serializer.serialize(EcoreUtil3.unformat(expectedExprs), SAVE_OPTIONS)
        Assertions.assertEquals(expectedFormatted, actualFormatted)
    }

    @Test
    def void complexExpression() {
        val types = '''
            record T {
                int ti
                bool tb
            }
        '''
        assertEval('''
            «types»
            bool a
            bool b = not a

            T t = T {
                ti = 5,
«««             TODO: Should variable references always be put between parenthesis?
«««             i.e. tb = true or ( ( not a ) and true )
                tb = true or ( not a and true )
            }
        ''', '''
            «types»
            bool a
            bool b = not a

            T t = T {
                ti = (1 + 2) * 3 - 4,
                tb = (1 == 1 and 2 == 2) or (b and 3 == 3)
            }
        ''')
    }

    @Test
    def void expressionVariable() {
        // Resolved variable
        assertEval('''
            bool a = false
            bool b = false
        ''', '''
            bool a = false
            bool b = a
        ''')
        // Unresolved variable
        assertEval('''
            bool a
            bool b = a
            bool c = a
        ''', '''
            bool a
            bool b = a
            bool c = b
        ''')
    }

    @Test
    def void expressionRecordAccess() {
        val types = '''
            record T {
                int ti
                bool tb
            }
        '''
        // Resolved variable
        assertEval('''
            «types»
            int a = 1
            T b = T {
                ti = 1
            }
            int c = 1
        ''', '''
            «types»
            int a = 1
            T b = T {
                ti = a
            }
            int c = b.ti
        ''')
        // Unresolved variable
        assertEval('''
            «types»
            T a
            int b = a.ti
        ''', '''
            «types»
            T a
            int b = a.ti
        ''')
        // Unresolved field
        assertEval('''
            «types»
            T a = T {
                tb = false
            }
            T b = T {
                ti = a.ti
            }
            int c = a.ti
        ''', '''
            «types»
            T a = T {
                tb = false
            }
            T b = T {
                ti = a.ti
            }
            int c = b.ti
        ''')

//        assertEval('''
//            «types»
//            step3 = symbolA + 1
//        ''', '''
//            «types»
//            symbolA
//            step1 = [
//                synmbolA
//            ]
//            step2 = get(step1, 0)
//            step3 = step2 + 1
//        ''')
//
//        assertEval('''
//            «types»
//            step3 = get(step1, 5) + 1
//        ''', '''
//            «types»
//            [] step1
//            step2 = get(step1, 1 + 4)
//            step3 = step2 + 1
//        ''')
//        
//        'a = "list["  + toString(10) + "].item"' -> 'list[10].item'
    }

    // ExpressionUnary

    @Test
    def void expressionBracket() {
        // Constants
        assertEval('int a = 1', 'int a = (1)')
        // Resolved variable
        assertEval('''
            bool a = true
            bool b = true
        ''', '''
            bool a = true
            bool b = (a)
        ''')
        // Unresolved variable
        assertEval('''
            bool a
            bool b = (a)
        ''', '''
            bool a
            bool b = (a)
        ''')
    }

    @Test
    def void expressionMinus() {
        assertEval('int a = -1', 'int a = -1')
        assertEval('int a = -1.0', 'int a = -1.0')
    }

    @Test
    def void exprNot() {
        assertEval('bool b = false', 'bool b = not true')
        assertEval('bool b = true', 'bool b = not false')
        // Resolved variable
        assertEval('''
            bool a = false
            bool b = true
            bool c = false
        ''', '''
            bool a = false
            bool b = not a
            bool c = not b
        ''')
        // Unresolved variable
        assertEval('''
            bool a
            bool b = not a
        ''', '''
            bool a
            bool b = not a
        ''')
    }

    @Test
    def void expressionPlus() {
        assertEval('int a = 1', 'int a = +1')
        assertEval('int a = 1.0', 'int a = +1.0')
        // Resolved variable
        assertEval('''
            int a
            int b = a
        ''', '''
            int a
            int b = +a
        ''')
        // Unresolved variable
        assertEval('''
            int a
            int b = a
        ''', '''
            int a
            int b = +a
        ''')
    }
}
