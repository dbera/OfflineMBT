/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.tests

import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test

class ExpressionEvaluatorFunctionTest extends ExpressionEvaluatorTestBase {
    static val TYPES = '''
        record T {
            int ti
            real tr
            bool tb
            string ts
            int[] tis
            string[] tss
            map<int, string> ti2s
        }
    '''
    @Test
    def void isEmpty() {
        assertEval('''
            «TYPES»
            T t = T {
                tis = <int[]> [],
                tss = <string[]> [ "Hello", "Test!" ]
            }
            bool empty = true
            bool notEmpty = false
        ''', '''
            «TYPES»
            T t = T {
                tis = <int[]> [],
                tss = <string[]> [ "Hello", "Test!" ]
            }
            bool empty = isEmpty(t.tis)
            bool notEmpty = isEmpty(t.tss)
        ''')
    }

    @Test
    def void size() {
        assertEval('''
            «TYPES»
            T t = T {
                tis = <int[]> [],
                tss = <string[]> [ "Hello", "Test!" ]
            }
            int sizeInt = 0
            int sizeString = 2
        ''', '''
            «TYPES»
            T t = T {
                tis = <int[]> [],
                tss = <string[]> [ "Hello", "Test!" ]
            }
            int sizeInt = size(t.tis)
            int sizeString = size(t.tss)
        ''')
    }

    @Test
    def void contains() {
        assertEval('''
            «TYPES»
            T t = T {
                tis = <int[]> [],
                tss = <string[]> [ "Hello", "Test!" ]
            }
            bool contains = true
            bool notContains = false
        ''', '''
            «TYPES»
            T t = T {
                tis = <int[]> [],
                tss = <string[]> [ "Hello", "Test!" ]
            }
            bool contains = contains(t.tss, "Hello")
            bool notContains = contains(t.tis, "1")
        ''')
    }

    @Test
    def void add() {
        assertEval('''
            «TYPES»
            T t1 = T { 
                tss = <string[]> [ "Hello" ]
            }
            T t2 = T { 
                tss = <string[]> [ "Hello" , "Test!" ]
            }
        ''', '''
            «TYPES»
            T t1 = T {
                tss = <string[]> [ "Hello" ]
            }
            T t2 = T {
                tss = add(t1.tss, "Test!")
            }
        ''')
    }

    @Test
    def void asReal() {
        assertEval('''
            «TYPES»
            real r1 = 1.0
            real r2 = 1234.0
        ''', '''
            «TYPES»
            real r1 = asReal(1)
            real r2 = asReal(1234)
        ''')
    }

    @Test
    def void abs() {
        assertEval('''
            «TYPES»
            int i1 = 1
            int i2 = 1
            real r1 = 1.0
            real r2 = 1.0
        ''', '''
            «TYPES»
            int i1 = abs(1)
            int i2 = abs(-1)
            real r1 = abs(1.0)
            real r2 = abs(-1.0)
        ''')
    }

    @Test
    def void hasKey() {
        assertEval('''
            «TYPES»
            T t = T {
                ti2s = <map<int, string>> { 0 -> "0", 1 -> "1" }
            }
            bool b1 = true
            bool b2 = false
        ''', '''
            «TYPES»
            T t = T {
                ti2s = <map<int, string>> { 0 -> "0", 1 -> "1" }
            }
            bool b1 = hasKey(t.ti2s, 0)
            bool b2 = hasKey(t.ti2s, 2)
        ''')
    }

    @Test
    def void deleteKey() {
        assertEval('''
            «TYPES»
            T t1 = T {
                ti2s = <map<int, string>> { 0 -> "0", 1 -> "1" }
            }
            T t2 = T {
                ti2s = <map<int, string>> { 0 -> "0" }
            }
        ''', '''
            «TYPES»
            T t1 = T {
                ti2s = <map<int, string>> { 0 -> "0", 1 -> "1" }
            }
            T t2 = T {
                ti2s = deleteKey(t1.ti2s, 1)
            }
        ''')
    }

    @Test
    def void get() {
        assertEval('''
            «TYPES»
            T t = T {
                tss = <string[]> [ "0", "1", "2", "3" ]
            }
            string s = "1"
        ''', '''
            «TYPES»
            T t = T {
                tss = <string[]> [ "0", "1", "2", "3" ]
            }
            string s = get(t.tss, 1)
        ''')
    }

    @Test
    def void getOutOfBounds() {
        Assertions.assertThrows(IndexOutOfBoundsException)[eval('''
            «TYPES»
            T t = T {
                tss = <string[]> [ "0" ]
            }
            string s = get(t.tss, 1)
        ''')]
    }

    @Test
    def void at() {
        assertEval('''
            «TYPES»
            T t1 = T {
                tis = <int[]>[ 1, 2 ],
                tss = <string[]>[ "Hello", "World!" ]
            }
            T t2 = T {
                tis = <int[]>[ 3, 2 ],
                tss = <string[]>[ "Hello", "Test!" ]
            }
        ''', '''
            «TYPES»
            T t1 = T {
                tis = <int[]>[ 1, 2 ],
                tss = <string[]>[ "Hello", "World!" ]
            }
            T t2 = T {
                tis = at(t1.tis, 0, 3),
                tss = at(t1.tss, 1, "Test!")
            }
        ''')
    }

    @Test
    def void atOutOfBounds() {
        Assertions.assertThrows(IndexOutOfBoundsException)[eval('''
            «TYPES»
            T t1 = T {
                tis = <int[]>[ 1, 2 ]
            }
            T t2 = T {
                tis = at(t1.tis, 2, 3)
            }
        ''')]
    }

    @Test
    def void toStringTest() {
        assertEval('''
            «TYPES»
            string s1 = "1"
            string s2 = "-1"
        ''', '''
            «TYPES»
            string s1 = toString(1)
            string s2 = toString(-1)
        ''')
    }

    @Test
    def void concat() {
        assertEval('''
            «TYPES»
            T t1 = T {
                tss = <string[]> [ "0", "1", "2", "3" ]
            }
            T t2 = T {
                tss = <string[]> [ "4", "5", "6", "7" ]
            }
            T t3 = T {
                tss = <string[]> [ "0", "1", "2", "3", "4", "5", "6", "7" ]
            }
        ''', '''
            «TYPES»
            T t1 = T {
                tss = <string[]> [ "0", "1", "2", "3" ]
            }
            T t2 = T {
                tss = <string[]> [ "4", "5", "6", "7" ]
            }
            T t3 = T {
                tss = concat(t1.tss, t2.tss)
            }
        ''')
    }

    @Test
    def void range() {
        assertEval('''
            «TYPES»
            T t1 = T {
                tis = <int[]>[ 0, 1, 2 ]
            }
            T t2 = T {
                tis = <int[]>[ 5, 6 ]
            }
            T t3 = T {
                tis = <int[]>[ 5, 8 ]
            }
            T t4 = T {
                tis = <int[]>[ 5, 8, 11 ]
            }
        ''', '''
            «TYPES»
            T t1 = T {
                tis = range(3)
            }
            T t2 = T {
                tis = range(5, 7)
            }
            T t3 = T {
                tis = range(5, 11, 3)
            }
            T t4 = T {
                tis = range(5, 12, 3)
            }
        ''')
    }
}
