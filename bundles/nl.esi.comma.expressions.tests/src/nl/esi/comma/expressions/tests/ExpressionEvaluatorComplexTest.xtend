/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.tests

import org.junit.jupiter.api.Test

class ExpressionEvaluatorComplexTest extends ExpressionEvaluatorTestBase {
    @Test
    def void recordsAndTypes() {
        val types = '''
            enum Count { ONE TWO THREE }

            record T {
                int ti
                real tr
                bool tb
                Count te
                string[] tss
                map<int, string> ti2s
            }
        '''
        assertEval('''
            «types»
            T t = T {
                ti = 1,
                tr = 1.1,
                tb = true,
                te = Count::TWO,
                tss = <string[]> [ "Hello", "World" ],
                ti2s = <map<int, string>> { 1 -> "Hello", 2 -> "World" }
            }
        ''', '''
            «types»
            T t = T {
                ti = 1,
                tr = 1.1,
                tb = true,
                te = Count::TWO,
                tss = <string[]> [ "Hello", "World" ],
                ti2s = <map<int, string>> { 1 -> "Hello", 2 -> "World" }
            }
        ''')
    }

    @Test
    def void variables() {
        val types = '''
            enum Count { ONE TWO THREE }

            record T {
                int ti
                real tr
                bool tb
                Count te
                string[] tss
                map<int, string> ti2s
            }
        '''
        // Resolved variable
        assertEval('''
            «types»
            int a = 1
            int b = 1
        ''', '''
            «types»
            int a = 1
            int b = a
        ''')
        // Unresolved variable
        assertEval('''
            «types»
            int a
            T t = T {
                ti = a
            }
        ''', '''
            «types»
            int a
            T t = T {
                ti = a
            }
        ''')
        // If 1 variable cannot be resolved, the result will be undefined
        assertEval('''
            «types»
            int a = 1
            bool b
            T t = T {
                ti = 1,
                tb = b
            }
        ''', '''
            «types»
            int a = 1
            bool b
            T t = T {
                ti = a,
                tb = b
            }
        ''')
    }

    @Test
    def void complexExpression() {
        val types = '''
            record T {
                int ti
                bool tb
                int[] tv
            }
        '''
        assertEval('''
            «types»
            bool a
            bool b = not a

            T t = T {
                ti = 5,
                tb = true or ((not a) and true)
            }
        ''', '''
            «types»
            bool a
            bool b = not a

            T t = T {
                ti = (1 + 2) * 3 - 4,
                tb = (1 == 1 and 2 == 2) or (b and 3 == 3)
            }
        ''')
        assertEval('''
            «types»
            T step1 = T {
                tb = true
            }
            T step2 = T {
                tv = <int[]> [ step1.ti ]
            }
            T step3 = T {
                ti = step1.ti
            }
            T step4 = T {
                ti = step1.ti + 1
            }
        ''', '''
            «types»
            T step1 = T {
                tb = true
            }
            T step2 = T {
                tv = <int[]> [ step1.ti ]
            }
            T step3 = T {
                ti = get(step2.tv, 1 - 1)
            }
            T step4 = T {
                ti = step3.ti + 1
            }
        ''')
        assertEval('''
            «types»
            T step1
            T step2 = T {
                ti = get(step1.tv, 5)
            }
            T step3 = T {
                ti = get(step1.tv, 5) + 1
            }
        ''', '''
            «types»
            T step1
            T step2 = T {
                ti = get(step1.tv, 1 + 4)
            }
            T step3 = T {
                ti = step2.ti + 1
            }
        ''')
    }

    @Test
    def void expressionVariable() {
        // Resolved variable
        assertEval('''
            bool a = false
            bool b = false
        ''', '''
            bool a = false
            bool b = a
        ''')
        // Unresolved variable
        assertEval('''
            bool a
            bool b = a
            bool c = a
        ''', '''
            bool a
            bool b = a
            bool c = b
        ''')
    }

    @Test
    def void expressionRecordAccess() {
        val types = '''
            record T {
                int ti
                bool tb
            }
        '''
        // Resolved variable
        assertEval('''
            «types»
            int a = 1
            T b = T {
                ti = 1
            }
            int c = 1
        ''', '''
            «types»
            int a = 1
            T b = T {
                ti = a
            }
            int c = b.ti
        ''')
        // Unresolved variable
        assertEval('''
            «types»
            T a
            int b = a.ti
        ''', '''
            «types»
            T a
            int b = a.ti
        ''')
        // Unresolved field
        assertEval('''
            «types»
            T a = T {
                tb = false
            }
            T b = T {
                ti = a.ti
            }
            int c = a.ti
        ''', '''
            «types»
            T a = T {
                tb = false
            }
            T b = T {
                ti = a.ti
            }
            int c = b.ti
        ''')
    }

    // ExpressionUnary

    @Test
    def void expressionBracket() {
        // Constants
        assertEval('int a = 1', 'int a = (1)')
        // Resolved variable
        assertEval('''
            bool a = true
            bool b = true
        ''', '''
            bool a = true
            bool b = (a)
        ''')
        // Unresolved variable
        assertEval('''
            bool a
            bool b = a
        ''', '''
            bool a
            bool b = (a)
        ''')
    }

    @Test
    def void expressionMinus() {
        assertEval('int a = -1', 'int a = -1')
        assertEval('int a = -1.0', 'int a = -1.0')
    }

    @Test
    def void exprNot() {
        assertEval('bool b = false', 'bool b = not true')
        assertEval('bool b = true', 'bool b = not false')
        // Resolved variable
        assertEval('''
            bool a = false
            bool b = true
            bool c = false
        ''', '''
            bool a = false
            bool b = not a
            bool c = not b
        ''')
        // Unresolved variable
        assertEval('''
            bool a
            bool b = not a
        ''', '''
            bool a
            bool b = not a
        ''')
    }

    @Test
    def void expressionPlus() {
        assertEval('int a = 1', 'int a = +1')
        assertEval('int a = 1.0', 'int a = +1.0')
        // Resolved variable
        assertEval('''
            int a
            int b = a
        ''', '''
            int a
            int b = +a
        ''')
        // Unresolved variable
        assertEval('''
            int a
            int b = a
        ''', '''
            int a
            int b = +a
        ''')
    }
}
