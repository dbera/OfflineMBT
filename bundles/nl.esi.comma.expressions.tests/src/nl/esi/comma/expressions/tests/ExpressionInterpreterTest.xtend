/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.tests

import com.google.inject.Inject
import nl.esi.comma.expressions.evaluation.ExpressionInterpreter
import nl.esi.comma.expressions.expression.Expressions
import nl.esi.comma.expressions.validation.ExpressionValidator
import nl.esi.comma.types.utilities.EcoreUtil3
import org.eclipse.xtext.resource.SaveOptions
import org.eclipse.xtext.serializer.ISerializer
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

@ExtendWith(InjectionExtension)
@InjectWith(ExpressionInjectorProvider)
class ExpressionInterpreterTest {
    @Inject
    ParseHelper<Expressions> parser

    @Inject
    ISerializer serializer

    val SAVE_OPTIONS = SaveOptions.newBuilder.format.options

    protected def void assertExec(String expected, String input) {
        val expressions = parser.parse(input)
        Assertions.assertTrue(expressions.eResource.errors.isEmpty, '''Unexpected errors in input: «expressions.eResource.errors.join(", ")»''')
        Assertions.assertEquals(expressions.variables.size, expressions.variables.map[variable.name].toSet.size, 'Variables cannot be declared multiple times')
        val interpreter = new ExpressionInterpreter()
        val context = expressions.variables.reverseView.toMap([variable], [expression])
        for (assignment : expressions.variables.reject[expression === null]) {
            val value = interpreter.execute(assignment.expression) [ varExpr |
                return context.get(varExpr.variable)
            ]
            val type = ExpressionValidator.typeOf(assignment.expression)
            assignment.expression = interpreter.createExpression(value, type)
            // context.put(assignment.variable, assignment.expression)
        }
        val actualFormatted = serializer.serialize(EcoreUtil3.unformat(expressions), SAVE_OPTIONS)
        val expectedExprs = parser.parse(expected)
        Assertions.assertTrue(expectedExprs.eResource.errors.isEmpty, '''Unexpected errors in input: «expectedExprs.eResource.errors.join(", ")»''')
        val expectedFormatted = serializer.serialize(EcoreUtil3.unformat(expectedExprs), SAVE_OPTIONS)
        Assertions.assertEquals(expectedFormatted, actualFormatted)
    }

    @Test
    def void recordsAndTypes() {
        val types = '''
            enum Count { ONE TWO THREE }

            record T {
                int ti
                real tr
                bool tb
                Count te
                string[] tss
                map<int, string> ti2s
            }
        '''
        assertExec('''
            «types»
            T t = T {
                ti = 1,
                tr = 1.1,
                tb = true,
                te = Count::TWO,
                tss = <string[]> [ "Hello", "World" ],
                ti2s = <map<int, string>> { 1 -> "Hello", 2 -> "World" }
            }
        ''', '''
            «types»
            T t = T {
                ti = 1,
                tr = 1.1,
                tb = true,
                te = Count::TWO,
                tss = <string[]> [ "Hello", "World" ],
                ti2s = <map<int, string>> { 1 -> "Hello", 2 -> "World" }
            }
        ''')
    }

    @Test
    def void variables() {
        val types = '''
            enum Count { ONE TWO THREE }

            record T {
                int ti
                real tr
                bool tb
                Count te
                string[] tss
                map<int, string> ti2s
            }
        '''
        // Resolved variable
        assertExec('''
            «types»
            int a = 1
            int b = 1
        ''', '''
            «types»
            int a = 1
            int b = a
        ''')
        // Unresolved variable
        assertExec('''
            «types»
            int a
            T t
        ''', '''
            «types»
            int a
            T t = T {
                ti = a
            }
        ''')
        // If 1 variable cannot be resolved, the result will be undefined
        assertExec('''
            «types»
            int a = 1
            bool b
            T t
        ''', '''
            «types»
            int a = 1
            bool b
            T t = T {
                ti = a,
                tb = b
            }
        ''')
    }

    @Test
    def void level1BasicTypes() {
        // Resolved variable
        assertExec('''
            bool v_and_1 = true
            bool v_and_2 = false
            bool v_or_1 = true
            bool v_or_2 = false
        ''', '''
            bool v_and_1 = true and true
            bool v_and_2 = true and false
            bool v_or_1 = false or true
            bool v_or_2 = false or false
        ''')
    }

    @Test
    def void level2BasicTypes() {
        // Resolved variable
        assertExec('''
            bool v_eq_int_1 = true
            bool v_eq_int_2 = false
            bool v_eq_real_1 = true
            bool v_eq_real_2 = false
            bool v_eq_string_1 = true
            bool v_eq_string_2 = false
            bool v_eq_null_1 = true
            bool v_eq_null_2 = false

            bool v_neq_int_1 = false
            bool v_neq_int_2 = true
            bool v_neq_real_1 = false
            bool v_neq_real_2 = true
            bool v_neq_string_1 = false
            bool v_neq_string_2 = true
            bool v_neq_null_1 = false
            bool v_neq_null_2 = true
        ''', '''
            bool v_eq_int_1 = 1 == 1
            bool v_eq_int_2 = 1 == 2
            bool v_eq_real_1 = 1.1 == 1.1
            bool v_eq_real_2 = 1.1 == 2.2
            bool v_eq_string_1 = "Hello" == "Hello"
            bool v_eq_string_2 = "Hello" == "World"
            bool v_eq_null_1 = null == null
            bool v_eq_null_2 = null == 1

            bool v_neq_int_1 = 1 != 1
            bool v_neq_int_2 = 1 != 2
            bool v_neq_real_1 = 1.1 != 1.1
            bool v_neq_real_2 = 1.1 != 2.2
            bool v_neq_string_1 = "Hello" != "Hello"
            bool v_neq_string_2 = "Hello" != "World"
            bool v_neq_null_1 = null != null
            bool v_neq_null_2 = null != 1
        ''')
    }

    @Test
    def void level3BasicTypes() {
        // Resolved variable
        assertExec('''
            bool v_gt_int_1 = true
            bool v_gt_int_2 = false
            bool v_gt_real_1 = true
            bool v_gt_real_2 = false
            bool v_geq_int_1 = true
            bool v_geq_int_2 = true
            bool v_geq_int_3 = false
            bool v_geq_real_1 = true
            bool v_geq_real_2 = true
            bool v_geq_real_3 = false

            bool v_lt_int_1 = true
            bool v_lt_int_2 = false
            bool v_lt_real_1 = true
            bool v_lt_real_2 = false
            bool v_leq_int_1 = true
            bool v_leq_int_2 = true
            bool v_leq_int_3 = false
            bool v_leq_real_1 = true
            bool v_leq_real_2 = true
            bool v_leq_real_3 = false
        ''', '''
            bool v_gt_int_1 = 2 > 1
            bool v_gt_int_2 = 1 > 1
            bool v_gt_real_1 = 2.2 > 1.1
            bool v_gt_real_2 = 2.2 > 2.2
            bool v_geq_int_1 = 2 >= 1
            bool v_geq_int_2 = 1 >= 1
            bool v_geq_int_3 = 1 >= 2
            bool v_geq_real_1 = 2.2 >= 1.1
            bool v_geq_real_2 = 1.1 >= 1.1
            bool v_geq_real_3 = 1.1 >= 2.2

            bool v_lt_int_1 = 1 < 2
            bool v_lt_int_2 = 1 < 1
            bool v_lt_real_1 = 1.1 < 2.2
            bool v_lt_real_2 = 1.1 < 1.1
            bool v_leq_int_1 = 1 <= 2
            bool v_leq_int_2 = 1 <= 1
            bool v_leq_int_3 = 2 <= 1
            bool v_leq_real_1 = 1.1 <= 2.2
            bool v_leq_real_2 = 1.1 <= 1.1
            bool v_leq_real_3 = 2.2 <= 1.1
        ''')
    }
    
    @Test
    def void level4BasicTypes() {
        // Resolved variable
        assertExec('''
            int v_add_int_1 = 3
            int v_add_int_2 = 6
            real v_add_real_1 = 3.3
            real v_add_real_2 = 6.6

            int v_sub_int_1 = 1
            int v_sub_int_2 = - 2
            int v_sub_int_3 = 2
            int v_sub_real_1 = 1.1
            int v_sub_real_2 = - 2.2
            int v_sub_real_3 = 1.3
        ''', '''
            int v_add_int_1 = 1 + 2
            int v_add_int_2 = 1 + 2 + 3
            real v_add_real_1 = 1.1 + 2.2
            real v_add_real_2 = 1.1 + 2.2 + 3.3

            int v_sub_int_1 = 2 - 1
            int v_sub_int_2 = 2 - 4
            int v_sub_int_3 = 10 - 5 - 3
            int v_sub_real_1 = 2.2 - 1.1
            int v_sub_real_2 = 2.2 - 4.4
            int v_sub_real_3 = 10.10 - 5.5 - 3.3
        ''')
    }
}
