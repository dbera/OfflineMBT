/*
 * generated by Xtext 2.36.0
 */
package nl.asml.matala.product.validation

import nl.esi.comma.types.types.Import
import nl.esi.comma.types.types.TypesPackage
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ProductValidator extends AbstractProductValidator {
	@Check
    override checkImportForValidity(Import imp) {
        if(!EcoreUtil2.isValidUri(imp, URI.createURI(imp.getImportURI()))) {
            error("Invalid resource", imp, TypesPackage.eINSTANCE.getImport_ImportURI());
        } else {
            /*val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
            if(! (r.allContents.head instanceof InterfaceDefinition ||
                r.allContents.head instanceof FeatureDefinition
            ))
                error("The imported resource is not an interface definition or a feature definition.", imp, TypesPackage.eINSTANCE.import_ImportURI)
        }*/
        }
    }
    
    
    /* STRANGE BUG: Output Vars are Empty. Appears in Input Vars. 
     * Not appearing as problem during product generation!
    */
    /*
    @Check
    public void checkInputOutputMapping(Product p) 
    {
        var outVarMap = new HashMap<String,List<String>>();
        var inVarMap  = new HashMap<String,List<String>>();
        
        for(var b : p.getBlock()) {
            System.out.println(" + Parsing Block: " + b.getName());
            for(var ov : b.getOutvars()) {
                if(outVarMap.containsKey(b.getName())) {
                    outVarMap.get(b.getName()).add(ov.getName());
                    System.out.println("    Added Output: " + ov.getName());
                }
                else {
                    var lst = new ArrayList<String>();
                    lst.add(ov.getName());
                    outVarMap.put(b.getName(), lst);
                    System.out.println("    Added Output to Existing: " + ov.getName());
                }
            }
            for(var iv : b.getInvars()) {
                System.out.println(" - Parsing Block: " + b.getName());
                if(inVarMap.containsKey(b.getName())) {
                    inVarMap.get(b.getName()).add(iv.getName());
                    System.out.println("    Added Input: " + iv.getName());
                }
                else {
                    var lst = new ArrayList<String>();
                    lst.add(iv.getName());
                    inVarMap.put(b.getName(), lst);
                    System.out.println("    Added Input to Existing: " + iv.getName());
                }
            }
        }
        
        System.out.println(" Debug in Var: " + inVarMap);
        System.out.println(" Debug out Var: " + outVarMap);
        
        for(var t : p.getTopology()) {
            for(var f : t.getFlow()) {
                for(var conn : f.getVarConn()) {
                    var lkey = conn.getVarRefLHS().getBlockRef().getName();
                    var lvalue = conn.getVarRefLHS().getVarRef().getName();
                    var rkey = conn.getVarRefRHS().getBlockRef().getName();
                    var rvalue = conn.getVarRefRHS().getVarRef().getName();
                    inVarMap.get(lkey).remove(lvalue);
                    outVarMap.get(rkey).remove(rvalue);
                }
            }
        }
        
        System.out.println(" Debug in Var: " + inVarMap);
        System.out.println(" Debug out Var: " + outVarMap);
        
        // Check what is not mapped. 
        var txt = new String();
        var isUnMapped = false;
        
        for(var k : inVarMap.keySet()) {
            if(!inVarMap.get(k).isEmpty()) {
                isUnMapped = true;
                txt += "\n block: " + k + " has input: "+ inVarMap.get(k) + "with no source \n";
            }
        }
        
        for(var k : outVarMap.keySet()) {
            if(!outVarMap.get(k).isEmpty()) {
                isUnMapped = true;
                txt += "\n block: " + k + " has output: "+ outVarMap.get(k) + "with no target \n";
            }
        }
        
        if(isUnMapped) {
            error("Missing Input-Output Connections: \n" + txt, 
                    ProductPackage.Literals.PRODUCT__TOPOLOGY);
        }
    }*/
	
}
