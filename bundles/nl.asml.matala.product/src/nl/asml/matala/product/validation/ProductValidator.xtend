/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.asml.matala.product.validation

import java.util.HashSet
import java.util.Set
import nl.asml.matala.product.product.Block
import nl.asml.matala.product.product.Function
import nl.asml.matala.product.product.ProductPackage
import nl.asml.matala.product.product.Update
import nl.esi.comma.actions.actions.ActionsPackage
import nl.esi.comma.actions.actions.AssignmentAction
import nl.esi.comma.actions.actions.ForAction
import nl.esi.comma.actions.actions.IfAction
import nl.esi.comma.actions.actions.RecordFieldAssignmentAction
import nl.esi.comma.expressions.expression.Expression
import nl.esi.comma.expressions.expression.ExpressionPackage
import nl.esi.comma.expressions.expression.ExpressionVariable
import nl.esi.comma.expressions.expression.Variable
import nl.esi.comma.types.types.Import
import nl.esi.comma.types.types.TypesPackage
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ProductValidator extends AbstractProductValidator {

    @Check
    override checkImportForValidity(Import imp) {
        if (!EcoreUtil2.isValidUri(imp, URI.createURI(imp.getImportURI()))) {
            error("Invalid resource", imp, TypesPackage.eINSTANCE.getImport_ImportURI());
        } else {
            /*val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
             * if(! (r.allContents.head instanceof InterfaceDefinition ||
             *     r.allContents.head instanceof FeatureDefinition
             * ))
             *     error("The imported resource is not an interface definition or a feature definition.", imp, TypesPackage.eINSTANCE.import_ImportURI)
             }*/
        }
    }

    /**
     * Prevent Duplicate Updates in Actions
     */
    @Check
    def preventDuplicationUpdatesActions(Function function) {
        for (update : function.updates) {
            val groupedByName = update.updateOutputVar.flatMap[it.fnOut].groupBy[it.ref.name]
            groupedByName.values.filter[size > 1].flatten.forEach [ output |                
                error(
                    "Duplicate output variable name: " + output.ref.name,
                    output, ProductPackage.Literals.VAR_REF__REF
                )
            ]
        }
    }

    /**
     * Check the duplication of variables in Inputs
     */
    @Check
    def checkInputDuplication(Block block) {
        val existingInputs = block.invars.groupBy[input|input.name]
        existingInputs.values.filter[size > 1].flatten.forEach [ input |
            error("Duplicate variable name in inputs: " + input.name, ProductPackage.Literals.BLOCK__INVARS,
                block.invars.indexOf(input))
        ]
    }

    /**
     * Check the duplication of variables in Outputs
     */
    @Check
    def checkOutputDuplication(Block block) {
        val existingOutputs = block.outvars.groupBy[output|output.name]
        existingOutputs.values.filter[size > 1].flatten.forEach [ output |
            error("Duplicate variable name in outputs: " + output.name, ProductPackage.Literals.BLOCK__OUTVARS,
                block.outvars.indexOf(output))
        ]
    }

    /**
     * Check the duplication of variables in Local
     */
    @Check
    def checkLocalDuplication(Block block) {
        val existingLocalvars = block.localvars.groupBy[localvars|localvars.name]
        existingLocalvars.values.filter[size > 1].flatten.forEach [ localvars |
            error("Duplicate variable name in local variables: " + localvars.name,
                ProductPackage.Literals.BLOCK__LOCALVARS, block.localvars.indexOf(localvars))
        ]
    }

    /**
     * All variables occurring in a guard expression must have been defined as inputs of an action
     */
    @Check
    def preventIlligalVariableAccess(Function function) {
        for (update : function.updates) {
            if (update.guard !== null) {
                val Set<String> inputs = newHashSet
                // Get all variables in a guard 
                var allVariables = update.guard.eAllContents.filter(ExpressionVariable).map[variable.name].toSet
                // get all the variables in input
                inputs.addAll(update.fnInp.map[it.ref.name])

                val missingInputs = allVariables.filter[e|!inputs.contains(e)]

                if (!missingInputs.empty) {
                    error(
                        "The following variables used in the guard are not defined in the input variables: " +
                            missingInputs.join(", "), update,
                        ProductPackage.Literals.UPDATE__GUARD
                    )
                }
            }
        }
    }

    /**
     * Variables occurring in the RHS of an update expression must have been defined as inputs of an action.
     * LHS variable is the same as that mentioned in immediately preceding "updates". 
     * Note that attributes of this variable may be referenced in the LHS expression (record field access)
     */
    @Check
    def void preventIlligalVariableAccess(Update update) {
        /* Variables occurring in the RHS of an update expression must have been defined as inputs of an action. */
        for (updateOutVar : update.updateOutputVar.reject[act === null]) {
            val inputs = update.fnInp.map[ref].toSet
            val outputs = updateOutVar.fnOut.map[ref].toSet
            updateOutVar.act.actions.forEach[preventIlligalVariableAccess(inputs, outputs)]
        }
    }

    private dispatch def void preventIlligalVariableAccess(AssignmentAction action, Set<Variable> inputs, Set<Variable> outputs) {
        if (!outputs.contains(action.assignment)) {
            error('''Variable '«action.assignment.name»' is not defined as an output''', action, ActionsPackage.Literals.ASSIGNMENT_ACTION__ASSIGNMENT)
        }
        action.exp?.preventIlligalVariableAccess(inputs, Direction::input)
        // As the variable is now assigned, we can also use it as input (imperative programming)
        inputs += action.assignment
    }

    private dispatch def void preventIlligalVariableAccess(RecordFieldAssignmentAction action, Set<Variable> inputs, Set<Variable> outputs) {
        action.fieldAccess?.preventIlligalVariableAccess(outputs, Direction::output)
        action.exp?.preventIlligalVariableAccess(inputs, Direction::input)
    }

    private dispatch def void preventIlligalVariableAccess(ForAction action, Set<Variable> inputs, Set<Variable> outputs) {
        action.exp?.preventIlligalVariableAccess(inputs, Direction::input)
        if (action.doList !== null) {
            val doInputs = new HashSet(inputs)
            doInputs += action.^var
            action.doList.actions.forEach[preventIlligalVariableAccess(doInputs, outputs)]
        }
    }

    private dispatch def void preventIlligalVariableAccess(IfAction action, Set<Variable> inputs, Set<Variable> outputs) {
        action.guard?.preventIlligalVariableAccess(inputs, Direction::input)
        if (action.thenList !== null) {
            action.thenList.actions.forEach[preventIlligalVariableAccess(inputs, outputs)]
        }
        if (action.thenList !== null) {
            action.thenList.actions.forEach[preventIlligalVariableAccess(inputs, outputs)]
        }
    }

    private enum Direction { input, output }

    private dispatch def void preventIlligalVariableAccess(ExpressionVariable exprVar, Set<Variable> variables, Direction direction) {
        if (!variables.contains(exprVar.variable)) {
            error('''Variable '«exprVar.variable.name»' is not defined as an «direction»''', exprVar, ExpressionPackage.Literals.EXPRESSION_VARIABLE__VARIABLE)
        }
    }

    private dispatch def void preventIlligalVariableAccess(Expression expr, Set<Variable> variables, Direction direction) {
        expr.eContents.filter(Expression).forEach[preventIlligalVariableAccess(variables, direction)]
    }
    
    /**
     * Name of global model should not have underscores */
     @Check 
     def checkBlockID(Block block){
         if(block.name.contains("_")){
             error("ID should not have underscores ", ProductPackage.Literals.BLOCK__NAME)
         }
     }

/* STRANGE BUG: Output Vars are Empty. Appears in Input Vars. 
 * Not appearing as problem during product generation!
 */
/*
 * @Check
 * public void checkInputOutputMapping(Product p) 
 * {
 *     var outVarMap = new HashMap<String,List<String>>();
 *     var inVarMap  = new HashMap<String,List<String>>();
 *     
 *     for(var b : p.getBlock()) {
 *         System.out.println(" + Parsing Block: " + b.getName());
 *         for(var ov : b.getOutvars()) {
 *             if(outVarMap.containsKey(b.getName())) {
 *                 outVarMap.get(b.getName()).add(ov.getName());
 *                 System.out.println("    Added Output: " + ov.getName());
 *             }
 *             else {
 *                 var lst = new ArrayList<String>();
 *                 lst.add(ov.getName());
 *                 outVarMap.put(b.getName(), lst);
 *                 System.out.println("    Added Output to Existing: " + ov.getName());
 *             }
 *         }
 *         for(var iv : b.getInvars()) {
 *             System.out.println(" - Parsing Block: " + b.getName());
 *             if(inVarMap.containsKey(b.getName())) {
 *                 inVarMap.get(b.getName()).add(iv.getName());
 *                 System.out.println("    Added Input: " + iv.getName());
 *             }
 *             else {
 *                 var lst = new ArrayList<String>();
 *                 lst.add(iv.getName());
 *                 inVarMap.put(b.getName(), lst);
 *                 System.out.println("    Added Input to Existing: " + iv.getName());
 *             }
 *         }
 *     }
 *     
 *     System.out.println(" Debug in Var: " + inVarMap);
 *     System.out.println(" Debug out Var: " + outVarMap);
 *     
 *     for(var t : p.getTopology()) {
 *         for(var f : t.getFlow()) {
 *             for(var conn : f.getVarConn()) {
 *                 var lkey = conn.getVarRefLHS().getBlockRef().getName();
 *                 var lvalue = conn.getVarRefLHS().getVarRef().getName();
 *                 var rkey = conn.getVarRefRHS().getBlockRef().getName();
 *                 var rvalue = conn.getVarRefRHS().getVarRef().getName();
 *                 inVarMap.get(lkey).remove(lvalue);
 *                 outVarMap.get(rkey).remove(rvalue);
 *             }
 *         }
 *     }
 *     
 *     System.out.println(" Debug in Var: " + inVarMap);
 *     System.out.println(" Debug out Var: " + outVarMap);
 *     
 *     // Check what is not mapped. 
 *     var txt = new String();
 *     var isUnMapped = false;
 *     
 *     for(var k : inVarMap.keySet()) {
 *         if(!inVarMap.get(k).isEmpty()) {
 *             isUnMapped = true;
 *             txt += "\n block: " + k + " has input: "+ inVarMap.get(k) + "with no source \n";
 *         }
 *     }
 *     
 *     for(var k : outVarMap.keySet()) {
 *         if(!outVarMap.get(k).isEmpty()) {
 *             isUnMapped = true;
 *             txt += "\n block: " + k + " has output: "+ outVarMap.get(k) + "with no target \n";
 *         }
 *     }
 *     
 *     if(isUnMapped) {
 *         error("Missing Input-Output Connections: \n" + txt, 
 *                 ProductPackage.Literals.PRODUCT__TOPOLOGY);
 *     }
 }*/
}
