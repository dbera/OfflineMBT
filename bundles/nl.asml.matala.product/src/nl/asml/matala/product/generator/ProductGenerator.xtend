/*
 * generated by Xtext 2.29.0
 */
package nl.asml.matala.product.generator

import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import nl.asml.matala.product.product.Block
import nl.asml.matala.product.product.Blocks
import nl.asml.matala.product.product.DataReferences
import nl.asml.matala.product.product.Function
import nl.asml.matala.product.product.Product
import nl.asml.matala.product.product.RefConstraint
import nl.asml.matala.product.product.Specification
import nl.asml.matala.product.product.Update
import nl.asml.matala.product.product.UpdateOutVar
import nl.asml.matala.product.product.VarRef
import nl.esi.comma.expressions.expression.Variable
import nl.esi.comma.types.generator.TypesZ3Generator
import nl.esi.comma.types.types.RecordField
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.SimpleTypeDecl
import nl.esi.comma.types.types.Type
import nl.esi.comma.types.types.TypeDecl
import nl.esi.comma.types.types.TypesModel
import nl.esi.comma.types.types.VectorTypeConstructor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import nl.esi.comma.actions.actions.ActionList
import nl.esi.comma.actions.actions.Action
import nl.esi.comma.actions.actions.AssignmentAction
import nl.esi.comma.expressions.generator.ExpressionsCommaGenerator
import nl.esi.comma.actions.actions.RecordFieldAssignmentAction
import org.eclipse.emf.ecore.EObject
import nl.esi.comma.expressions.expression.ExpressionRecordAccess
import nl.esi.comma.expressions.expression.ExpressionVariable
import nl.esi.comma.expressions.expression.ExpressionRecord
import nl.esi.comma.expressions.expression.Field
import nl.esi.comma.expressions.expression.ExpressionMapRW
import nl.esi.comma.expressions.expression.ExpressionEnumLiteral
import nl.esi.comma.expressions.expression.ExpressionConstantInt
import nl.esi.comma.expressions.expression.ExpressionConstantString
import nl.esi.comma.expressions.expression.ExpressionVector
import nl.esi.comma.expressions.expression.ExpressionConstantBool
import nl.esi.comma.expressions.expression.ExpressionConstantReal
import nl.esi.comma.expressions.expression.ExpressionAny
import nl.esi.comma.expressions.expression.ExpressionBulkData
import nl.esi.comma.expressions.expression.ExpressionFunctionCall
import nl.esi.comma.expressions.expression.ExpressionQuantifier
import nl.esi.comma.expressions.expression.ExpressionBracket
import nl.asml.matala.product.product.SymbConstraint
import nl.asml.matala.product.product.DataConstraints
import nl.asml.matala.product.product.ActionType
import nl.esi.comma.expressions.expression.ExpressionAnd
import nl.esi.comma.expressions.expression.ExpressionOr
import nl.esi.comma.expressions.expression.ExpressionEqual
import nl.esi.comma.expressions.expression.ExpressionNEqual
import nl.esi.comma.expressions.expression.ExpressionGeq
import nl.esi.comma.expressions.expression.ExpressionGreater
import nl.esi.comma.expressions.expression.ExpressionLeq
import nl.esi.comma.expressions.expression.ExpressionLess
import nl.esi.comma.expressions.expression.ExpressionAddition
import nl.esi.comma.expressions.expression.ExpressionSubtraction
import nl.esi.comma.expressions.expression.ExpressionMultiply
import nl.esi.comma.expressions.expression.ExpressionDivision
import nl.esi.comma.expressions.expression.ExpressionMaximum
import nl.esi.comma.expressions.expression.ExpressionMinimum
import nl.esi.comma.expressions.expression.ExpressionModulo
import nl.esi.comma.expressions.expression.ExpressionPower
import nl.esi.comma.expressions.expression.ExpressionUnary
import nl.esi.comma.expressions.expression.ExpressionNot
import nl.esi.comma.expressions.expression.ExpressionMinus
import nl.esi.comma.expressions.expression.ExpressionPlus

/**
 * Generates code from your *.ps model files on save.
 */
 
class ProductGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, 
		IFileSystemAccess2 fsa, IGeneratorContext context
	) {
		var prod = resource.allContents.head
		if(prod instanceof Product) {
			if (prod.specification !== null) {
				generatePetriNet(prod,resource,fsa)
			}
		}
	}
	
	def toTypes(String class_name, ArrayList<String> import_list, HashMap<String,String> var_decl_map) {
		'''
		class Types:
		    def __init__(self):
		        self.import_list = ["«FOR elm : import_list SEPARATOR ','»«elm»«ENDFOR»"]
		        self.var_decl_map = {«FOR k : var_decl_map.keySet SEPARATOR ','»"«k»" : "«var_decl_map.get(k)»"«ENDFOR»}
		'''
	}
	
	def generatePetriNet(Product prod, Resource resource, IFileSystemAccess2 fsa) 
	{	
		var dataGetterTxt = (new TypesGenerator).generatePythonGetters(prod,resource)
		var pnet = new PetriNet
		var methodTxt = ''''''		

		var inout_places = new ArrayList<String>
		var init_places = new ArrayList<String>
		
		var depth_limit = prod.specification.limit 
		
		var import_list = new ArrayList<String>
		var var_decl_map = new HashMap<String,String>
		
		/* Generate Z3 Data Types */
		for(imp : prod.imports) {
			// Assumption: At most one
			val typeResource = EcoreUtil2.getResource(resource, imp.importURI)
			var typeInst = typeResource.allContents.head
			if(typeInst instanceof TypesModel) {
				var txt = (new TypesZ3Generator).generateAllUserDefinedTypes(typeInst) 
				fsa.generateFile('CPNServer//' + prod.specification.name + '//Z3//' + prod.specification.name + '_z3types.py', txt)
			}
			import_list.add(imp.importURI)
		}

		/* ****** Z3 Type Generation ********** */
		
		
		for(b : prod.specification.blocks) {
			var Block block = null
			// if it works make it recursive
			if (b.block !== null) {
				block = b.block
			}
			if (b.refBlock !== null) {
				block = b.refBlock.system
			}
			// populate var and its type decl in map
			for(invar : block.invars) var_decl_map.put(block.name + "_" + invar.name, invar.type.type.name)
			for(ovar : block.outvars) var_decl_map.put(block.name + "_" + ovar.name, ovar.type.type.name)
			for(lvar : block.localvars) var_decl_map.put(block.name + "_" + lvar.name, lvar.type.type.name)
			
			// parse each block to derive places and transitions
			var tuple = populatePetriNet(pnet, block)
			pnet = tuple.key
			methodTxt += tuple.value		
		}
		
		fsa.generateFile('CPNServer//' + prod.specification.name + '//' + prod.specification.name + '_types.py', toTypes(prod.specification.name + "_types", import_list, var_decl_map))
		fsa.generateFile('CPNServer//' + prod.specification.name + '//plantuml//' + prod.specification.name + '_model.plantuml', pnet.toPlantUML(pnet, false))
		fsa.generateFile('CPNServer//' + prod.specification.name + '//plantuml//' + prod.specification.name + '_system.plantuml', pnet.toPlantUML(pnet, true))
		
		pnet.display
		
		if(true)
		{
			var listOfEnvBlocks = new ArrayList<String>
			for(b : prod.specification.envBlock) listOfEnvBlocks.add(b.name)
			
			var listOfAssertTransitions = new ArrayList<String>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
						    if(u.actionType.equals(ActionType.COMPOSE) || u.actionType.equals(ActionType.RUN)) {
						        listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
						    }
							// 30.01.2025 commented out
							/*for(fi : u.fnInp) {
								if(fi.dataConstraints !== null) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
							}*/
							//for(ovar : u.updateOutputVar) {
							    // if(ovar.assert) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
								// 30.01.2025 commented out and replaced with line above. 
								/*for(fo : ovar.fnOut) {
									if(fo.dataConstraints !== null) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
								}*/
							//}
						}
					}
				}
			}
			// transition names -> list of output variables that were suppressed
			var mapOfSuppressTransitionVars = new HashMap<String,List<String>>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
							for(ovar : u.updateOutputVar) {
								if(ovar.suppress) {
									// ADDED 08.11.2024 DB. Record out variables that were suppressed for a transition
									// Is transition name present?
									if(mapOfSuppressTransitionVars.containsKey(block.name+"_" + f.name + "_" + u.name)) {
										for(elm : ovar.fnOut) {
											// 08.11.2024 Assumption is that produces output does not have multiple vars (|ovar.fnOut| = 1)
											mapOfSuppressTransitionVars.get(block.name+"_" + f.name + "_" + u.name).add(elm.ref.name)
										}
									} else {
										for(elm : ovar.fnOut) {
											// 08.11.2024 Assumption is that produces output does not have multiple vars (|ovar.fnOut| = 1)
											var strList = new ArrayList<String>() 
											strList.add(elm.ref.name)
											mapOfSuppressTransitionVars.put(block.name+"_" + f.name + "_" + u.name, strList)
										}
									}
									// listOfSuppressTransitions.add(block.name+"_" + f.name + "_" + u.name)
								}
							}
						}
					}
				}
			}
			
			var name = prod.specification.name
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '.py', pnet.toSnakes(name, name, listOfEnvBlocks, listOfAssertTransitions, mapOfSuppressTransitionVars, inout_places, init_places, depth_limit))
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + 'server.py', (new FlaskSimulationGenerator).generateServer(name))
			fsa.generateFile('CPNserver.py', (new FlaskSimulationGenerator).generateCPNServer)
			fsa.generateFile('CPNclient.py', (new FlaskSimulationGenerator).generateCPNClient(prod.specification.name))
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + 'client.py', (new FlaskSimulationGenerator).generateClient)
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '_Simulation.py', pnet.toSnakesSimulation)
			
            // generate utils for HTTP server
            fsa.generateFile('CPNServer//' + prod.specification.name + '//' + '__init__.py', 
                (new FlaskSimulationGenerator).generateInitForCPNSpecPkg(prod)
            )
            
            fsa.generateFile('CPNServer//' + '__init__.py', 
                (new FlaskSimulationGenerator).generateInitForCPNServerSpecPkg(prod)
            )
			
			var data_container_class = 
			'''
			import copy
			import json
			
			
			class Data:
				
				@staticmethod
				def int_keys(ordered_pairs):
					result = {}
					for key, value in ordered_pairs:
						try:
							key = int(key)
						except ValueError:
							pass
						result[key] = value
					return result
				
				«dataGetterTxt»
				«methodTxt»
			'''
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '_data.py', data_container_class)
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '_TestSCN.py', generateTestSCNTxt(prod.specification.name + "_types", prod, resource.URI.lastSegment))
			
			// execute python code
			// val relativeFile = fsa.getURI(prod.name + '.py')
			// var path = ResourcesPlugin.workspace.root.getFile(new Path(relativeFile.toPlatformString(true))).rawLocation.toOSString
			// System.out.println("Path-to-generated-python-file: " +  path)
			// var p = Runtime.getRuntime().exec("python " + path);
		}
	}
	
	def Pair<PetriNet,String> populatePetriNet(PetriNet pnet, Block block) {
		var methodTxt = ''''''		
		var map_output_input = new HashMap<String, List<String>>
		// populate list of places
		/* 23.01.24 */
		for(invar : block.invars) {
			// System.out.println(" Debug: " + invar.name)
			// pnet.places.add(new Place(block.name, block.name+"_"+invar.name, PType.IN, invar.type.type))
			pnet.places.add(new Place(block.name, invar.name, PType.IN, invar.type.type))
		}
		// since we will use the map_output_input to map directly to an input place while creating outgoing arcs
		/* 23.01.24 */ // uncommented
		for(outvar : block.outvars) {
			pnet.places.add(new Place(block.name, outvar.name, PType.OUT, outvar.type.type))
		}
		/* 23.01.24 */
		for(localvar : block.localvars) {
			// pnet.places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			// pnet.internal_places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			pnet.places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			pnet.internal_places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			// TODO add as class members in python class of this block
		}
		
		//val (String) => String func = [s|block.name+"_"+s]
		val (String) => String func = [s|s]
					
		for(act : block.initActions) {
			System.out.println(" Init-Action LHS: " + SnakesHelper.action(act, func, "").split("=",2).get(0))
			System.out.println(" Init-Action RHS: " + SnakesHelper.action(act, func, "").split("=",2).get(1))
			
			pnet.add_to_init_place_expression_map(
				SnakesHelper.action(act, func,"").split("=",2).get(0), 
				SnakesHelper.action(act, func,"").split("=",2).get(1)
			)
		}
		
		// populate transitions
		for(f : block.functions) {
			System.out.println(" Function-name: " + f.name)
			for(update : f.updates) 
			{
				System.out.println("  > case: " + update.name)
				var tname = f.name + "_" + update.name + "@" + update.stepType + "@" + update.actionType + "@"
				var tr = new Transition(block.name, block.name+"_"+tname)
				pnet.transitions.add(tr)
				var input_var_list = new HashMap<String,TypeDecl> // ArrayList<String>
				for(v : update.fnInp) 
				{
					// place is already added before
					System.out.println("	> in-var-name: " + block.name + "_"+ v.ref.name)
					//if(v.opt) inout_places.add(block.name+"_"+v.ref.name)
					//if(v.init) init_places.add(block.name+"_"+v.ref.name)
					
					/* commenting out the use of opt and init places: 17.02.2024 */
					/* if(v.opt) inout_places.add(v.ref.name)
					if(v.init) init_places.add(v.ref.name) */
					
					/* 23.01.24 */
					//input_var_list.put(block.name+"_"+v.ref.name, v.ref.type.type)
					input_var_list.put(v.ref.name, v.ref.type.type)
					pnet.add_input_arc(tr.name, v.ref.name)
					/* 23.01.24 */
					// pnet.add_expression(tr.name, block.name + "_" + v.ref.name, 
					//						"Variable('v_" + block.name+"_" + v.ref.name + "')", PType.IN)
					pnet.add_expression(tr.name, v.ref.name, 
											"Variable('v_" + v.ref.name + "')", PType.IN, getConstraintTxt(v))
				}
				if(update.guard!==null) {
					val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
					System.out.println("	> guard: " + SnakesHelper.expression(update.guard, fn))
					pnet.add_guard_expression(tr.name, "Expression('" + SnakesHelper.expression(update.guard, fn) + "')")	
				}
				if(update.updateOutputVar!==null) 
				{
					var isActionsPresent = false
					for(outvar : update.updateOutputVar) 
					{
						/*var decTxt = 
						'''
							«FOR v : outvar.hiddenVars»
								«v.name» = «SnakesHelper.defaultValue(v.type.type)»
							«ENDFOR»
						'''*/
						var actTxt = ''''''
						
						isActionsPresent = false
						if(outvar.act !== null) 
						{
							isActionsPresent = true // flag true: actions are present!
							for(a : outvar.act.actions) 
							{ 
								System.out.println("	> act: " + SnakesHelper.action(a, func,""))
								actTxt +=
								'''
								    «SnakesHelper.action(a, func, "")»
								'''
							}
						}
						for(v : outvar.fnOut) 
						{
							// logic for parsing output variables to Petri net places, arcs and their expressions
							var place = new String
							if(isActionsPresent)
								place = parseOutVariablesWithActions(block, map_output_input, 
										v, tr, pnet, f.name+"_"+update.name, input_var_list)
							else
								place = parseOutputVariables(block, map_output_input, v, tr, pnet)
							
							if(outvar.assert) pnet.add_to_map_transition_assertions(tr.name, place)
							
							var methodDef = 
							'''
								@staticmethod
								def execute_«f.name»_«update.name»_«place»(«FOR elm : input_var_list.keySet SEPARATOR ','»«elm»«ENDFOR»):
									«actTxt»
									«IF v.ref.type.type instanceof RecordTypeDecl»
										return json.dumps(«v.ref.name»)
									«ELSE»
										return «v.ref.name»
									«ENDIF»
							'''
							if(!actTxt.isEmpty) methodTxt += methodDef.trim + "\n\n"
						}
					}
				}
			}
		}
		return new Pair(pnet, methodTxt)
	}
	
	
	def getConstraintTxt(VarRef v) {
		var constraints = new ArrayList<Constraint>
		if(v.dataConstraints !== null) {
			for(c : v.dataConstraints.constr) {
				// val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
				val (String) => String fn = [s|s]
				// constraints.add(new Constraint(c.name, SnakesHelper.expression(c.symbExpr, fn)))
				
				// constraints to comma expression. 27.08.2024
				// Check if boolean expression or assignment action
//				constraints.add(new Constraint(c.name, (new ExpressionsCommaGenerator()).exprToComMASyntax(c.symbExpr).toString()))
				constraints.add(new Constraint(printConstraint(c as SymbConstraint), ""))
			}
		}
		if(v.dataReferences !== null) {
			for(c : v.dataReferences.constr) {
				val (String) => String fn = [s|s]
				for(a : c.act.actions)
//					constraints.add(new Constraint(c.name, SnakesHelper.commaAction(a, fn, "")))
					constraints.add(new Constraint(printConstraint(c as RefConstraint), ""))
			}
		}
		return constraints
	}
	
	dispatch def String printConstraint(SymbConstraint sref) {
        return printConstraint(sref.eContainer as DataConstraints) + "." + sref.name
    }	
	dispatch def String printConstraint(RefConstraint ref) {
		return printConstraint(ref.eContainer as DataReferences) + "." + ref.name
	}
	
	dispatch def String printConstraint(DataConstraints ref) {
        return printConstraint(ref.eContainer as VarRef)
    }
    
	dispatch def String printConstraint(DataReferences ref) {
		return printConstraint(ref.eContainer as VarRef)
	}
	
	dispatch def String printConstraint(VarRef ref) {
		return printConstraint(ref.eContainer as UpdateOutVar)
	}
	
	dispatch def String printConstraint(UpdateOutVar ref) {
		return printConstraint(ref.eContainer as Update)
	}
	
	dispatch def String printConstraint(Update ref) {
		return printConstraint(ref.eContainer as Function) + "." + ref.name
	}
	
	dispatch def String printConstraint(Function ref) {
		return printConstraint(ref.eContainer as Block) + "." + ref.name
	}
	
	dispatch def String printConstraint(Variable ref) {
		return printConstraint(ref.eContainer as Block) + "." + ref.name
	}
	
	dispatch def String printConstraint(Block ref) {
		return printConstraint(ref.eContainer as Blocks) + "." + ref.name
	}
	
	dispatch def String printConstraint(Blocks ref) {
		return printConstraint(ref.eContainer as Specification)
	}
	
	dispatch def String printConstraint(Specification ref) {
		return ref.name
	}

	
	def generateTestSCNTxt(String name, Product prod, String pSpecFile) {
		return
		'''
		import json
		import os
		
		# from .«prod.specification.name».«name» import Types
		
		
		class Tests:
		    list_of_test_scn = []
		
		    def __init__(self):
		        self.list_of_test_scn = []
		
		    def toJSON(self):
		        return json.dumps(self, default=lambda o: o.__dict__,
		                          sort_keys=True, indent=4)
		
		
		class TestSCN:
		    step_list = []
		    step_dependencies = []
		    map_transition_assert = {}
		    constraint_dict = {}
		
		    def __init__(self, _mapTrAssert, _constraint_dict):
		        self.step_list = []
		        self.step_dependencies = []
		        self.map_transition_assert = _mapTrAssert
		        self.constraint_dict = _constraint_dict
		
		    def generate_viz(self, idx, output_dir):
		        txt = "@startuml\n"
		        if len(self.step_list) > 0:
		            # txt += "[*] --> %s : x\n" % self.step_list[0].step_name
		            for first, second in zip(self.step_list, self.step_list[1:]):
		                txt += "%s --> %s : follows\n" % (first.step_name.replace("@","_"), second.step_name.replace("@","_"))
		        if len(self.step_dependencies):
		            for elm in self.step_dependencies:
		                txt += "%s ..> %s : uses\n" % (elm.step_name.replace("@","_"), elm.depends_on.replace("@","_"))
		                txt += "note on link\n"
		                txt += "%s" % elm.payload
		                txt += "\nend note\n"
		        txt += "@enduml"
		
		        fname = output_dir / f"scenario{str(idx)}.plantuml"
		        os.makedirs(os.path.dirname(fname), exist_ok=True)
		        with open(fname, 'w') as f:
		            f.write(txt)
		
		    def recurseJson(self, items, prefix):
		        txt = ""
		        try:
		            for jk in items.keys():
		                txt += self.recurseJson(items[jk], f"{prefix}.{jk}")
		        except:
		            match items:
		                case str():
		                    if ":" in items and not "()" in items:
		                        items = items.replace(":", "::")
		                    elif "True" in items:
		                        items = "true"
		                    elif "False" in items:
		                        items = "false"
		                    else:
		                        items = f"\"{items}\""
		                case int():
		                    items = items
		                case list():
		                    items = self.updateDict[prefix].strip()
		                case _:
		                    raise TypeError('Unsupported type')
		            txt += f"    {prefix} := {items}\n"
		        return txt
		
		    «printLists(prod)»
		
		    def printData(self, idata):
		        txt = ""
		        for k, v in idata.items():
		            txt += "%s : {\n" % k
		            j = json.loads(v)
		            for jk in j.keys():
		                txt += self.recurseJson(j[jk], "%s.%s" % (k,jk))
		            txt += "}\n"
		        return txt
				
		    def generateTSpec(self, idx, output_dir):
		        txt = ""
		        txt += "import \"«pSpecFile»\"\n\n"
		        «usageList(prod)»
		        txt += "abstract-test-definition\n\n"
		        txt += "Test-Scenario: S%s\n" % idx
		        for step in self.step_list:
		            if not step.is_assert:
		                name = step.step_name
		                idata = step.input_data
		                odata = step.output_data
		                parts = name.split("@")
		                new_name = parts[0] + parts[3]
		                if "RUN" in parts[2]:
		                    type_name = ""
		                    if not "null" in parts[1]:
		                        type_name = " step-type: \"%s\"" % parts[1] 
		                    txt += "run-step-name: %s%s\n" % (new_name, type_name)
		                else:
		                    txt += "compose-step-name: %s\n" % new_name
		                for elm in self.step_dependencies:
		                    if elm.step_name == name:
		                        parts = elm.depends_on.split("@")
		                        new_name = parts[0] + parts[3]
		                        txt += "consumes-from-step: %s { " % new_name
		                        txt += elm.var_ref
		                        txt += " }\n"
		                txt += "input-binding:\n"
		                txt += self.printData(idata)
		                for k, v in idata.items():
		                    if name.rsplit("_",1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_",1)[0]]:
		                            if constr.var_ref == k and constr.dir == "IN":
		                                txt += "output-assertion: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s\n" % entry.name
		                txt += "output-data:\n"
		                txt += self.printData(odata)
		                # if step.is_suppress:
		                # txt += "suppress\n"
		                for k, v in odata.items():
		                    if name.rsplit("_",1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_",1)[0]]:
		                            if constr.var_ref == k and constr.dir == "OUT":
		                                txt += "data-references: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s\n" % entry.name
		            else:
		                name = step.step_name
		                idata = step.input_data
		                odata = step.output_data
		                # txt += name
		                # txt += "input-binding:\n"
		                for k, v in idata.items():
		                    # txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_", 1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_", 1)[0]]:
		                            if constr.var_ref == k and constr.dir == "IN":
		                                txt += "\noutput-assertion: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : \"%s\"\n" % (entry.name, entry.constr.replace('"','\\"'))
		                for k, v in odata.items():
		                    # txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_", 1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_", 1)[0]]:
		                            if constr.var_ref == k and constr.dir == "OUT":
		                                txt += "\ndata-references: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : \"%s\"\n" % (entry.name, entry.constr.replace('"','\\"'))
		                txt += "\n"
		        txt += '\ngenerate-file "./vfab2_scenario/"\n\n'
		        fname = output_dir / f"_scenario{str(idx)}.tspec"
		        print(str(fname))
		        os.makedirs(os.path.dirname(fname), exist_ok=True)
		        with open(fname, 'w') as f:
		            f.write(txt)
		
		    def compute_dependencies(self):
		        for step in self.step_list:
		            idx = self.step_list.index(step)
		            preced = [item for i, item in enumerate(self.step_list) if idx < i < len(self.step_list)]
		            for elm in preced:
		                # print(" SRC-STEP: %s" % step.step_name)
		                # print(" DST-STEP: %s" % elm.step_name)
		                step_dep = step.compare(elm,self.map_transition_assert)
		                if step_dep:
		                    self.step_dependencies.append(step_dep)
		        # for elm in self.step_dependencies:
		        #    print("%s" % elm.step_name)
		        #    print("%s" % elm.depends_on)
		        #    print("%s" % elm.payload)
		
		
		class Step:
		    step_name = ""
		    input_data = {}
		    output_data = {}
		    is_assert = False
		    # mapOfSuppressTransitionVars = {}
		
		    def __init__(self, _is_assert):
		        self.step_name = ""
		        self.input_data = {}
		        self.output_data = {}
		        self.is_assert = _is_assert
		        # self.mapOfSuppressTransitionVars = mapOfSuppressTransitionVars
		
		    def compare(self, _step, mapTrAssert):
		        for ipdata in self.output_data:
		            for opdata in _step.input_data:
		                if self.step_name.rsplit('_', 1)[0] in mapTrAssert:
		                    if ipdata == opdata and ipdata in mapTrAssert[self.step_name.rsplit('_', 1)[0]]:
		                        # print("     Step %s depends on Step %s" % (_step.step_name, self.step_name))
		                        # print("     Matched %s - %s" % (ipdata,opdata))
		                        if _step.input_data[opdata] == self.output_data[ipdata]:
		                            # print("     Payload Matched!")
		                            step_dep = StepDependency()
		                            step_dep.step_name = _step.step_name
		                            step_dep.depends_on = self.step_name
		                            step_dep.var_ref = ipdata
		                            step_dep.payload = _step.input_data[opdata]
		                            return step_dep
		                        # else:
		                        # print("     Payload Not Matched!")
		                        # print(_step.input_data[opdata])
		                        # print(self.output_data[ipdata])
		                        # print("\n")
		        return None
		
		
		class StepDependency:
		    step_name = ""
		    depends_on = ""
		    var_ref = ""
		    payload = ""
		
		    def __init__(self):
		        self.step_name = ""
		        self.depends_on = ""
		        self.payload = ""
		
		
		class Constraint:
		    var_ref = ""
		    dir = ""
		    centry = []
		
		    def __init__(self, v, d, ce):
		        self.var_ref = v
		        self.dir = d
		        self.centry = ce
		
		
		class CEntry:
		    name = ""
		    constr = ""
		
		    def __init__(self, n, c):
		        self.name = n
		        self.constr = c
		

		'''
	}
	
	def generateVarListTxt(Map<String,TypeDecl> input_var_map) {
		return '''(«FOR elm : input_var_map.keySet SEPARATOR ','»«generateVarTxt(input_var_map,elm)»«ENDFOR»)'''
	}
	
	def generateVarTxt(Map<String,TypeDecl> input_var_map, String elm) {
		
		var txt = ''''''
		
		if(input_var_map.get(elm) instanceof RecordTypeDecl)
			txt += '''json.loads(v_«elm», object_pairs_hook=Data().int_keys)'''
		else 
			txt += '''v_«elm»'''
		
		return txt
	}

	def dispatch ArrayList<String> findVariableAssignments(RecordFieldAssignmentAction act) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionVariable v) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionConstantBool b) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionConstantInt i) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionConstantReal r) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionConstantString s) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionVector v) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionEnumLiteral e) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionAny e) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionBulkData b) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionFunctionCall b) {
		return new ArrayList<String>()
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionQuantifier q) {
		return new ArrayList<String>()
	}

    def dispatch ArrayList<String> findVariableAssignments(ExpressionAnd q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionOr q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionEqual q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionNEqual q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionGeq q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionGreater q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionLeq q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionLess q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionAddition q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionSubtraction b) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionMultiply b) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionDivision b) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionMaximum b) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionMinimum b) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionModulo b) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionPower q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionUnary q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionNot q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionMinus q) {
        return new ArrayList<String>()
    }

    def dispatch ArrayList<String> findVariableAssignments(ExpressionPlus q) {
        return new ArrayList<String>()
    }

	def dispatch ArrayList<String> findVariableAssignments(AssignmentAction act) {
		return findVariableAssignments(act.exp)
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionMapRW m) {
		return findVariableAssignments(m.key)
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionRecordAccess r) {
		return findVariableAssignments(r.record)
	}

	def dispatch ArrayList<String> findVariableAssignments(ExpressionRecord exp) {
		var list = new ArrayList<String>()
		for (f : exp.fields) {
			var fqname = getFQName(f)
			list += "updateDict[\"" + fqname + "\"] = \"\"\"" + (new ExpressionGenerator).exprToComMASyntax(f.exp) + " \"\"\"\n"
			list += findVariableAssignments(f.exp)
		}
		return list
	}

	def dispatch String getFQName(Field f) {
		return getFQName(f.eContainer) + "." + f.recordField.name
	}

	def dispatch String getFQName(ExpressionRecord e) {
		return getFQName(e.eContainer)
	}

	def dispatch String getFQName(AssignmentAction e) {
		return e.assignment.name
	}	

	def printLists(Product prod) {
		var list = new ArrayList<String>()
		list += "updateDict = {}\n"
		for (updateOutVar :  prod.eAllContents.filter(UpdateOutVar).toIterable) {
			if (updateOutVar.act !== null) { // Null Pointer BugFix - DB 05.02.2025
    			for (act : updateOutVar.act.actions) {
    				list += findVariableAssignments(act)
    			}
			}
		}
		return list.join("")
	}

	def usageList(Product prod) {
		var varSet = getUniqueVariables(prod)
		var usings = ""
		for (v : varSet) {
			var blockName = (v.eContainer as Block).name
			usings += "txt += \"using " + prod.specification.name + "." + blockName + "." + v.name + "\\n\"\n"
		}
		return usings
	}

	def getUniqueVariables(Product prod) {
		var Set<Variable> varSet = new HashSet<Variable>()
		var Set<Variable> varSetUniqueNames = new HashSet<Variable>()
		for (b : prod.eAllContents.filter(Block).toIterable) {
			varSet.addAll(b.invars)
			varSet.addAll(b.outvars)
			varSet.addAll(b.localvars)
		}
		for (v : varSet) {
			var notInUniqueSet = true
			for (u : varSetUniqueNames) {
				if (v.name.compareToIgnoreCase(u.name) == 0) {
					notInUniqueSet = false
				}				
			}
			if (notInUniqueSet) {
				varSetUniqueNames.add(v)
			}
		}
		return varSetUniqueNames
	}

	def Map<String,String> recurseTypes(Type typ) {
		var constructors = newLinkedHashMap() 
		var typ2 = typ.type
		if (typ instanceof VectorTypeConstructor) {
			if (!typ2.name.equalsIgnoreCase("string")) {
				if (typ.eContainer instanceof RecordField) {
					var field = (typ.eContainer as RecordField).name
					var key = typ2.name
					constructors.put(key, field)
				}
			}
		}
		if (typ2 instanceof RecordTypeDecl) {
			for (f : (typ2 as RecordTypeDecl).fields) {
				constructors.putAll(recurseTypes(f.type))
			}
		}
		return constructors
	}

	def parseOutVariablesWithActions(Block block, HashMap<String, List<String>> map_output_input, 
									VarRef v, Transition tr, PetriNet pnet, String executeFnName, 
									Map<String,TypeDecl> input_var_list) 
	{
		System.out.println("	> out-var-name: " + block.name+"_"+v.ref.name)
		var vtype = v.ref.type.type.name
		var place = new String
		
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name))  /* 23.01.24 */ 
		{
			var outp = map_output_input.get(block.name+"_"+v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				place = p

				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, "Value(" + SnakesHelper.defaultValue(v.ref.type.type) + ")", PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", PType.OUT, getConstraintTxt(v))	
			}
		} 
		else 
		{ 
			/* 23.01.24 */
			// pnet.add_output_arc(tr.name, block.name+"_"+v.ref.name)
			pnet.add_output_arc(tr.name, v.ref.name)
			place = v.ref.name
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, "Expression('" + SnakesHelper.defaultValue(v.ref.type.type) + "')", PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", PType.OUT, getConstraintTxt(v))
		}
		
		return place
	}
	
	def parseOutputVariables(Block block, HashMap<String, List<String>> map_output_input, 
							VarRef v, Transition tr, PetriNet pnet) 
	{
		// find mapping to input place in map_output_input
		System.out.println("	> out-var-name: " + v.ref.name)
		// System.out.println("> MAP: " + map_output_input)
		var vtype = v.ref.type.type.name
		var place = new String
		// Note assumption is that all output variable mapped to input var by user
		// TODO implement validation checker!
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name)) /* 23.01.24 */
		{
			var outp = map_output_input.get(v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				//pnet.add_expression(tr.name, p, "Expression('1')", PType.OUT)
				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, "Value(" + SnakesHelper.defaultValue(v.ref.type.type) + ")", PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, "Expression('Data().get_" + vtype + "()')", PType.OUT, getConstraintTxt(v))
				
				place = p
			}
		} else 
		{ 
			// can reach here if output is not mapped and then this is a dangling arc
			/* 23.01.24 */
			pnet.add_output_arc(tr.name, v.ref.name)
			
			//pnet.add_expression(tr.name, block.name+"_"+v.ref.name, "Expression('1')", PType.OUT)
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, "Expression('" + SnakesHelper.defaultValue(v.ref.type.type) + "')", PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, "Expression('Data().get_" + vtype + "()')", PType.OUT, getConstraintTxt(v))
			
			/* Commented DB 06.02.2025 */
			// None of the other places have block name in prefix. 
			// Causes issues in assert transition list and linking of steps
			// TODO How to deal with data name collisions in BPMN model
			/* place = block.name+"_"+v.ref.name */
			place = v.ref.name
		}
		
		return place
	}
	
	def generateOnlineMBTController(Product envModel, Product sutModel, 
		IFileSystemAccess2 fsa, IGeneratorContext context
	) {
		var txt =
		'''
		import asyncio
		import random
		
		from «envModel.specification.name» import «envModel.specification.name»Model
		from «sutModel.specification.name» import «sutModel.specification.name»Model
		
		
		class OnlineMBTController:
		
		    async def execute(self, pnMod, is_client):
		        dead_marking = False
		        while True:
		            if is_client and dead_marking:
		                # item = await self.ni_queue.get()
		                try:
		                    item = await asyncio.wait_for(self.ni_queue.get(), timeout=1)
		                    print(f' [Test Client] Received Message: {item}')
		                    self.cpn.n.place(item[0]).add(item[1])
		                    self.ni_queue.task_done()
		                except asyncio.TimeoutError:
		                    print(' [INFO] Time-out')
		            elif not is_client and dead_marking:
		                # item = await self.rq_queue.get()
		                try:
		                    item = await asyncio.wait_for(self.rq_queue.get(), timeout=1)
		                    print(f' [SUT] Received Message: {item}')
		                    self.spn.n.place(item[0]).add(item[1])
		                    self.rq_queue.task_done()
		                except asyncio.TimeoutError:
		                    print(' [INFO] Time-out')
		            else:
		                if is_client:
		                    print(' [Test Client] Going to Fire a Transition!')
		                else:
		                    print(' [SUT] Going to Fire a Transition!')
		            dead_marking = False
		            enabled_transition_modes = {}
		            for t in pnMod.n.transition():
		                tmodes = t.modes()
		                for mode in tmodes:
		                    enabled_transition_modes[t] = tmodes
		            if not enabled_transition_modes:
		                dead_marking = True
		                if is_client:
		                    print(' [Test Client] Deadlock Marking Detected! Waiting for Message.. ')
		                else:
		                    print(' [SUT] Deadlock Marking Detected! Waiting for Message.. ')
		            choices = {}
		            idx = 0
		            for key, value in enabled_transition_modes.items():
		                for elm in value:
		                    choices[idx] = key, elm
		                    idx = idx + 1
		            if not dead_marking:
		                value = random.randint(0, idx - 1)
		                if is_client:
		                    print(' [Test Client] Selected Transition: ', choices.get(int(value)))
		                else:
		                    print(' [SUT] Selected Transition: ', choices.get(int(value)))
		                t, m = choices.get(int(value))
		                t.fire(m)
		                if is_client:
		                    print(' [Test Client] Transition Fired! ')
		                else:
		                    print(' [SUT] Transition Fired! ')
		                if is_client:
		                    for ch in self.ClientToSUTchannels:
		                        if not pnMod.n.place(ch).is_empty():
		                            m = pnMod.n.get_marking()
		                            pnMod.n.place(ch).remove(m.get(ch))
		                            print(' [Test Client] Sent Request')
		                            await self.rq_queue.put((ch, m.get(ch)))
		                else:
		                    for ch in self.SUTToClientchannels:
		                        if not pnMod.n.place(ch).is_empty():
		                            m = pnMod.n.get_marking()
		                            pnMod.n.place(ch).remove(m.get(ch))
		                            print(' [SUT] Sent Notification')
		                            await self.ni_queue.put((ch, m.get(ch)))
		
		    def __init__(self):
		        self.rq_queue = asyncio.Queue(maxsize=2)  # single input queue
		        self.ni_queue = asyncio.Queue(maxsize=2)  # single output queue
		        self.cpn = «envModel.specification.name»Model()  # for each client component
		        self.spn = «sutModel.specification.name»Model()  # for each SUT
		        print(" [INFO] Loaded CPN models and Initialized Queues.")
		        cIntfP = self.cpn.determineInterfacePlaces()  # create set, by iterating over each client component
		        sIntfP = self.spn.determineInterfacePlaces()  # create set, by iterating over each SUT component
		        # From the point of view of SUT
		        self.SUTToClientchannels = [x for x in cIntfP.input if
		                                    x in sIntfP.output]  # find common places between client and SUT
		        self.ClientToSUTchannels = [x for x in cIntfP.output if
		                                    x in sIntfP.input]  # find common places between client and SUT
		
		    async def run(self):
		        await asyncio.gather(self.execute(self.spn, False),
		                             self.execute(self.cpn, True))
		
		
		if __name__ == '__main__':
		    asyncio.run(OnlineMBTController().run())
		'''
		fsa.generateFile('OnlineMBT_Controller.py', txt)
	}
}
