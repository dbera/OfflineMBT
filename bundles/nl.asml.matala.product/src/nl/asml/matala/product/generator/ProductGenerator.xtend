/*
 * generated by Xtext 2.29.0
 */
package nl.asml.matala.product.generator

import java.util.ArrayList
import java.util.HashMap
import java.util.List
import nl.asml.matala.product.product.Product
import nl.esi.comma.types.types.SimpleTypeDecl
import nl.esi.comma.types.types.TypeDecl
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import nl.asml.matala.product.product.VarRef
import nl.asml.matala.product.product.Block
import java.util.Map
import nl.esi.comma.types.types.RecordTypeDecl
//import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import java.util.HashSet

/**
 * Generates code from your *.ps model files on save.
 */
 
class ProductGenerator extends AbstractGenerator {
	
	var connections = new ArrayList<MapBlockPort>
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var prod = resource.allContents.head
		if(prod instanceof Product) {
			generatePetriNet(prod,resource,fsa)
		}
	}
	
	def generatePetriNet(Product prod, Resource resource, IFileSystemAccess2 fsa) 
	{	
		var dataGetterTxt = (new TypesGenerator).generatePythonGetters(prod,resource)
		var methodTxt = ''''''
		
		var pnet = new PetriNet
		var inout_places = new ArrayList<String>
		var init_places = new ArrayList<String>
		var map_output_input = new HashMap<String, List<String>>
		var init_place_expression_map = new HashMap<String, List<String>>
		
		var depth_limit = prod.limit 

		/*for(t : prod.topology) {
			for(f : t.flow) {
				for(conn : f.varConn) {
					var src = conn.varRefLHS.blockRef.name + "_" + conn.varRefLHS.varRef.name
					var dst = conn.varRefRHS.blockRef.name + "_" + conn.varRefRHS.varRef.name
					if(map_output_input.keySet.contains(dst)) {
						map_output_input.get(dst).add(src)
					} else {
						var lst = new ArrayList
						lst.add(src)
						map_output_input.put(dst,lst)
					}
				}	
			}	
		}*/
		
		// parse each block to derive places and transitions
		for(block : prod.block) {
			// populate list of places
			/* 23.01.24 */
			for(invar : block.invars) {
				// System.out.println(" Debug: " + invar.name)
				// pnet.places.add(new Place(block.name, block.name+"_"+invar.name, PType.IN, invar.type.type))
				pnet.places.add(new Place(block.name, invar.name, PType.IN, invar.type.type))
			}
			// since we will use the map_output_input to map directly to an input place while creating outgoing arcs
			/* 23.01.24 */ // uncommented
			for(outvar : block.outvars) {
				pnet.places.add(new Place(block.name, outvar.name, PType.OUT, outvar.type.type))
			}
			/* 23.01.24 */
			for(localvar : block.localvars) {
				// pnet.places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
				// pnet.internal_places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
				pnet.places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
				pnet.internal_places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
				// TODO add as class members in python class of this block
			}
			
			//val (String) => String func = [s|block.name+"_"+s]
			val (String) => String func = [s|s]
						
			for(act : block.initActions) {
				System.out.println(" Init-Action LHS: " + SnakesHelper.action(act, func, "").split("=",2).get(0))
				System.out.println(" Init-Action RHS: " + SnakesHelper.action(act, func, "").split("=",2).get(1))
				
				pnet.add_to_init_place_expression_map(
					SnakesHelper.action(act, func,"").split("=",2).get(0), 
					SnakesHelper.action(act, func,"").split("=",2).get(1)
				)
			}
			
			// populate transitions
			for(f : block.functions) {
				System.out.println(" Function-name: " + f.name)
				for(update : f.updates) 
				{
					System.out.println("  > case: " + update.name)
					var tname = f.name + "_" + update.name
					var tr = new Transition(block.name, block.name+"_"+tname)
					pnet.transitions.add(tr)
					var input_var_list = new HashMap<String,TypeDecl> // ArrayList<String>
					for(v : update.fnInp) 
					{
						// place is already added before
						System.out.println("	> in-var-name: " + block.name + "_"+ v.ref.name)
						//if(v.opt) inout_places.add(block.name+"_"+v.ref.name)
						//if(v.init) init_places.add(block.name+"_"+v.ref.name)
						
						/* commenting out the use of opt and init places: 17.02.2024 */
						/* if(v.opt) inout_places.add(v.ref.name)
						if(v.init) init_places.add(v.ref.name) */
						
						/* 23.01.24 */
						//input_var_list.put(block.name+"_"+v.ref.name, v.ref.type.type)
						input_var_list.put(v.ref.name, v.ref.type.type)
						pnet.add_input_arc(tr.name, v.ref.name)
						/* 23.01.24 */
						// pnet.add_expression(tr.name, block.name + "_" + v.ref.name, 
						//						"Variable('v_" + block.name+"_" + v.ref.name + "')", PType.IN)
						pnet.add_expression(tr.name, v.ref.name, 
												"Variable('v_" + v.ref.name + "')", PType.IN, getConstraintTxt(v))
					}
					if(update.guard!==null) {
						val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
						System.out.println("	> guard: " + SnakesHelper.expression(update.guard, fn))
						pnet.add_guard_expression(tr.name, "Expression('" + SnakesHelper.expression(update.guard, fn) + "')")	
					}
					if(update.updateOutputVar!==null) 
					{
						var isActionsPresent = false
						for(outvar : update.updateOutputVar) 
						{
							/*var decTxt = 
							'''
								«FOR v : outvar.hiddenVars»
									«v.name» = «SnakesHelper.defaultValue(v.type.type)»
								«ENDFOR»
							'''*/
							var actTxt = ''''''
							
							isActionsPresent = false
							if(outvar.act !== null) 
							{
								isActionsPresent = true // flag true: actions are present!
								for(a : outvar.act.actions) 
								{ 
									System.out.println("	> act: " + SnakesHelper.action(a, func,""))
									actTxt +=
									'''
									    «SnakesHelper.action(a, func, "")»
									'''
								}
							}
							for(v : outvar.fnOut) 
							{
								// logic for parsing output variables to Petri net places, arcs and their expressions
								var place = new String
								if(isActionsPresent)
									place = parseOutVariablesWithActions(block, map_output_input, 
											v, tr, pnet, f.name+"_"+update.name, input_var_list)
								else
									place = parseOutputVariables(block, map_output_input, v, tr, pnet)
								
								if(outvar.assert) pnet.add_to_map_transition_assertions(tr.name, place)
								
								var methodDef = 
								'''
									@staticmethod
									def execute_«f.name»_«update.name»_«place»(«FOR elm : input_var_list.keySet SEPARATOR ''','''»«elm»«ENDFOR»):
										«actTxt»
										«IF v.ref.type.type instanceof RecordTypeDecl»
											return json.dumps(«v.ref.name»)
										«ELSE»
											return «v.ref.name»
										«ENDIF»
								'''
								if(!actTxt.isEmpty) methodTxt += methodDef.trim + "\n\n"
							}
						}
					}
				}
			}
		}
		
		fsa.generateFile(prod.name + '_model.plantuml', pnet.toPlantUML(pnet, false))
		fsa.generateFile(prod.name + '_system.plantuml', pnet.toPlantUML(pnet, true))
		
		// identify inout places and make all arcs to and from it, bi-directional
		/* commenting out the use of opt and init places: 17.02.2024 */
		/*for(place : inout_places) {
			for(t : pnet.input_arcs.keySet) {
				for(p : pnet.input_arcs.get(t)) {
					if(place.equals(p)) {
						pnet.add_output_arc(t,p)
						//pnet.add_expression(t, p, "Expression('1')", PType.OUT)
						pnet.add_expression(t, p, "Expression(\""+ "v_" + p +"\")", PType.OUT)
					}	
				}
			}
			for(t : pnet.output_arcs.keySet) {
				for(p : pnet.output_arcs.get(t)) {
					if(place.equals(p)) {
						pnet.add_input_arc(t,p)
						pnet.add_expression(t, p, "Variable('v_" + p + "')", PType.IN)
					}	
				}
			}
		}*/
		
		pnet.display
		
		// if(!prod.topology.isEmpty)
		if(true)
		{
			var listOfEnvBlocks = new ArrayList<String>
			for(b : prod.envBlock) listOfEnvBlocks.add(b.name)
			
			var listOfAssertTransitions = new ArrayList<String>
			for(b : prod.block) {
				for(f : b.functions) {
					for(u : f.updates) {
						for(fi : u.fnInp) {
							if(fi.dataConstraints !== null) listOfAssertTransitions.add(b.name+"_" + f.name + "_" + u.name)
						}
						for(ovar : u.updateOutputVar) {
							for(fo : ovar.fnOut) {
								if(fo.dataConstraints !== null) listOfAssertTransitions.add(b.name+"_" + f.name + "_" + u.name)
							}
						}
					}
				}
			}
			
			fsa.generateFile(prod.name + '.py', pnet.toSnakes(prod.name, prod.name, listOfEnvBlocks, listOfAssertTransitions, inout_places, init_places, depth_limit))
			
			fsa.generateFile(prod.name + '_Simulation.py', pnet.toSnakesSimulation)
				
			var data_container_class = 
			'''
			import copy
			import json
			
			
			class Data:
				
				@staticmethod
				def int_keys(ordered_pairs):
					result = {}
					for key, value in ordered_pairs:
						try:
							key = int(key)
						except ValueError:
							pass
						result[key] = value
					return result
				
				«dataGetterTxt»
				«methodTxt»
			'''
			fsa.generateFile(prod.name + '_data.py', data_container_class)
			
			fsa.generateFile(prod.name + '_TestSCN.py', generateTestSCNTxt)
			
			// execute python code
			// val relativeFile = fsa.getURI(prod.name + '.py')
			// var path = ResourcesPlugin.workspace.root.getFile(new Path(relativeFile.toPlatformString(true))).rawLocation.toOSString
			// System.out.println("Path-to-generated-python-file: " +  path)
			// var p = Runtime.getRuntime().exec("python " + path);
		}
	}
	
	
	def getConstraintTxt(VarRef v) {
		var constraints = new ArrayList<Constraint>
		if(v.dataConstraints !== null) {
			for(c : v.dataConstraints.constr) {
				// val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
				val (String) => String fn = [s|s]
				constraints.add(new Constraint(c.name, SnakesHelper.expression(c.symbExpr, fn)))
			}
		}
		return constraints
	}
	
	def generateTestSCNTxt() {
		return
		'''
		import json
		import os
		
		
		class Tests:
		    list_of_test_scn = []
		
		    def __init__(self):
		        self.list_of_test_scn = []
		
		    def toJSON(self):
		        return json.dumps(self, default=lambda o: o.__dict__,
		                          sort_keys=True, indent=4)
		
		
		class TestSCN:
		    step_list = []
		    step_dependencies = []
		    map_transition_assert = {}
		    constraint_dict = {}
		
		    def __init__(self, _mapTrAssert, _constraint_dict):
		        self.step_list = []
		        self.step_dependencies = []
		        self.map_transition_assert = _mapTrAssert
		        self.constraint_dict = _constraint_dict
		
		    def generate_viz(self, idx):
		        txt = "@startuml\n"
		        if len(self.step_list) > 0:
		            # txt += "[*] --> %s : x\n" % self.step_list[0].step_name
		            for first, second in zip(self.step_list, self.step_list[1:]):
		                txt += "%s --> %s : follows\n" % (first.step_name, second.step_name)
		        if len(self.step_dependencies):
		            for elm in self.step_dependencies:
		                txt += "%s ..> %s : uses\n" % (elm.step_name, elm.depends_on)
		                txt += "note on link\n"
		                txt += "%s" % elm.payload
		                txt += "\nend note\n"
		        txt += "@enduml"
		
		        fname = "./generated_scenarios/scenario" + str(idx) + ".plantuml"
		        os.makedirs(os.path.dirname(fname), exist_ok=True)
		        with open(fname, 'w') as f:
		            f.write(txt)
		
		    def generateTSpec(self, idx):
		        txt = "abstract-test-definition\n\n"
		        txt += "Test-Scenario: S%s\n" % idx
		        for step in self.step_list:
		            if not step.is_assert:
		                name = step.step_name
		                idata = step.input_data
		                odata = step.output_data
		                txt += "step-name: %s\n" % name
		                for elm in self.step_dependencies:
		                    if elm.step_name == name:
		                        txt += "consumes-from-step: %s { " % elm.depends_on
		                        txt += elm.var_ref
		                        txt += " }\n"
		                txt += "input-binding:\n"
		                for k, v in idata.items():
		                    txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_",1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_",1)[0]]:
		                            if constr.var_ref == k and constr.dir == "IN":
		                                txt += "symbolic-input-constraint: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : %s\n" % (entry.name,entry.constr)
		                txt += "output-data:\n"
		                for k, v in odata.items():
		                    txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_",1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_",1)[0]]:
		                            if constr.var_ref == k and constr.dir == "OUT":
		                                txt += "symbolic-output-constraint: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : %s\n" % (entry.name,entry.constr)
		            else:
		                name = step.step_name
		                idata = step.input_data
		                odata = step.output_data
		                # txt += name
		                # txt += "input-binding:\n"
		                for k, v in idata.items():
		                    # txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_", 1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_", 1)[0]]:
		                            if constr.var_ref == k and constr.dir == "IN":
		                                txt += "\noutput-assertion: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : \"%s\"\n" % (entry.name, entry.constr.replace('"','\\"'))
		                for k, v in odata.items():
		                    # txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_", 1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_", 1)[0]]:
		                            if constr.var_ref == k and constr.dir == "OUT":
		                                txt += "\nsymbolic-constraint: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : \"%s\"\n" % (entry.name, entry.constr.replace('"','\\"'))
		                txt += "\n"
		        txt += '\ngenerate-file "./vfab2_scenario/"\n\n'
		        fname = "./generated_scenarios/_scenario" + str(idx) + ".tspec"
		        os.makedirs(os.path.dirname(fname), exist_ok=True)
		        with open(fname, 'w') as f:
		            f.write(txt)
		
		    def compute_dependencies(self):
		        for step in self.step_list:
		            idx = self.step_list.index(step)
		            preced = [item for i, item in enumerate(self.step_list) if idx < i < len(self.step_list)]
		            for elm in preced:
		                # print(" SRC-STEP: %s" % step.step_name)
		                # print(" DST-STEP: %s" % elm.step_name)
		                step_dep = step.compare(elm,self.map_transition_assert)
		                if step_dep:
		                    self.step_dependencies.append(step_dep)
		        # for elm in self.step_dependencies:
		        #    print("%s" % elm.step_name)
		        #    print("%s" % elm.depends_on)
		        #    print("%s" % elm.payload)
		
		
		class Step:
		    step_name = ""
		    input_data = {}
		    output_data = {}
		    is_assert = False
		
		    def __init__(self, _is_assert):
		        self.step_name = ""
		        self.input_data = {}
		        self.output_data = {}
		        self.is_assert = _is_assert
		
		    def compare(self, _step, mapTrAssert):
		        for ipdata in self.output_data:
		            for opdata in _step.input_data:
		                if self.step_name.rsplit('_', 1)[0] in mapTrAssert:
		                    if ipdata == opdata and ipdata in mapTrAssert[self.step_name.rsplit('_', 1)[0]]:
		                        # print("     Step %s depends on Step %s" % (_step.step_name, self.step_name))
		                        # print("     Matched %s - %s" % (ipdata,opdata))
		                        if _step.input_data[opdata] == self.output_data[ipdata]:
		                            # print("     Payload Matched!")
		                            step_dep = StepDependency()
		                            step_dep.step_name = _step.step_name
		                            step_dep.depends_on = self.step_name
		                            step_dep.var_ref = ipdata
		                            step_dep.payload = _step.input_data[opdata]
		                            return step_dep
		                        # else:
		                        # print("     Payload Not Matched!")
		                        # print(_step.input_data[opdata])
		                        # print(self.output_data[ipdata])
		                        # print("\n")
		        return None
		
		
		class StepDependency:
		    step_name = ""
		    depends_on = ""
		    var_ref = ""
		    payload = ""
		
		    def __init__(self):
		        self.step_name = ""
		        self.depends_on = ""
		        self.payload = ""
		
		
		class Constraint:
		    var_ref = ""
		    dir = ""
		    centry = []
		
		    def __init__(self, v, d, ce):
		        self.var_ref = v
		        self.dir = d
		        self.centry = ce
		
		
		class CEntry:
		    name = ""
		    constr = ""
		
		    def __init__(self, n, c):
		        self.name = n
		        self.constr = c
		

		'''
	}
	
	def generateVarListTxt(Map<String,TypeDecl> input_var_map) {
		return '''(«FOR elm : input_var_map.keySet SEPARATOR ''','''»«generateVarTxt(input_var_map,elm)»«ENDFOR»)'''
	}
	
	def generateVarTxt(Map<String,TypeDecl> input_var_map, String elm) {
		
		var txt = ''''''
		
		if(input_var_map.get(elm) instanceof RecordTypeDecl)
			txt += '''json.loads(v_«elm», object_pairs_hook=Data().int_keys)'''
		else 
			txt += '''v_«elm»'''
		
		return txt
	}
	
	def parseOutVariablesWithActions(Block block, HashMap<String, List<String>> map_output_input, 
									VarRef v, Transition tr, PetriNet pnet, String executeFnName, 
									Map<String,TypeDecl> input_var_list) 
	{
		System.out.println("	> out-var-name: " + block.name+"_"+v.ref.name)
		var vtype = v.ref.type.type.name
		var place = new String
		
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name))  /* 23.01.24 */ 
		{
			var outp = map_output_input.get(block.name+"_"+v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				place = p

				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, "Value(" + SnakesHelper.defaultValue(v.ref.type.type) + ")", PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", PType.OUT, getConstraintTxt(v))	
			}
		} 
		else 
		{ 
			/* 23.01.24 */
			// pnet.add_output_arc(tr.name, block.name+"_"+v.ref.name)
			pnet.add_output_arc(tr.name, v.ref.name)
			place = v.ref.name
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, "Expression('" + SnakesHelper.defaultValue(v.ref.type.type) + "')", PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", PType.OUT, getConstraintTxt(v))
		}
		
		return place
	}
	
	def parseOutputVariables(Block block, HashMap<String, List<String>> map_output_input, 
							VarRef v, Transition tr, PetriNet pnet) 
	{
		// find mapping to input place in map_output_input
		System.out.println("	> out-var-name: " + v.ref.name)
		// System.out.println("> MAP: " + map_output_input)
		var vtype = v.ref.type.type.name
		var place = new String
		// Note assumption is that all output variable mapped to input var by user
		// TODO implement validation checker!
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name)) /* 23.01.24 */
		{
			var outp = map_output_input.get(v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				//pnet.add_expression(tr.name, p, "Expression('1')", PType.OUT)
				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, "Value(" + SnakesHelper.defaultValue(v.ref.type.type) + ")", PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, "Expression('Data().get_" + vtype + "()')", PType.OUT, getConstraintTxt(v))
				
				place = p
			}
		} else 
		{ 
			// can reach here if output is not mapped and then this is a dangling arc
			/* 23.01.24 */
			pnet.add_output_arc(tr.name, v.ref.name)
			
			//pnet.add_expression(tr.name, block.name+"_"+v.ref.name, "Expression('1')", PType.OUT)
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, "Expression('" + SnakesHelper.defaultValue(v.ref.type.type) + "')", PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, "Expression('Data().get_" + vtype + "()')", PType.OUT, getConstraintTxt(v))
			
			place = block.name+"_"+v.ref.name
		}
		
		return place
	}
}
	

class Constraint {
	public var name = new String
	public var txt = new String
	
	new(String _name, String _txt) {
		name = _name
		txt = _txt
	}
}

class ArcExpression {
	public var type = PType.IN
	public var t = new String
	public var p = new String
	public var expTxt = new String
	public var constraints = new ArrayList<Constraint>
	
	new(String _t, String _p, String _expTxt, PType _type, ArrayList<Constraint> _constraints) {
		t = _t
		p = _p
		expTxt = _expTxt
		type = _type
		constraints = _constraints
	}
	
	def areEqual(String _t, String _p, PType _type) {
		if(t.equals(_t) && p.equals(_p) && type.equals(_type)) return true
		else return false
	}
}

class PetriNet {
	public var places = new ArrayList<Place>
	public var transitions = new ArrayList<Transition>
	public var input_arcs = new HashMap<String,List<String>>  // transition -> list of places
	public var output_arcs = new HashMap<String,List<String>> // transition -> list of places
	public var map_transition_assertions = new HashMap<String,List<String>> // transition -> list of places to assert on
	public var arc_expressions = new ArrayList<ArcExpression>
	public var guard_expressions = new HashMap<String,String> // transition -> expression
	public var internal_places = new ArrayList<Place>
	public var init_place_expression_map = new HashMap<String, List<String>>
	
	
	def add_to_map_transition_assertions(String tname, String assertion_place) {
		if(map_transition_assertions.keySet.contains(tname)) {
			if(!map_transition_assertions.get(tname).contains(assertion_place)) {
				map_transition_assertions.get(tname).add(assertion_place)
			}
		}
		else {
			map_transition_assertions.put(tname, new ArrayList<String>)
			map_transition_assertions.get(tname).add(assertion_place)
		}
	}
	
	def generatePlaceInitializationText() {
		return 
		'''
		«FOR k : init_place_expression_map.keySet»
			self.n.place('«k.trim»').empty()
			«FOR elm : init_place_expression_map.get(k)»
				self.n.place('«k.trim»').add(json.dumps(«elm.trim»))
			«ENDFOR»
		«ENDFOR»
		'''
	}
	
	def add_to_init_place_expression_map(String p, String e) {
		if(init_place_expression_map.keySet.contains(p)) 
			init_place_expression_map.get(p).add(e)
		else{
			var lst = new ArrayList<String>
			lst.add(e)
			init_place_expression_map.put(p,lst)
		}
	}
		
	def is_internal_place(String p) {
		for(ip : internal_places) {
			if(ip.name.equals(p)) return true
		}
		return false
	}
	
	// TODO validate all entry in input and output arcs 
	// have corresponding expression in arc_expressions. Risk of null pointer!
	def get_expression(String t, String p, PType type) {
		for(ae : arc_expressions) {
			if(ae.areEqual(t,p,type)) return ae
		}
		return null
	}
	
	def add_expression(String t, String p, String expTxt, PType type, ArrayList<Constraint> constraints) {
		arc_expressions.add(new ArcExpression(t,p,expTxt,type, constraints))
	}
	
	def add_guard_expression(String t, String txt) {
		guard_expressions.put(t,txt)
	}
	
	def display() {
		System.out.println("********* Petri Net ***************")
		System.out.println(" > Places ")
		for(p : places){
			System.out.println("	> name: " + p.name + " block-name: " + p.bname + " type: " + p.type.toString)
		}
		System.out.println("	> Transition ")
		for(t : transitions){
			if(guard_expressions.containsKey(t.name))
				System.out.println("	> name: " + t.name + " block-name: " + t.bname + " guard: " + guard_expressions.get(t))
			else System.out.println("	> name: " + t.name + " block-name: " + t.bname)
		}
		System.out.println("	> Input Arcs ")
		for(k : input_arcs.keySet) {
			System.out.println("	> places: " + input_arcs.get(k) + "  transition: " + k)
		}
		System.out.println("	> Output Arcs ")
		for(k : output_arcs.keySet) {
			System.out.println("	> transition: " + k + "  places: " + output_arcs.get(k))
		}
		System.out.println("	> Transition Output Assertions ")
		for(k : map_transition_assertions.keySet) {
			System.out.println("	> transition: " + k + "  assert-places: " + map_transition_assertions.get(k))
		}
		System.out.println("	> Constraints ")
		for(e : arc_expressions) {
			for(c : e.constraints) {
				System.out.println("	> transition: " + e.t + "  place: " + e.p + "  direction: " + e.type)
				System.out.println("	> name: " + c.name + "  constraint: " + c.txt)
			}
		}
		System.out.println("***********************************")
	}
	
	def add_input_arc(String t, String p) {
		if(input_arcs.keySet.contains(t)) { 
			if(!input_arcs.get(t).contains(p)) {
				input_arcs.get(t).add(p)
			}
		}
		else { 
			input_arcs.put(t, new ArrayList<String>) 
			input_arcs.get(t).add(p)
		}
	}
	
	def add_output_arc(String t, String p) {
		if(output_arcs.keySet.contains(t)) { 
			if(!output_arcs.get(t).contains(p)) {
				output_arcs.get(t).add(p)
			}
		}
		else { 
			output_arcs.put(t, new ArrayList<String>) 
			output_arcs.get(t).add(p)
		}
	}
	
	def getPlace(String bname, String name) { 
		for(pl : places)
			if(pl.name.equals(name) && pl.bname.equals(bname))
				return pl
		throw new RuntimeException
	}
	
	def getTransition(String bname, String name) { 
		for(tr : transitions)
			if(tr.name.equals(name) && tr.bname.equals(bname))
				return tr
		throw new RuntimeException
	}
	
	def generateSnakesPlace(Place p, List<String> inout_places, List<String> init_places) 
	{
		if(inout_places.contains(p.name) || init_places.contains(p.name)) {
			if(p.custom_type instanceof SimpleTypeDecl) 
				return '''self.n.add_place(Place('«p.name»', «SnakesHelper.defaultValue(p.custom_type)»))'''
			else return '''self.n.add_place(Place('«p.name»', Data().get_«p.custom_type.name»()))'''
		} else {
			return '''self.n.add_place(Place('«p.name»'))'''
		}
	}
	
	def isPresent(Place p, List<Place> lp) {
		for(elm : lp) { if(elm.name.equals(p.name)) return true }
		return false
	}
	
	def getPlacesTxt(List<String> inout_places, List<String> init_places) 
	{
		var lp = new ArrayList<Place>
		for(p : places) { if(!isPresent(p,lp)) lp.add(p) }
		return
		'''
		«FOR p : lp»
		    «generateSnakesPlace(p, inout_places, init_places)»
		«ENDFOR»
		'''
	}
	
	def getTransitionsTxt() {
		return
		'''
		«FOR t : transitions»
		    self.n.add_transition(Transition('«t.name»'«IF guard_expressions.containsKey(t.name)», «guard_expressions.get(t.name)»«ENDIF»))
		«ENDFOR»
		'''
	}
	
	def getInputArcsTxt() {
		return
		'''
		«FOR t : input_arcs.keySet»
		    «FOR p : input_arcs.get(t)»
		        self.n.add_input('«p»','«t»',«get_expression(t,p,PType.IN).expTxt»)
		    «ENDFOR»
		«ENDFOR»
		'''
	}
	
	def getOutputArcsTxt() {
		return
		'''
		«FOR t : output_arcs.keySet»
		    «FOR p : output_arcs.get(t)»
		        self.n.add_output('«p»','«t»', «get_expression(t,p,PType.OUT).expTxt»)
		    «ENDFOR»
		«ENDFOR»
		'''
	}
	
	def toSnakesSimulation() {
		'''
		def simulate(n):
		    stop = False
		    while not stop:
		        dead_marking = False
		        enabled_transition_modes = {}
		        # print("Current State")
		        # print("{\n\t" +
		        #      "\n\t".join("{!r}: {!r},".format(k, v) for k, v in n.get_marking().items()) +
		        #      "\n}")
		        for t in n.transition():
		            tmodes = t.modes()
		            # print(tmodes)
		            enabled_transition_modes[t] = tmodes
		            for mode in tmodes:
		                print('\n')
		                print(' Enabled-transition-name: ', t)
		                print('    # with-input-modes: ')
		                for key, value in mode.dict().items():
		                    print('      - var: ', key, '  ->  value:', value)
		                # print('     > with mode: ', mode.dict())
		
		        # print(enabled_transition_modes)
		
		        if not enabled_transition_modes:
		            dead_marking = True
		
		        choices = {}
		        idx = 0
		        for key, value in enabled_transition_modes.items():
		            for elm in value:
		                choices[idx] = key, elm
		                idx = idx + 1
		
		        for k, v in choices.items():
		            print('\n')
		            print('Possible-choices: ')
		            print('    + choice: ', k, ' with-mode: ', v)
		
		        if not dead_marking:
		            print('\n')
		            value = input(" Enter Choice: ")
		            print('\n')
		            print(' - Selected transition: ', choices.get(int(value)))
		            t, m = choices.get(int(value))
		            t.fire(m)
		            print('\n')
		            print(' [ Transition Fired! ]')
		            print('\n')
		            print(' Resulting Marking: ')
		            for k in n.get_marking():
		                print('    + Place: ', k, ' has Token: ', n.get_marking()[k])
		            print('****************************************************************')
		            # self.generatePlantUML(n, True)
		        else:
		            print('No Enabled Transitions!!')
		            stop = True
		
		
		def getTransitionName(t, isDetailed):
		    if isDetailed:
		        return t.name
		    else:
		        return t.name.split('_')[0]
		
		
		class Simulation:
		    def __init__(self):
		        self.dictTrMode = None
		        self.dictTrName = None
		
		    def getEnabledTransitionList(self, n):
		        trList = []
		        self.dictTrName = {}
		        self.dictTrMode = {}
		        for t in n.transition():
		            tmodes = t.modes()
		            idx = 0
		            for mode in tmodes:
		                # for key,value in mode.dict().items():
		                # kv = ': {0}  -> {1}'.format(key,value)
		                trList.append(t.name + str(idx))
		                self.dictTrName.update({t.name + str(idx): t.name})
		                self.dictTrMode.update({t.name + str(idx): mode})
		                idx = idx + 1
		        return trList
		'''
	}
	
	def toSnakes(String prod_name, 
				 String topology_name, 
				 List<String> listOfEnvBlocks,
				 ArrayList<String> listOfAssertTransitions, 
				 List<String> inout_places, 
				 List<String> init_places, 
				 int depth_limit
	) {
		'''
		import datetime
		import json
		import pprint
		
		from snakes.nets import *

		from «prod_name»_TestSCN import TestSCN, Step, Tests, Constraint, CEntry
		from «prod_name»_data import Data
		from «prod_name»_Simulation import Simulation, simulate
		import subprocess
		import copy
		import os
		
		snakes.plugins.load('gv', 'snakes.nets', 'nets')
		from nets import *
		
		
		class PetriNetModel:
		    visitedList = set()
		    visitedTList = [[]]
		    visitedTProdList = [[]]
		    rg_txt = ""
		
		    def __init__(self):
		        self.rg_txt = '@startuml\n'
		        self.rg_txt += '[*] --> 0\n'
		        self.n = PetriNet('«topology_name»')
		        self.n.globals["Data"] = Data
		        self.n.globals.declare("import json")
		        «getPlacesTxt(inout_places, init_places)»
		        «generatePlaceInitializationText»
		        «transitionsTxt»
		        «inputArcsTxt»
		        «outputArcsTxt»
		    
		    «print_SCNGen»
		    
		    def chunkstring(self, string, length):
		        return (string[0+i:length+i] for i in range(0, len(string), length))
		        
		
		if __name__ == '__main__':
		    a = datetime.datetime.now()
		    pn = PetriNetModel()
		    print("[INFO] Loaded CPN model.")
		    # pn.n.draw('net-gv-graph.png')
		    s = StateGraph(pn.n)
		    # s.build()
		    # s.draw('test-gv-graph.png')
		    # print(" Finished Generation, writing to file.. ")
		    print("[INFO] Starting Reachability Graph Generation")
		    pn.generateScenarios(s,0,[],[],[],0,«depth_limit»)
		    print("[INFO] Finished.")
		    b = datetime.datetime.now()
		
		    s.goto(0)
		    # rg_txt = '@startuml\n'
		    # rg_txt += '[*] --> 0\n'
		    # for state in s:
		        # for succ in s.successors():
		            # rg_txt += '%s --> %s : %s\n' % (state,succ[0],succ[1])
		    pn.rg_txt += "@enduml\n"
		    fname = "rg.plantuml"
		    with open(fname, 'w') as f:
		        f.write(pn.rg_txt)
		    print("[INFO] Created rg.platuml")
		    
		    # server = PlantUML(url='http://www.plantuml.com/plantuml/img/', basic_auth={}, form_auth={}, http_opts={}, request_opts={})
		    # subprocess.call(['java -DPLANTUML_LIMIT_SIZE=122192', '-jar', 'plantuml-1.2023.8.jar', 'rg.plantuml'])
		    subprocess.Popen('java -DPLANTUML_LIMIT_SIZE=122192 -jar ./lib/plantuml-1.2023.11.jar rg.plantuml',
		                     stdout=subprocess.PIPE,
		                     stderr=subprocess.STDOUT)
		    #if os.path.exists(fname):
		    #    server.processes_file(abspath(fname))
		    # for entry in pn.visitedTList:
		    #    print('SCN: ', entry)
		    c = datetime.datetime.now()
		    
		    listOfEnvBlocks = [«FOR elm : listOfEnvBlocks SEPARATOR ''','''»"«elm»"«ENDFOR»]
		    listOfAssertTransitions = [«FOR elm : listOfAssertTransitions SEPARATOR ''','''»"«elm»"«ENDFOR»]
		    print("[INFO] Starting Test Generation.")
		    
		    map_of_transition_modes = {}
		    for entry in pn.visitedTList:
		        if entry:
		            for step in entry:
		                if step[1].name in map_of_transition_modes:
		                    map_of_transition_modes.get(step[1].name).append(step[2])
		                else:
		                    map_of_transition_modes[step[1].name] = [step[2]]
		    
		    map_transition_modes_to_name = {}
		    cnt = 0
		    for k,v in map_of_transition_modes.items():
		        # print(k)
		        cnt = 0
		        modes = set(v)
		        for elm in modes:
		            # print(elm)
		            map_transition_modes_to_name[k + "_" +elm.__repr__()] = k + "_" + str(cnt)
		            # map_transition_modes_to_name[k + "_" + pprint.pformat(elm.items(), width=60, compact=True,depth=5)] = k + "_" + str(cnt)
		            cnt = cnt + 1
		    
		    txt = '\n// import "<insert valid step specification file>"\n\ncontext-map\n\n'
		    for k,v in map_transition_modes_to_name.items():
		        # print(k)
		        # print(v)
		        step_txt = v
		        if step_txt.split("_")[0] in listOfEnvBlocks:
		            txt += 'abstract-step %s\n' %(v)
		            txt += '    with /* %s */\n' %(k)
		            txt += '    // -> <refer to a step sequence>\n'
		    
		    fname = "./generated_scenarios/_cm.tspec"
		    os.makedirs(os.path.dirname(fname), exist_ok=True)
		    with open(fname, 'w') as f:
		        f.write(txt)
		    
		    print("[INFO] Created context mapper.")
		    
		    _txt = []
		    constraint_list = []
		    constraint_dict = {}
		    «FOR e : arc_expressions»
		    	«IF !e.constraints.empty»
		    	«FOR c : e.constraints»
		    		_txt.append(CEntry("«c.name»","«c.txt.replace("\"", "\\\"")»"))
		    	«ENDFOR»
		    	constraint_list.append(Constraint("«e.p»","«e.type»", _txt))
		    	_txt = []
		    	if "«e.t»" not in constraint_dict:
		    	    constraint_dict["«e.t»"] = constraint_list
		    	else:
		    	    constraint_dict["«e.t»"].extend(constraint_list)
		    	«ENDIF»
		    «ENDFOR»
		    
		    idx = 0
		    # txt = ''
		    map_transition_assert = {«FOR elm : map_transition_assertions.keySet SEPARATOR ''','''»'«elm»': [«FOR v : map_transition_assertions.get(elm) SEPARATOR ''','''»'«v»'«ENDFOR»]«ENDFOR»}
		    i = 0
		    j = 0
		    _tests = Tests()
		    for entry in pn.visitedTList:
		        # txt = ''
		        if entry:
		            _test_scn = TestSCN(map_transition_assert, constraint_dict)
		            idx = idx + 1
		            # txt += '\nimport "_cm.tspec"\n\nabstract-test-definition\n\nTest-Scenario : s%s \n' % (idx)
		            j = 0
		            for step in entry:
		                # txt += "    [%s] : [%s]\n" % (step[1], step[2])
		                stp = step[1].name + "_" + step[2].__repr__()
		                # stp = step[1].name + "_" + pprint.pformat(step[2].items(), width=60, compact=True, depth=5)
		                # step_txt = map_transition_modes_to_name[step[1].name + "_" + step[2].__repr__()]
		                step_txt = map_transition_modes_to_name[stp]
		                if step_txt.split("_")[0] in listOfEnvBlocks or step_txt.rsplit("_",1)[0] in listOfAssertTransitions:
		                    _step = Step(step_txt.rsplit("_",1)[0] in listOfAssertTransitions)
		                    # txt += "    %s\n" % (map_transition_modes_to_name[step[1].name + "_" + step[2].__repr__()])
		                    # txt += "step-name: %s\n" % (map_transition_modes_to_name[stp])
		                    _step.step_name = map_transition_modes_to_name[stp]
		                    # txt += "    input-binding: %s\n" % (step[2].__repr__())
		                    # txt += "input-binding:\n"
		                    for x,y in step[2].dict().items():
		                        # txt += "    /*\n"
		                        # txt += "%s: %s\n" % (x,json.dumps(json.loads(y), indent=4, sort_keys=True))
		                        _step.input_data[x.replace("v_", "", 1)] = json.dumps(json.loads(y), indent=4, sort_keys=True)
		                        # txt += "    \n\t*/\n"
		                    # txt += "    output-data: %s\n" % (pn.visitedTProdList[i][j])
		                    # txt += "output-data:\n"
		                    for x,y in pn.visitedTProdList[i][j].items():
		                        # txt += "%s:" % x
		                        for z in y.items():
		                            # txt += "%s\n" % (json.dumps(json.loads(z), indent=4, sort_keys=True))
		                            _step.output_data[x] = json.dumps(json.loads(z), indent=4, sort_keys=True)
		                    # txt += "\n"
		                    _test_scn.step_list.append(_step)
		                    # if map_transition_assert[map_transition_modes_to_name[stp].rsplit('_', 1)[0]]:
		                        # s.goto(step[0])
		                        # txt += "    result-marking\n"
		                        # txt += "\n/*\n"
		                        # for k, v in s.net.get_marking().items():
		                            # if k in map_transition_assert[map_transition_modes_to_name[stp].rsplit('_', 1)[0]]:
		                                # txt += "\t" + k
		                                # txt += ":"
		                                # txt += "\t" + pprint.pformat(v, width=60, indent=4, compact=True, depth=2)
		                                # txt += "\n"
		                        # txt += "\t*/\n"
		                j = j + 1
		            _test_scn.compute_dependencies()
		            _test_scn.generate_viz(i)
		            _test_scn.generateTSpec(i)
		            _tests.list_of_test_scn.append(_test_scn)
		            # txt += '\ngenerate-file "./vfab2_scenario/"\n\n'
		            # fname = "./generated_scenarios/scenario" + str(idx) +".tspec"
		            # os.makedirs(os.path.dirname(fname), exist_ok=True)
		            # with open(fname, 'w') as f:
		            #    f.write(txt)
		        i = i + 1
		    
		    fname = "./generated_scenarios/tcs" + ".json"
		    os.makedirs(os.path.dirname(fname), exist_ok=True)
		    with open(fname, 'w') as f:
		        f.write(_tests.toJSON())
		    
		    print('[INFO] Number-of-generated-scenario files: ',len(pn.visitedTList))
		    print("[INFO] Test Generation Finished.")
		    d = datetime.datetime.now()
		    
		    print("[INFO] Creating Structure and Behavior Views in PlantUML.")
		    map_block_uml_txt = {}
		    for t in pn.n.transition():
		        map_block_uml_txt[t.name.split('_')[0]] = '@startuml\n'
		        
		    for t in pn.n.transition():
		        gtxt = map_block_uml_txt.get(t.name.split('_')[0])
		        if 'json.loads' in t.guard._str:
		            # print(t.guard._str.replace('json.loads',''))
		            # print('\n'.join(list(pn.chunkstring(t.guard._str.replace('json.loads','').replace(', object_pairs_hook=Data().int_keys', ''),55))))
		            gtxt += 'component %s\n' % (t.name)
		            if len(list(pn.chunkstring(t.guard._str.replace('json.loads','').replace(', object_pairs_hook=Data().int_keys', ''),68))) <= 2:
		                gtxt += 'note left of [%s]\n %s\nendnote\n' % (t.name, '\n'.join(list(pn.chunkstring(t.guard._str.replace('json.loads','').replace(', object_pairs_hook=Data().int_keys', ''),55))))
		            else:
		                gtxt += 'note bottom of [%s]\n %s\nendnote\n' % (t.name, '\n'.join(list(pn.chunkstring(t.guard._str.replace('json.loads','').replace(', object_pairs_hook=Data().int_keys', ''),55))))
		        else:
		            gtxt += 'component %s\n' % (t.name)
		            gtxt += 'note right of [%s]\n %s\nendnote\n' % (t.name, t.guard)
		        map_block_uml_txt[t.name.split('_')[0]] = gtxt
		        
		    for t in pn.n.transition():
		        for inp in pn.n.pre(t.name):
		            txt = map_block_uml_txt.get(t.name.split('_')[0])
		            if 'local' in inp:
		                txt += '%s -[#lightgrey]-> [%s]\n' % (inp, t.name)
		            else:
		                txt += '%s --> [%s]\n' % (inp, t.name)
		            map_block_uml_txt[t.name.split('_')[0]] = txt
		        for out in pn.n.post(t.name):
		            txt = map_block_uml_txt.get(t.name.split('_')[0])
		            if 'local' in out:
		                txt += '[%s] -[#lightgrey]-> %s\n' % (t.name, out)
		            else:
		                txt += '[%s] --> %s\n' % (t.name, out)
		            map_block_uml_txt[t.name.split('_')[0]] = txt
		    
		    for key in map_block_uml_txt:
		        txt = map_block_uml_txt.get(key)
		        txt += '@enduml\n'
		        map_block_uml_txt[key] = txt
		        fname = key + ".plantuml"
		        with open(fname, 'w') as f:
		            f.write(txt)
		    
		    print("[INFO] View Generation Finished.")
		    e = datetime.datetime.now()
		    print("[INFO] Time Statistics")
		    print("[INFO]    * Reachability Computation: %s" % (b - a))
		    print("[INFO]    * Reachability PUML Creation: %s" % (c - b))
		    print("[INFO]    * Test Generation: %s" % (d - c))
		    print("[INFO]    * PlantUML View Generation: %s" % (e - d))
		    
		    print("[INFO] Starting Command-Line Simulation.")
		    # Simulation().simulateUI(pn.n)
		    
		    print('[SIM] Start Simulation? (Y/N) :')
		    value = input(" Enter Choice: ")
		    if value == "Y" or value == "y":
		        os.system('cls')
		        simulate(pn.n)
		    
		    print("[INFO] Exiting..")
		'''
	}
	
	def print_SCNGen() {
		return
		'''
	    def generateScenarios(self, state_space, currentVertex, visited, visitedT, visitedTP, depth, limit):
	        # print(currentVertex)
	        # print(self.visitedList)
	        # print(visitedT)
	        if depth > limit:
	            print('	[RG-INFO] depth limit is reached.')
	            self.visitedTList.append(list(visitedT))
	            self.visitedTProdList.append(list(visitedTP))
	        elif currentVertex in self.visitedList:
	            print('	[RG-INFO] current vertex is already visited.')
	            self.visitedTList.append(list(visitedT))
	            self.visitedTProdList.append(list(visitedTP))
	        else:
	            self.visitedList.add(currentVertex)
	            state_space.goto(currentVertex)
	            visited.append(currentVertex)
	            if len(list(state_space.successors())) == 0:
	                print('	[RG-INFO] deadlock detected.')
	                self.visitedTList.append(list(visitedT))
	                self.visitedTProdList.append(list(visitedTP))
	            else:
	                for elm in state_space.successors():
	                    state_space.goto(currentVertex)
	                    visitedT.append(elm)  # [1].name)
	                    visitedTP.append(elm[1].flow(elm[2])[1])
	                    self.rg_txt += '%s --> %s : %s\n' % (currentVertex, elm[0], elm[1])
	                    self.generateScenarios(state_space, elm[0], visited.copy(), visitedT.copy(), visitedTP.copy(), depth + 1, limit)
	                    # visitedT.remove(elm[1].name)
	                    del visitedT[-1]
	                    del visitedTP[-1]
		'''
	}
	
	def printSCNGen() {
		return
		'''
		def generateScenarios(self, state_space, currentVertex, visited, visitedT, depth, limit):
		    state_space.goto(currentVertex)
		    visited.append(currentVertex)
		    # print('state %s is %r with status %s' % (state_space.current(), state_space.net.get_marking(),
		    # state_space.completed()))
		    for elm in state_space.successors():
		        visitedT.append(elm[1].name)
		        # print('Next State: ', elm[0], ' with transition ', elm[1])
		        if elm[0] not in visited:
		            self.generateScenarios(state_space,elm[0],visited.copy(),visitedT.copy(), depth+1, limit)
		        else:
		            self.visitedTList.append(visitedT)
		        visitedT.remove(elm[1].name)
		    self.visitedList.append(visited)
		'''
	}	
	
	def getBlocks() {
		var block_set = new HashSet<String>
		for(t : transitions) {
			block_set.add(t.bname)
		}
		return block_set
	}
	
	def getTransitions(String block_name) {
		var transition_list = new ArrayList<String>
		for(t : transitions) {
			if(t.bname.equals(block_name))
				transition_list.add(t.name)
		}
		return transition_list
	}
	
	def getOutputs(String transition_name) {
		var output_list = new HashSet<String>
		for(t : output_arcs.keySet) {
			if(t.equals(transition_name)) {
				for(p : output_arcs.get(t)) {
					output_list.add(p)
				}
			}
		}
		return output_list
	}
	
	def getIntputs(String transition_name) {
		var input_list = new HashSet<String>
		for(t : input_arcs.keySet) {
			if(t.equals(transition_name)) {
				for(p : input_arcs.get(t)) {
					input_list.add(p)
				}
			}
		}
		return input_list
	}
	
	def getInputArcsOfBlock(String block_name) {
		var arcList = new HashSet<String>
		for(b: getBlocks) {
			for(t : getTransitions(b)) {
				for(ip : getIntputs(t)) {
					arcList.add(ip)
				}		
			}
		}
		return arcList
	}
	
	def getOutputArcsOfBlock(String block_name) {
		var arcList = new HashSet<String>
		for(b: getBlocks) {
			for(t : getTransitions(b)) {
				for(ip : getOutputs(t)) {
					arcList.add(ip)
				}		
			}
		}
		return arcList
	}
	
	def toPlantUML(PetriNet pn, boolean printBlocks) {
		return 
		'''
		@startuml
		«IF printBlocks»
			«FOR b: getBlocks»
				node "«b»" {
					«FOR t : getTransitions(b)»
						[«t»]
					«ENDFOR»
				}
			«ENDFOR»
		«ENDIF»
		«FOR b: getBlocks»
			«FOR t : getTransitions(b)»
				«FOR elm : getIntputs(t)»
					«IF !pn.is_internal_place(elm) && printBlocks»«elm» --> [«t»]«ENDIF»
					«IF !printBlocks»«elm» --> [«t»]«ENDIF»
				«ENDFOR»
				«FOR elm : getOutputs(t)»
					«IF !pn.is_internal_place(elm) && printBlocks»[«t»] --> «elm»«ENDIF»
					«IF !printBlocks»[«t»] --> «elm»«ENDIF»
				«ENDFOR»
			«ENDFOR»
		«ENDFOR»
		@enduml
		'''
	}
}

class Place {
	public var bname = new String
	public var name = new String
	public var type = PType::IN
	public var TypeDecl custom_type
	new (String b, String n, PType t, TypeDecl ctype) {
		bname = b
		name = n
		type = t
		custom_type = ctype
	}
}

enum PType { IN, OUT, INOUT, LOCAL }

class Transition {
	public var bname = new String
	public var name = new String
	new (String b, String n) {
		bname = b
		name = n
	}
}

class MapBlockPort {
	public var in 	= new BlockPort
	public var out = new BlockPort
	
	new (BlockPort bin, BlockPort bout) {
		in = new BlockPort(bin.block_name, bin.var_name)
		out = new BlockPort(bout.block_name, bout.var_name)
	}
	
	def display() {
		System.out.println(" > in: " + in.display())
		System.out.println(" > out: " + out.display())
	}
}

class BlockPort {
	public var block_name 	= new String
	public var var_name 	= new String
	
	new() {}
	
	new (String bname, String vname) {
		block_name = bname
		var_name = vname
	}
	
	def display() {
		return " block name: " + block_name + " ; " + " var name: " + var_name 
	}
}



/*
def toSnakesSimulation() {
		'''
		import PySimpleGUI as sg
		import PIL
		from PIL import Image
		from plantuml import PlantUML
		import os
		import base64
		from os.path import abspath
		from io import BytesIO
		
		class Simulation:
		    
		    def convert_to_bytes(self, source, size=(None, None), subsample=None, zoom=None, fill=False):
		        if isinstance(source, str):
		            image = Image.open(source)
		        elif isinstance(source, bytes):
		            image = Image.open(io.BytesIO(base64.b64decode(source)))
		        else:
		            image = PIL.Image.open(io.BytesIO(source))
		    
		        width, height = image.size
		    
		        scale = None
		        if size != (None, None):
		            new_width, new_height = size
		            scale = min(new_height/height, new_width/width)
		        elif subsample is not None:
		            scale = 1/subsample
		        elif zoom is not None:
		            scale = zoom
		    
		        resized_image = image.resize((int(width * scale), int(height * scale)), Image.ANTIALIAS) if scale is not None else image
		        if fill and scale is not None:
		            resized_image = make_square(resized_image)
		        # encode a PNG formatted version of image into BASE64
		        with BytesIO() as bio:
		            resized_image.save(bio, format="PNG")
		            contents = bio.getvalue()
		            encoded = base64.b64encode(contents)
		        return encoded
		    
		    
		    def simulateUI(self,n):
		        trList = []
		        column = [[sg.Image(key="-IMAGE-")]]
		        buttonLayout = [
		                    [sg.Button("Start"),
		                    sg.Button("ZoomIn"),
		                    sg.Button("ZoomOut"),
		                    sg.Button("Fire")],
		                    [sg.Text('Enabled-Transitions')],
		                    [sg.Combo(['empty'], enable_events=True, key='enabled',size=(60, 0))],
		                    [sg.Text('Modes')],
		                    [sg.Listbox(trList, size=(60, len(trList) + 10), horizontal_scroll = True, key='modes')],
		                    [sg.Text('Marking')],
		                    [sg.Multiline('', size=(60,10), horizontal_scroll = True, key = 'marking')]
		        ]
		        layout = [
		            [sg.Column(column, size=(700, 500), scrollable=True, key='Column', expand_x=True, expand_y=True),
		            [sg.Checkbox('block-view', default=True, key='isBlockView')],
		            sg.VSeperator(),
		            sg.Column(buttonLayout, key='bColumn', expand_x=True, expand_y=True)],
		        ]
		        window = sg.Window("Simulator", layout, resizable=True)
		        server = PlantUML(url='http://www.plantuml.com/plantuml/img/', basic_auth={}, form_auth={}, http_opts={}, request_opts={})
		        zoomin = 0
		        zoomout = 0
		        isBlockViewEnabled = False
		        while True:
		            event, values = window.read()
		            if event == sg.WINDOW_CLOSED:
		                break
		            if event == "Fire":
		                # print(values['modes'])
		                # print(values['enabled'])
		                n.transition(self.dictTrName[values['enabled']]).fire(values['modes'][0])
		                self.generatePlantUML(n,values['isBlockView'])
		                # print(self.getEnabledTransitionList(n))
		                window['enabled'].update(values=self.getEnabledTransitionList(n))
		                #window['modes'].Widget.configure(height=len(trList)+10)
		                window['modes'].update(values=[])
		                marking_txt = ''
		                for k in n.get_marking():
		                    marking_txt += ' Queue: {0}\n'.format(k)
		                    marking_txt += '     Contents: {0}\n'.format(n.get_marking()[k])
		                window['marking'].update(marking_txt)
		                # print(values)
		                filename = 'simulation.plantuml'
		                if os.path.exists(filename):
		                    server.processes_file(abspath(filename))                    
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png'))
		                    if zoomin > 1: 
		                        window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', zoom=zoomin))
		                    if zoomout > 1:
		                        window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', subsample=zoomout))
		                    window.refresh()
		                    window['Column'].contents_changed()
		            if event == "enabled":
		                # print(values['enabled'])
		                trList = []
		                for key,value in self.dictTrMode.items():
		                    if key == values['enabled']:
		                        trList.append(value)
		                window['modes'].Widget.configure(height=len(trList)+10)
		                window['modes'].update(values=trList)
		            if event == "ZoomOut":
		                zoomout = zoomout + 1
		                if zoomin > 1: 
		                    zoomin = zoomin - 1
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', zoom=zoomin))
		                else:
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', subsample=zoomout))
		                window.refresh()
		                window['Column'].contents_changed()
		            if event == "ZoomIn":
		                zoomin = zoomin + 1
		                if zoomout > 1:
		                    zoomout = zoomout - 1
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', subsample=zoomout))
		                else:
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', zoom=zoomin))
		                window.refresh()
		                window['Column'].contents_changed()
		            if event == "Start":
		                self.generatePlantUML(n,values['isBlockView'])
		                # print(self.getEnabledTransitionList(n))
		                window['enabled'].update(values=self.getEnabledTransitionList(n))
		                marking_txt = ''
		                for k in n.get_marking():
		                    marking_txt += ' Queue: {0}\n'.format(k)
		                    marking_txt += '     Contents: {0}\n'.format(n.get_marking()[k])
		                window['marking'].update(marking_txt)
		                # print(values)
		                filename = 'simulation.plantuml'
		                if os.path.exists(filename):
		                    server.processes_file(abspath(filename))                    
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png'))
		                    window.refresh()
		                    window['Column'].contents_changed()
		    
		    
		    def getEnabledTransitionList(self,n):
		        trList = []
		        self.dictTrName = {}
		        self.dictTrMode = {}
		        for t in n.transition():
		            tmodes = t.modes()
		            idx = 0
		            for mode in tmodes:
		                #for key,value in mode.dict().items():
		                    #kv = ': {0}  -> {1}'.format(key,value)
		                trList.append(t.name + str(idx))
		                self.dictTrName.update({t.name + str(idx) : t.name})
		                self.dictTrMode.update({t.name + str(idx) : mode})
		                idx = idx + 1
		        return trList
		    
		    def simulate(self,n):
		        stop = False
		        while not stop:
		            dead_marking = False
		            enabled_transition_modes = {}
		            for t in n.transition():
		                tmodes = t.modes()
		                for mode in tmodes:
		                    print('\n')
		                    print(' Enabled-transition-name: ', t)
		                    print('    # with-input-modes: ')
		                    for key,value in mode.dict().items():
		                        print('      - var: ', key, '  ->  value:', value)
		                    # print('     > with mode: ', mode.dict())
		                    enabled_transition_modes[t] = mode
		    
		            if not enabled_transition_modes:
		                dead_marking = True
		    
		            choices = {}
		            idx = 0
		            for key, value in enabled_transition_modes.items():
		                choices[idx] = key, value
		                idx = idx + 1
		    
		            for k, v in choices.items():
		                print('\n')
		                print('Possible-choices: ')
		                print('    + choice: ', k, ' with-mode: ', v)
		    
		            if not dead_marking:
		                print('\n')
		                value = input(" Enter Choice: ")
		                print('\n')
		                print(' - Selected transition: ', choices.get(int(value)))
		                t, m = choices.get(int(value))
		                t.fire(m)
		                print('\n')
		                print(' [ Transition Fired! ]')
		                print('\n')
		                print(' Resulting Marking: ')
		                for k in n.get_marking():
		                    print('    + Place: ', k, ' has Token: ', n.get_marking()[k])
		                print('****************************************************************')
		                self.generatePlantUML(n,True)
		            else:
		                print('No Enabled Transitions!!')
		                stop = True
		    
		    
		    def getTransitionName(self,t,isDetailed):
		        if isDetailed:
		            return t.name
		        else:
		            return t.name.split('_')[0]
		    
		    
		    def generatePlantUML(self, n, isDetailed):
		        print('generating animation...')
		        fname = "simulation.plantuml"
		        txt = ''
		        txt += '@startuml'
		        txt += '\n'
		        placeList = []
		        transitionList = []
		        
		        for k in n.get_marking():
		            print('    + Place: ', k, ' has Token: ', n.get_marking()[k])
		            placeList.append(k)
		            # txt += 'interface {0} #yellow\n'.format(k)
		        for t in n.transition():
		            tmodes = t.modes()
		            for mode in tmodes:
		                print('\n')
		                print(' Enabled-transition-name: ', t)
		                # transitionList.append(t.name)
		                transitionList.append(self.getTransitionName(t,isDetailed))
		                # txt += 'component {0} #yellow\n'.format(self.getTransitionName(t,isDetailed))
		        
		        net_places = []
		        net_transitions = []
		        
		        for p in n.place():
		            net_places.append(p.name)
		        for t in n.transition():
		            net_transitions.append(self.getTransitionName(t,isDetailed))
		        
		        for p in sorted(net_places):
		            if p in placeList:
		                if not "local" in p:
		                    txt += 'interface {0} #yellow\n'.format(p)
		            else:
		                if not "local" in p:
		                    txt += 'interface {0} #white\n'.format(p)
		        for t in sorted(net_transitions):
		            if t in transitionList:
		                if isDetailed:
		                    txt += 'component {0} #yellow\n'.format(self.getTransitionName(n.transition(t),isDetailed))
		                else:
		                    txt += 'component {0} #yellow\n'.format(t)
		            else:
		                if isDetailed:
		                    txt += 'component {0} #white\n'.format(self.getTransitionName(n.transition(t),isDetailed))
		                else:
		                    txt += 'component {0} #white\n'.format(t)
		        
		        conn = set()
		        for t in n.transition():
		            for p in n.pre(t.name):
		                str = ''
		                if not "local" in p:
		                    str = '{0} --> [{1}]\n'.format(p,self.getTransitionName(t,isDetailed))
		                if not str in conn:
		                    if not "local" in p:
		                        txt += '{0} --> [{1}]\n'.format(p,self.getTransitionName(t,isDetailed))
		                    conn.add(str)
		            for p in n.post(t.name):
		                str = ''
		                if not "local" in p:
		                    str = '[{1}] --> {0}\n'.format(p,self.getTransitionName(t,isDetailed))
		                if not str in conn:
		                    if not "local" in p:
		                        txt += '[{1}] --> {0}\n'.format(p,self.getTransitionName(t,isDetailed))
		                    conn.add(str)
		        
		        txt += '@enduml'
		        with open(fname, 'w') as f:
		            f.write(txt)

		'''
	} 
*/