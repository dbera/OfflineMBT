/*
 * generated by Xtext 2.29.0
 */
package nl.asml.matala.product.generator

import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import nl.asml.matala.product.product.ActionType
import nl.asml.matala.product.product.Block
import nl.asml.matala.product.product.Product
import nl.asml.matala.product.product.RefConstraint
import nl.asml.matala.product.product.SymbConstraint
import nl.asml.matala.product.product.UpdateOutVar
import nl.asml.matala.product.product.VarRef
import nl.esi.comma.actions.actions.AssignmentAction
import nl.esi.comma.actions.actions.RecordFieldAssignmentAction
import nl.esi.comma.expressions.expression.ExpressionAddition
import nl.esi.comma.expressions.expression.ExpressionAnd
import nl.esi.comma.expressions.expression.ExpressionAny
import nl.esi.comma.expressions.expression.ExpressionBulkData
import nl.esi.comma.expressions.expression.ExpressionConstantBool
import nl.esi.comma.expressions.expression.ExpressionConstantInt
import nl.esi.comma.expressions.expression.ExpressionConstantReal
import nl.esi.comma.expressions.expression.ExpressionConstantString
import nl.esi.comma.expressions.expression.ExpressionDivision
import nl.esi.comma.expressions.expression.ExpressionEnumLiteral
import nl.esi.comma.expressions.expression.ExpressionEqual
import nl.esi.comma.expressions.expression.ExpressionFunctionCall
import nl.esi.comma.expressions.expression.ExpressionGeq
import nl.esi.comma.expressions.expression.ExpressionGreater
import nl.esi.comma.expressions.expression.ExpressionLeq
import nl.esi.comma.expressions.expression.ExpressionLess
import nl.esi.comma.expressions.expression.ExpressionMapRW
import nl.esi.comma.expressions.expression.ExpressionMaximum
import nl.esi.comma.expressions.expression.ExpressionMinimum
import nl.esi.comma.expressions.expression.ExpressionMinus
import nl.esi.comma.expressions.expression.ExpressionModulo
import nl.esi.comma.expressions.expression.ExpressionMultiply
import nl.esi.comma.expressions.expression.ExpressionNEqual
import nl.esi.comma.expressions.expression.ExpressionNot
import nl.esi.comma.expressions.expression.ExpressionOr
import nl.esi.comma.expressions.expression.ExpressionPlus
import nl.esi.comma.expressions.expression.ExpressionPower
import nl.esi.comma.expressions.expression.ExpressionQuantifier
import nl.esi.comma.expressions.expression.ExpressionRecord
import nl.esi.comma.expressions.expression.ExpressionRecordAccess
import nl.esi.comma.expressions.expression.ExpressionSubtraction
import nl.esi.comma.expressions.expression.ExpressionUnary
import nl.esi.comma.expressions.expression.ExpressionVariable
import nl.esi.comma.expressions.expression.ExpressionVector
import nl.esi.comma.expressions.expression.Field
import nl.esi.comma.expressions.expression.Variable
import nl.esi.comma.types.generator.TypesZ3Generator
import nl.esi.comma.types.types.RecordField
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.SimpleTypeDecl
import nl.esi.comma.types.types.Type
import nl.esi.comma.types.types.TypeDecl
import nl.esi.comma.types.types.TypesModel
import nl.esi.comma.types.types.VectorTypeConstructor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import nl.asml.matala.product.product.Update

/**
 * Generates code from your *.ps model files on save.
 */
 
class ProductGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, 
		IFileSystemAccess2 fsa, IGeneratorContext context
	) {
		var prod = resource.allContents.head
		if(prod instanceof Product) {
			if (prod.specification !== null) {
				generatePetriNetAndTestGeneration(prod,resource,fsa)
			}
		}
	}
	
	def generatePetriNetAndTestGeneration(Product prod, Resource resource, IFileSystemAccess2 fsa) 
	{	
		var dataGetterTxt = (new TypesGenerator).generatePythonGetters(prod,resource)
		var pnet = new PetriNet
		var methodTxt = ''''''	
		var sutTypesList = new ArrayList<String>	

		var inout_places = new ArrayList<String>
		var init_places = new ArrayList<String>
		
		var depth_limit = prod.specification.limit 
		
		var num_tests = prod.specification.numTests
		
		var import_list = new ArrayList<String>
		var var_decl_map = new HashMap<String,String>
		
		/* Generate Z3 Data Types */
		for(imp : prod.imports) {
			// Assumption: At most one
			val typeResource = EcoreUtil2.getResource(resource, imp.importURI)
			var typeInst = typeResource.allContents.head
			if(typeInst instanceof TypesModel) {
				var txt = (new TypesZ3Generator).generateAllUserDefinedTypes(typeInst) 
				fsa.generateFile('CPNServer//' + prod.specification.name + '//Z3//' + prod.specification.name + '_z3types.py', txt)
			}
			import_list.add(imp.importURI)
		}
		
		// DB 05.04.2025. Added to handle SUT Types List
		if(prod.sutTypes !== null) for(typ : prod.sutTypes.type) { sutTypesList.add(typ.type.name) }
		
		for(b : prod.specification.blocks) {
			var Block block = null
			if (b.block !== null) {
				block = b.block
			}
			if (b.refBlock !== null) {
				block = b.refBlock.system
			}
			// populate var and its type decl in map
			for(invar : block.invars) var_decl_map.put(block.name + "_" + invar.name, invar.type.type.name)
			for(ovar : block.outvars) var_decl_map.put(block.name + "_" + ovar.name, ovar.type.type.name)
			for(lvar : block.localvars) var_decl_map.put(block.name + "_" + lvar.name, lvar.type.type.name)
			
			// parse each block to derive places and transitions
			var tuple = populatePetriNet(pnet, block)
			pnet = tuple.key
			methodTxt += tuple.value		
		}
		
		fsa.generateFile('CPNServer//' + prod.specification.name + '//' + prod.specification.name + '_types.py', (new Utils()).toTypes(prod.specification.name + "_types", import_list, var_decl_map))
		fsa.generateFile('CPNServer//' + prod.specification.name + '//plantuml//' + prod.specification.name + '_model.plantuml', pnet.toPlantUML(pnet, false))
		fsa.generateFile('CPNServer//' + prod.specification.name + '//plantuml//' + prod.specification.name + '_system.plantuml', pnet.toPlantUML(pnet, true))
		
		pnet.display
		
		if(true)
		{
			var listOfEnvBlocks = new ArrayList<String>
			for(b : prod.specification.envBlock) listOfEnvBlocks.add(b.name)
			
			var listOfAssertTransitions = new ArrayList<String>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
						    if(u.actionType.equals(ActionType.COMPOSE) 
						        || u.actionType.equals(ActionType.RUN)
						        || u.actionType.equals(ActionType.ASSERT)
						    ) {
						        listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
						    }
							// 30.01.2025 commented out
							/*for(fi : u.fnInp) {
								if(fi.dataConstraints !== null) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
							}*/
							//for(ovar : u.updateOutputVar) {
							    // if(ovar.assert) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
								// 30.01.2025 commented out and replaced with line above. 
								/*for(fo : ovar.fnOut) {
									if(fo.dataConstraints !== null) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
								}*/
							//}
						}
					}
				}
			}
			// transition names -> list of output variables that were suppressed
			var mapOfSuppressTransitionVars = new HashMap<String,List<String>>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
							for(ovar : u.updateOutputVar) {
								if(ovar.suppress) {
									// ADDED 08.11.2024 DB. Record out variables that were suppressed for a transition
									// Is transition name present?
									if(mapOfSuppressTransitionVars.containsKey(block.name+"_" + f.name + "_" + u.name)) {
										for(elm : ovar.fnOut) {
											// 08.11.2024 Assumption is that produces output does not have multiple vars (|ovar.fnOut| = 1)
											mapOfSuppressTransitionVars.get(block.name+"_" + f.name + "_" + u.name).add(elm.ref.name)
										}
									} else {
										for(elm : ovar.fnOut) {
											// 08.11.2024 Assumption is that produces output does not have multiple vars (|ovar.fnOut| = 1)
											var strList = new ArrayList<String>() 
											strList.add(elm.ref.name)
											mapOfSuppressTransitionVars.put(block.name+"_" + f.name + "_" + u.name, strList)
										}
									}
									// listOfSuppressTransitions.add(block.name+"_" + f.name + "_" + u.name)
								}
							}
						}
					}
				}
			}
			
			var name = prod.specification.name
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '.py', pnet.toSnakes(name, name, listOfEnvBlocks, listOfAssertTransitions, mapOfSuppressTransitionVars, inout_places, init_places, depth_limit, num_tests, sutTypesList))
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + 'server.py', (new FlaskSimulationGenerator).generateServer(name))
			fsa.generateFile('CPNserver.py', (new FlaskSimulationGenerator).generateCPNServer)
			fsa.generateFile('CPNclient.py', (new FlaskSimulationGenerator).generateCPNClient(prod.specification.name))
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + 'client.py', (new FlaskSimulationGenerator).generateClient)
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '_Simulation.py', pnet.toSnakesSimulation)
			
            // generate utils for HTTP server
            fsa.generateFile('CPNServer//' + prod.specification.name + '//' + '__init__.py', 
                (new FlaskSimulationGenerator).generateInitForCPNSpecPkg(prod)
            )
            fsa.generateFile('CPNServer//' + '__init__.py', 
                (new FlaskSimulationGenerator).generateInitForCPNServerSpecPkg(prod)
            )
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '_data.py', (new Utils()).getDataContainerClass(dataGetterTxt, methodTxt))
			fsa.generateFile('CPNServer//' + prod.specification.name + '//' + name + '_TestSCN.py', (new Utils()).generateTestSCNTxt(prod.specification.name + "_types", prod, resource.URI.lastSegment))
            fsa.generateFile('__init__.py', 
                (new FlaskSimulationGenerator).generateInitForSrcGen()
            )
		}
	}
	
	def Pair<PetriNet,String> populatePetriNet(PetriNet pnet, Block block) {
		var methodTxt = ''''''		
		var map_output_input = new HashMap<String, List<String>>
		// populate list of places
		/* 23.01.24 */
		for(invar : block.invars) {
			// System.out.println(" Debug: " + invar.name)
			// pnet.places.add(new Place(block.name, block.name+"_"+invar.name, PType.IN, invar.type.type))
			pnet.places.add(new Place(block.name, invar.name, PType.IN, invar.type.type))
		}
		// since we will use the map_output_input to map directly to an input place while creating outgoing arcs
		/* 23.01.24 */ // uncommented
		for(outvar : block.outvars) {
			pnet.places.add(new Place(block.name, outvar.name, PType.OUT, outvar.type.type))
		}
		/* 23.01.24 */
		for(localvar : block.localvars) {
			// pnet.places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			// pnet.internal_places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			pnet.places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			pnet.internal_places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			// TODO add as class members in python class of this block
		}
		
		//val (String) => String func = [s|block.name+"_"+s]
		val (String) => String func = [s|s]
					
		for(act : block.initActions) {
			System.out.println(" Init-Action LHS: " + SnakesHelper.action(act, func, "").split("=",2).get(0))
			System.out.println(" Init-Action RHS: " + SnakesHelper.action(act, func, "").split("=",2).get(1))
			
			pnet.add_to_init_place_expression_map(
				SnakesHelper.action(act, func,"").split("=",2).get(0), 
				SnakesHelper.action(act, func,"").split("=",2).get(1)
			)
		}
		
		// populate transitions
		for(f : block.functions) {
			System.out.println(" Function-name: " + f.name)
			for(update : f.updates) 
			{
				System.out.println("  > case: " + update.name)
				var tname = f.name + "_" + update.name + "@" + update.stepType + "@" + update.actionType + "@"
				var tr = new Transition(block.name, block.name+"_"+tname)
				pnet.transitions.add(tr)
				var input_var_list = new HashMap<String,TypeDecl> // ArrayList<String>
				for(v : update.fnInp) 
				{
					// place is already added before
					System.out.println("	> in-var-name: " + block.name + "_"+ v.ref.name)
					//if(v.opt) inout_places.add(block.name+"_"+v.ref.name)
					//if(v.init) init_places.add(block.name+"_"+v.ref.name)
					
					/* commenting out the use of opt and init places: 17.02.2024 */
					/* if(v.opt) inout_places.add(v.ref.name)
					if(v.init) init_places.add(v.ref.name) */
					
					/* 23.01.24 */
					//input_var_list.put(block.name+"_"+v.ref.name, v.ref.type.type)
					input_var_list.put(v.ref.name, v.ref.type.type)
					pnet.add_input_arc(tr.name, v.ref.name)
					/* 23.01.24 */
					// pnet.add_expression(tr.name, block.name + "_" + v.ref.name, 
					//						"Variable('v_" + block.name+"_" + v.ref.name + "')", PType.IN)
					pnet.add_expression(tr.name, v.ref.name, 
											"Variable('v_" + v.ref.name + "')",
											 PType.IN, getConstraintTxt(v))
				}
				if(update.guard!==null) {
					val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
					System.out.println("	> guard: " + SnakesHelper.expression(update.guard, fn))
					pnet.add_guard_expression(tr.name, "Expression('" + SnakesHelper.expression(update.guard, fn) + "')")
				}
				if(update.dataAssertions!==null) {
				    System.out.println("\t> assert: " + (new Utils()).printConstraint(update.dataAssertions)) 
				    pnet.add_assert_expression_ref(tr.name, (new Utils()).printConstraint(update.dataAssertions))
				}
				if(update.updateOutputVar!==null) 
				{
					var isActionsPresent = false
					for(outvar : update.updateOutputVar) 
					{
						var actTxt = ''''''
						
						isActionsPresent = false
						if(outvar.act !== null) 
						{
							isActionsPresent = true
							
							// Added DB. 05.04.2025. 
							// Support for auto constructors
							for(v : outvar.fnOut) {
							    System.out.println(" > auto-constructor: " + 
							        SnakesHelper.defaultValue(v.ref.type.type, v.ref.name)
							    )
							    actTxt +=
							    '''
                                    «v.ref.name» = «SnakesHelper.defaultValue(v.ref.type.type, v.ref.name)»
							    '''
							}
							// End of support for auto-constructors
							
							for(a : outvar.act.actions) 
							{ 
								System.out.println("	> act: " + SnakesHelper.action(a, func,""))
								actTxt +=
								'''
								    «SnakesHelper.action(a, func, "")»
								'''
							}
						}
						for(v : outvar.fnOut) 
						{
							// logic for parsing output variables to Petri net places, arcs and their expressions
							var place = new String
							if(isActionsPresent)
								place = parseOutVariablesWithActions(block, map_output_input, 
										v, tr, pnet, f.name+"_"+update.name, input_var_list)
							else
								place = parseOutputVariables(block, map_output_input, v, tr, pnet)
							
							if(outvar.assert) pnet.add_to_map_transition_assertions(tr.name, place)
							
							var methodDef = 
							'''
								@staticmethod
								def execute_«f.name»_«update.name»_«place»(«FOR elm : input_var_list.keySet SEPARATOR ','»«elm»«ENDFOR»):
									«actTxt»
									«IF v.ref.type.type instanceof RecordTypeDecl»
										return json.dumps(«v.ref.name»)
									«ELSE»
										return «v.ref.name»
									«ENDIF»
							'''
							if(!actTxt.isEmpty) methodTxt += methodDef.trim + "\n\n"
						}
					}
				}
			}
		}
		return new Pair(pnet, methodTxt)
	}
	
	def getConstraintTxt(VarRef v) {
		var constraints = new ArrayList<Constraint>
		if(v.dataConstraints !== null) {
			for(c : v.dataConstraints.constr) {
				// val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
				val (String) => String fn = [s|s]
				// constraints.add(new Constraint(c.name, SnakesHelper.expression(c.symbExpr, fn)))
				
				// constraints to comma expression. 27.08.2024
				// Check if boolean expression or assignment action
//				constraints.add(new Constraint(c.name, (new ExpressionsCommaGenerator()).exprToComMASyntax(c.symbExpr).toString()))
				constraints.add(new Constraint((new Utils()).printConstraint(c as SymbConstraint), ""))
			}
		}
		if(v.dataReferences !== null) {
			for(c : v.dataReferences.constr) {
				val (String) => String fn = [s|s]
				for(a : c.act.actions)
//					constraints.add(new Constraint(c.name, SnakesHelper.commaAction(a, fn, "")))
					constraints.add(new Constraint((new Utils()).printConstraint(c as RefConstraint), ""))
			}
		}
		return constraints
	}
	
	def generateVarListTxt(Map<String,TypeDecl> input_var_map) {
		return '''(«FOR elm : input_var_map.keySet SEPARATOR ','»«generateVarTxt(input_var_map,elm)»«ENDFOR»)'''
	}
	
	def generateVarTxt(Map<String,TypeDecl> input_var_map, String elm) 
	{
		var txt = ''''''
		if(input_var_map.get(elm) instanceof RecordTypeDecl)
			txt += '''json.loads(v_«elm», object_pairs_hook=Data().int_keys)'''
		else 
			txt += '''v_«elm»'''
		return txt
	}

	def parseOutVariablesWithActions(Block block, HashMap<String, List<String>> map_output_input, 
									VarRef v, Transition tr, PetriNet pnet, String executeFnName, 
									Map<String,TypeDecl> input_var_list) 
	{
		System.out.println("	> out-var-name: " + block.name+"_"+v.ref.name)
		var vtype = v.ref.type.type.name
		var place = new String
		
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name))  /* 23.01.24 */ 
		{
			var outp = map_output_input.get(block.name+"_"+v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				place = p

				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, 
					   "Value(" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + ")", 
					   PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, 
					   "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", 
					   PType.OUT, getConstraintTxt(v))	
			}
		} 
		else 
		{ 
			/* 23.01.24 */
			// pnet.add_output_arc(tr.name, block.name+"_"+v.ref.name)
			pnet.add_output_arc(tr.name, v.ref.name)
			place = v.ref.name
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + "')", 
				    PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", 
				    PType.OUT, getConstraintTxt(v))
		}
		
		return place
	}
	
	def parseOutputVariables(Block block, HashMap<String, List<String>> map_output_input, 
							VarRef v, Transition tr, PetriNet pnet) 
	{
		// find mapping to input place in map_output_input
		System.out.println("	> out-var-name: " + v.ref.name)
		// System.out.println("> MAP: " + map_output_input)
		var vtype = v.ref.type.type.name
		var place = new String
		// Note assumption is that all output variable mapped to input var by user
		// TODO implement validation checker!
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name)) /* 23.01.24 */
		{
			var outp = map_output_input.get(v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				//pnet.add_expression(tr.name, p, "Expression('1')", PType.OUT)
				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, 
					   "Value(" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + ")", 
					   PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, 
					   "Expression('Data().get_" + vtype + "()')", 
					   PType.OUT, getConstraintTxt(v))
				
				place = p
			}
		} else 
		{ 
			// can reach here if output is not mapped and then this is a dangling arc
			/* 23.01.24 */
			pnet.add_output_arc(tr.name, v.ref.name)
			
			//pnet.add_expression(tr.name, block.name+"_"+v.ref.name, "Expression('1')", PType.OUT)
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + "')", 
				    PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('Data().get_" + vtype + "()')", 
				    PType.OUT, getConstraintTxt(v))
			
			/* Commented DB 06.02.2025 */
			// None of the other places have block name in prefix. 
			// Causes issues in assert transition list and linking of steps
			// TODO How to deal with data name collisions in BPMN model
			/* place = block.name+"_"+v.ref.name */
			place = v.ref.name
		}
		
		return place
	}
	
	def generateOnlineMBTController(Product envModel, Product sutModel, 
        IFileSystemAccess2 fsa, IGeneratorContext context) {
	    (new Utils()).generateOnlineMBTController(envModel, sutModel, fsa, context)
	}
}
