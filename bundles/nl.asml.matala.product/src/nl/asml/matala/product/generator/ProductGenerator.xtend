/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.29.0
 */
package nl.asml.matala.product.generator

import java.util.ArrayList
import java.util.HashMap
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import java.util.Set
import nl.asml.matala.product.product.ActionType
import nl.asml.matala.product.product.Block
import nl.asml.matala.product.product.Product
import nl.asml.matala.product.product.RefConstraint
import nl.asml.matala.product.product.SymbConstraint
import nl.asml.matala.product.product.VarRef
import nl.esi.comma.types.generator.TypesZ3Generator
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.SimpleTypeDecl
import nl.esi.comma.types.types.TypeDecl
import nl.esi.comma.types.types.TypesModel
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension nl.esi.comma.types.utilities.EcoreUtil3.serialize

/**
 * Generates code from your *.ps model files on save.
 */
 
class ProductGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
	    res.contents.filter(Product).reject[specification === null].forEach[generatePetriNetAndTestGeneration(res, fsa)]
    }
	
	def generatePetriNetAndTestGeneration(Product prod, Resource resource, IFileSystemAccess2 fsa) {
	    val specName = prod.specification.name
		val dataGetterTxt = (new TypesGenerator).generatePythonGetters(prod,resource)
		var pnet = new PetriNet
		var methodTxt = ''''''	
		val sutTransitionMap = newLinkedHashMap // sutvar -> transition_list (occurs in input/output)

		val inout_places = newArrayList
		val init_places = newArrayList
		
		val depth_limit = prod.specification.limit 
		
		val num_tests = prod.specification.numTests
		
		val import_list = newArrayList
		val var_decl_map = newLinkedHashMap
		
		/* Generate Z3 Data Types */
		for(imp : prod.imports) {
			// Assumption: At most one
			val typeResource = EcoreUtil2.getResource(resource, imp.importURI)
			var typeInst = typeResource.allContents.head
			if(typeInst instanceof TypesModel) {
				var txt = (new TypesZ3Generator).generateAllUserDefinedTypes(typeInst) 
				fsa.generateFile('CPNServer//' + specName + '//Z3//' + specName + '_z3types.py', txt)
			}
			import_list.add(imp.importURI)
		}
		
		for(b : prod.specification.blocks) {
			val Block block = b.block ?: b.refBlock?.system
			// populate var and its type decl in map
			for(invar : block.invars) var_decl_map.put(block.name + "_" + invar.name, invar.type.type.name)
			for(ovar : block.outvars) var_decl_map.put(block.name + "_" + ovar.name, ovar.type.type.name)
			for(lvar : block.localvars) var_decl_map.put(block.name + "_" + lvar.name, lvar.type.type.name)
			// Added DB 15.04.2025. To handle SUT Variables List
            for(sutvar : block.sutvars) {
                sutTransitionMap.put(sutvar.name, newLinkedHashSet)
            }
			
			// parse each block to derive places and transitions
			val tuple = populatePetriNet(pnet, block)
			pnet = tuple.key
			methodTxt += tuple.value		
		}
		
		fsa.generateFile('CPNServer//' + specName + '//' + specName + '_types.py', (new Utils()).toTypes(specName + "_types", import_list, var_decl_map))
		fsa.generateFile('CPNServer//' + specName + '//plantuml//' + specName + '_model.plantuml', pnet.toPlantUML(pnet, false))
		fsa.generateFile('CPNServer//' + specName + '//plantuml//' + specName + '_system.plantuml', pnet.toPlantUML(pnet, true))
		
		pnet.display
		
		if(true)
		{
			var listOfEnvBlocks = new ArrayList<String>
			for(b : prod.specification.envBlock) listOfEnvBlocks.add(b.name)
			
			var listOfAssertTransitions = new ArrayList<String>
			var mapOfTransitionQnames = new LinkedHashMap<String,String>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
                            val transitionName = block.name + "_" + f.name + "_" + u.name

						    if(u.actionType.equals(ActionType.COMPOSE) 
						        || u.actionType.equals(ActionType.RUN)
						        || u.actionType.equals(ActionType.ASSERT)
						    ) {
						        listOfAssertTransitions.add(transitionName)
						        mapOfTransitionQnames.put(transitionName, new Utils().printConstraint(u))
						    }
						    
						    // Added DB. 15.04.2025. Create map of sut-var to transitions
						    for(fi : u.fnInp) {
						        if(sutTransitionMap.containsKey(fi.ref.name)) {
						            sutTransitionMap.get(fi.ref.name).add(transitionName)
						        }
						    }
						    
							// 30.01.2025 commented out
							/*for(fi : u.fnInp) {
								if(fi.dataConstraints !== null) listOfAssertTransitions.add(transitionName)
							}*/
							//for(ovar : u.updateOutputVar) {
							    // if(ovar.assert) listOfAssertTransitions.add(transitionName)
								// 30.01.2025 commented out and replaced with line above. 
								/*for(fo : ovar.fnOut) {
									if(fo.dataConstraints !== null) listOfAssertTransitions.add(transitionName)
								}*/
							//}
						}
					}
				}
			}
			// transition names -> list of output variables that were suppressed
			val mapOfSuppressTransitionVars = new HashMap<String,Set<String>>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
						    val transitionName = block.name + "_" + f.name + "_" + u.name

							for(ovar : u.updateOutputVar) {
								for(elm : ovar.fnOut) {
								    // Added DB. 15.04.2025. Create map of sut-var to transitions
                                    if(sutTransitionMap.containsKey(elm.ref.name)) {
                                        sutTransitionMap.get(elm.ref.name).add(transitionName)
                                    }
								}
								if(ovar.suppress !== null) {
								    val suppressedVars = mapOfSuppressTransitionVars.computeIfAbsent(transitionName)[newLinkedHashSet]
								    if (ovar.suppress.varFields.isEmpty) {
                                        suppressedVars += ovar.fnOut.map[ref.name]
								    } else {
								        suppressedVars += ovar.suppress.varFields.map[serialize]
								    }
								}
							}
						}
					}
				}
			}
			
			fsa.generateFile('CPNServer//' + specName + '//' + specName + '.py', pnet.toSnakes(
                specName, specName, listOfEnvBlocks, listOfAssertTransitions,
                 mapOfTransitionQnames, mapOfSuppressTransitionVars, inout_places,
                init_places, depth_limit, num_tests, sutTransitionMap
            ))
			//fsa.generateFile('CPNServer//' + specName + '//' + 'server.py', (new FlaskSimulationGenerator).generateServer(name))
			//fsa.generateFile('CPNserver.py', (new FlaskSimulationGenerator).generateCPNServer)	
			//fsa.generateFile('CPNclient.py', (new FlaskSimulationGenerator).generateCPNClient(specName))
			//fsa.generateFile('CPNServer//' + specName + '//' + 'client.py', (new FlaskSimulationGenerator).generateClient)
			fsa.generateFile('CPNServer//' + specName + '//' + specName + '_Simulation.py', pnet.toSnakesSimulation)

            // generate utils for HTTP server
            fsa.generateFile('CPNServer//' + specName + '//' + '__init__.py', 
                (new FlaskSimulationGenerator).generateInitForCPNSpecPkg(prod)
            )
//            fsa.generateFile('CPNServer//' + '__init__.py', 
//                (new FlaskSimulationGenerator).generateInitForCPNServerSpecPkg(prod)
//            )
			fsa.generateFile('CPNServer//' + specName + '//' + specName + '_data.py', (new Utils()).getDataContainerClass(dataGetterTxt, methodTxt))
			fsa.generateFile('CPNServer//' + specName + '//' + specName + '_TestSCN.py', (new Utils()).generateTestSCNTxt(specName + "_types", prod, resource.URI.lastSegment))
//            fsa.generateFile('__init__.py', 
//                (new FlaskSimulationGenerator).generateInitForSrcGen()
//            )
		}
	}
	
	def Pair<PetriNet,String> populatePetriNet(PetriNet pnet, Block block) {
		var methodTxt = ''''''		
		var map_output_input = new HashMap<String, List<String>>
		// populate list of places
		/* 23.01.24 */
		for(invar : block.invars) {
			// System.out.println(" Debug: " + invar.name)
			// pnet.places.add(new Place(block.name, block.name+"_"+invar.name, PType.IN, invar.type.type))
			pnet.places.add(new Place(block.name, invar.name, PType.IN, invar.type.type))
		}
		// since we will use the map_output_input to map directly to an input place while creating outgoing arcs
		/* 23.01.24 */ // uncommented
		for(outvar : block.outvars) {
			pnet.places.add(new Place(block.name, outvar.name, PType.OUT, outvar.type.type))
		}
		/* 23.01.24 */
		for(localvar : block.localvars) {
			// pnet.places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			// pnet.internal_places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			pnet.places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			pnet.internal_places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			// TODO add as class members in python class of this block
		}
		
		//val (String) => String func = [s|block.name+"_"+s]
		val (String) => String func = [s|s]
					
		for(act : block.initActions.map[SnakesHelper.action(it, func, "").split("=",2)].map[get(0) -> get(1)]) {
			System.out.println(" Init-Action LHS: " + act.key)
			System.out.println(" Init-Action RHS: " + act.value)
			
			pnet.add_to_init_place_expression_map(act.key, act.value)
		}
		
		// populate transitions
		for(f : block.functions) {
			System.out.println(" Function-name: " + f.name)
			for(update : f.updates) 
			{
				System.out.println("  > case: " + update.name)
				var tname = f.name + "_" + update.name + "@" + update.stepType + "@" + update.actionType + "@"
				var qname = new Utils().printConstraint(update)
				var tr = new Transition(block.name, block.name+"_"+tname, qname)
				pnet.transitions.add(tr)
				var input_var_list = new HashMap<String,TypeDecl> // ArrayList<String>
				for(v : update.fnInp) 
				{
					// place is already added before
					System.out.println("	> in-var-name: " + block.name + "_"+ v.ref.name)
					//if(v.opt) inout_places.add(block.name+"_"+v.ref.name)
					//if(v.init) init_places.add(block.name+"_"+v.ref.name)
					
					/* commenting out the use of opt and init places: 17.02.2024 */
					/* if(v.opt) inout_places.add(v.ref.name)
					if(v.init) init_places.add(v.ref.name) */
					
					/* 23.01.24 */
					//input_var_list.put(block.name+"_"+v.ref.name, v.ref.type.type)
					input_var_list.put(v.ref.name, v.ref.type.type)
					pnet.add_input_arc(tr.name, v.ref.name)
					/* 23.01.24 */
					// pnet.add_expression(tr.name, block.name + "_" + v.ref.name, 
					//						"Variable('v_" + block.name+"_" + v.ref.name + "')", PType.IN)
					pnet.add_expression(tr.name, v.ref.name, 
											"Variable('v_" + v.ref.name + "')",
											 PType.IN, getConstraintTxt(v))
				}
				if(update.guard!==null) {
					val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
					System.out.println("	> guard: " + SnakesHelper.expression(update.guard, fn))
					pnet.add_guard_expression(tr.name, "Expression('" + SnakesHelper.expression(update.guard, fn) + "')")
				}
				if(update.dataAssertions!==null) {
				    System.out.println("\t> assert: " + (new Utils()).printConstraint(update.dataAssertions)) 
				    pnet.add_assert_expression_ref(tr.name, (new Utils()).printConstraint(update.dataAssertions))
				}
				if(update.updateOutputVar!==null) 
				{
					var isActionsPresent = false
					for(outvar : update.updateOutputVar) 
					{
						var actTxt = ''''''
						
						isActionsPresent = false
						if(outvar.act !== null) 
						{
							isActionsPresent = true
							
							// Added DB. 05.04.2025. 
							// Support for auto constructors
//							for(v : outvar.fnOut) {
//							    System.out.println(" > auto-constructor: " + 
//							        SnakesHelper.defaultValue(v.ref.type.type, v.ref.name)
//							    )
//							    actTxt +=
//							    '''
//                                    «v.ref.name» = «SnakesHelper.defaultValue(v.ref.type.type, v.ref.name)»
//							    '''
//							}
							// End of support for auto-constructors
							
							for(a : outvar.act.actions) 
							{ 
								System.out.println("	> act: " + SnakesHelper.action(a, func,""))
								actTxt +=
								'''
								    «SnakesHelper.action(a, func, "")»
								'''
							}
						}
						for(v : outvar.fnOut) 
						{
							// logic for parsing output variables to Petri net places, arcs and their expressions
							var place = new String
							if(isActionsPresent)
								place = parseOutVariablesWithActions(block, map_output_input, 
										v, tr, pnet, f.name+"_"+update.name, input_var_list)
							else
								place = parseOutputVariables(block, map_output_input, v, tr, pnet)
							
							if(outvar.assert) pnet.add_to_map_transition_assertions(tr.name, place)
							
							var methodDef = 
							'''
								@staticmethod
								def execute_«f.name»_«update.name»_«place»(«FOR elm : input_var_list.keySet SEPARATOR ','»«elm»«ENDFOR»):
									«actTxt»
									«IF v.ref.type.type instanceof RecordTypeDecl»
										return json.dumps(«v.ref.name»)
									«ELSE»
										return «v.ref.name»
									«ENDIF»
							'''
							if(!actTxt.isEmpty) methodTxt += methodDef.trim + "\n\n"
						}
					}
				}
			}
		}
		return new Pair(pnet, methodTxt)
	}
	
	def getConstraintTxt(VarRef v) {
		var constraints = new ArrayList<Constraint>
		if(v.dataConstraints !== null) {
			for(c : v.dataConstraints.constr) {
				// val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
				val (String) => String fn = [s|s]
				// constraints.add(new Constraint(c.name, SnakesHelper.expression(c.symbExpr, fn)))
				
				// constraints to comma expression. 27.08.2024
				// Check if boolean expression or assignment action
//				constraints.add(new Constraint(c.name, (new ExpressionsCommaGenerator()).exprToComMASyntax(c.symbExpr).toString()))
				constraints.add(new Constraint((new Utils()).printConstraint(c as SymbConstraint), ""))
			}
		}
		if(v.dataReferences !== null) {
			for(c : v.dataReferences.constr) {
				val (String) => String fn = [s|s]
				for(a : c.act.actions)
//					constraints.add(new Constraint(c.name, SnakesHelper.commaAction(a, fn, "")))
					constraints.add(new Constraint((new Utils()).printConstraint(c as RefConstraint), ""))
			}
		}
		return constraints
	}
	
	def generateVarListTxt(Map<String,TypeDecl> input_var_map) {
		return '''(«FOR elm : input_var_map.keySet SEPARATOR ','»«generateVarTxt(input_var_map,elm)»«ENDFOR»)'''
	}
	
	def generateVarTxt(Map<String,TypeDecl> input_var_map, String elm) 
	{
		var txt = ''''''
		if(input_var_map.get(elm) instanceof RecordTypeDecl)
			txt += '''json.loads(v_«elm», object_pairs_hook=Data().int_keys)'''
		else 
			txt += '''v_«elm»'''
		return txt
	}

	def parseOutVariablesWithActions(Block block, HashMap<String, List<String>> map_output_input, 
									VarRef v, Transition tr, PetriNet pnet, String executeFnName, 
									Map<String,TypeDecl> input_var_list) 
	{
		System.out.println("	> out-var-name: " + block.name+"_"+v.ref.name)
		var vtype = v.ref.type.type.name
		var place = new String
		
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name))  /* 23.01.24 */ 
		{
			var outp = map_output_input.get(block.name+"_"+v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				place = p

				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, 
					   "Value(" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + ")", 
					   PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, 
					   "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", 
					   PType.OUT, getConstraintTxt(v))	
			}
		} 
		else 
		{ 
			/* 23.01.24 */
			// pnet.add_output_arc(tr.name, block.name+"_"+v.ref.name)
			pnet.add_output_arc(tr.name, v.ref.name)
			place = v.ref.name
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + "')", 
				    PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", 
				    PType.OUT, getConstraintTxt(v))
		}
		
		return place
	}
	
	def parseOutputVariables(Block block, HashMap<String, List<String>> map_output_input, 
							VarRef v, Transition tr, PetriNet pnet) 
	{
		// find mapping to input place in map_output_input
		System.out.println("	> out-var-name: " + v.ref.name)
		// System.out.println("> MAP: " + map_output_input)
		var vtype = v.ref.type.type.name
		var place = new String
		// Note assumption is that all output variable mapped to input var by user
		// TODO implement validation checker!
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name)) /* 23.01.24 */
		{
			var outp = map_output_input.get(v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				//pnet.add_expression(tr.name, p, "Expression('1')", PType.OUT)
				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, 
					   "Value(" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + ")", 
					   PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, 
					   "Expression('Data().get_" + vtype + "()')", 
					   PType.OUT, getConstraintTxt(v))
				
				place = p
			}
		} else 
		{ 
			// can reach here if output is not mapped and then this is a dangling arc
			/* 23.01.24 */
			pnet.add_output_arc(tr.name, v.ref.name)
			
			//pnet.add_expression(tr.name, block.name+"_"+v.ref.name, "Expression('1')", PType.OUT)
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('" + SnakesHelper.defaultValue(v.ref.type.type, v.ref.name) + "')", 
				    PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, 
				    "Expression('Data().get_" + vtype + "()')", 
				    PType.OUT, getConstraintTxt(v))
			
			/* Commented DB 06.02.2025 */
			// None of the other places have block name in prefix. 
			// Causes issues in assert transition list and linking of steps
			// TODO How to deal with data name collisions in BPMN model
			/* place = block.name+"_"+v.ref.name */
			place = v.ref.name
		}
		
		return place
	}
	
	def generateOnlineMBTController(Product envModel, Product sutModel, 
        IFileSystemAccess2 fsa, IGeneratorContext context) {
	    (new Utils()).generateOnlineMBTController(envModel, sutModel, fsa, context)
	}
}
