/*
 * generated by Xtext 2.29.0
 */
package nl.asml.matala.product.generator

import java.util.ArrayList
import java.util.HashMap
import java.util.List
import nl.asml.matala.product.product.Product
import nl.esi.comma.types.types.SimpleTypeDecl
import nl.esi.comma.types.types.TypeDecl
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import nl.asml.matala.product.product.VarRef
import nl.asml.matala.product.product.Block
import java.util.Map
import nl.esi.comma.types.types.RecordTypeDecl
import java.util.HashSet
import org.eclipse.xtext.xbase.lib.Pair


/**
 * Generates code from your *.ps model files on save.
 */
 
class ProductGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var prod = resource.allContents.head
		if(prod instanceof Product) {
			if (prod.specification !== null) {
				generatePetriNet(prod,resource,fsa)
			}
		}
	}
	
	def generatePetriNet(Product prod, Resource resource, IFileSystemAccess2 fsa) 
	{	
		var dataGetterTxt = (new TypesGenerator).generatePythonGetters(prod,resource)
		var pnet = new PetriNet
		var methodTxt = ''''''		

		var inout_places = new ArrayList<String>
		var init_places = new ArrayList<String>
		
		var depth_limit = prod.specification.limit 
		
		for(b : prod.specification.blocks) {
			var Block block = null
			// if it works make it recursive
			if (b.block !== null) {
				block = b.block
			}
			if (b.refBlock !== null) {
				block = b.refBlock.system
			}
			// parse each block to derive places and transitions
			var tuple = populatePetriNet(pnet, block)
			pnet = tuple.key
			methodTxt += tuple.value		
		}
		
		
		fsa.generateFile(prod.specification.name + '_model.plantuml', pnet.toPlantUML(pnet, false))
		fsa.generateFile(prod.specification.name + '_system.plantuml', pnet.toPlantUML(pnet, true))
		
		pnet.display
		
		if(true)
		{
			var listOfEnvBlocks = new ArrayList<String>
			for(b : prod.specification.envBlock) listOfEnvBlocks.add(b.name)
			
			var listOfAssertTransitions = new ArrayList<String>
			for(b : prod.specification.blocks) {
				if (b.block !== null) {
					val block = b.block
					for(f : block.functions) {
						for(u : f.updates) {
							for(fi : u.fnInp) {
								if(fi.dataConstraints !== null) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
							}
							for(ovar : u.updateOutputVar) {
								for(fo : ovar.fnOut) {
									if(fo.dataConstraints !== null) listOfAssertTransitions.add(block.name+"_" + f.name + "_" + u.name)
								}
							}
						}
					}
				}
			}
			var name = prod.specification.name
			fsa.generateFile(name + '.py', pnet.toSnakes(name, name, listOfEnvBlocks, listOfAssertTransitions, inout_places, init_places, depth_limit))
			
			fsa.generateFile(name + '_Simulation.py', pnet.toSnakesSimulation)
				
			var data_container_class = 
			'''
			import copy
			import json
			
			
			class Data:
				
				@staticmethod
				def int_keys(ordered_pairs):
					result = {}
					for key, value in ordered_pairs:
						try:
							key = int(key)
						except ValueError:
							pass
						result[key] = value
					return result
				
				«dataGetterTxt»
				«methodTxt»
			'''
			fsa.generateFile(name + '_data.py', data_container_class)
			
			fsa.generateFile(name + '_TestSCN.py', generateTestSCNTxt)
			
			// execute python code
			// val relativeFile = fsa.getURI(prod.name + '.py')
			// var path = ResourcesPlugin.workspace.root.getFile(new Path(relativeFile.toPlatformString(true))).rawLocation.toOSString
			// System.out.println("Path-to-generated-python-file: " +  path)
			// var p = Runtime.getRuntime().exec("python " + path);
		}
	}
	
	def Pair<PetriNet,String> populatePetriNet(PetriNet pnet, Block block) {
		var methodTxt = ''''''		
		var map_output_input = new HashMap<String, List<String>>
		// populate list of places
		/* 23.01.24 */
		for(invar : block.invars) {
			// System.out.println(" Debug: " + invar.name)
			// pnet.places.add(new Place(block.name, block.name+"_"+invar.name, PType.IN, invar.type.type))
			pnet.places.add(new Place(block.name, invar.name, PType.IN, invar.type.type))
		}
		// since we will use the map_output_input to map directly to an input place while creating outgoing arcs
		/* 23.01.24 */ // uncommented
		for(outvar : block.outvars) {
			pnet.places.add(new Place(block.name, outvar.name, PType.OUT, outvar.type.type))
		}
		/* 23.01.24 */
		for(localvar : block.localvars) {
			// pnet.places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			// pnet.internal_places.add(new Place(block.name, block.name+"_"+localvar.name, PType.LOCAL, localvar.type.type))
			pnet.places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			pnet.internal_places.add(new Place(block.name, localvar.name, PType.LOCAL, localvar.type.type))
			// TODO add as class members in python class of this block
		}
		
		//val (String) => String func = [s|block.name+"_"+s]
		val (String) => String func = [s|s]
					
		for(act : block.initActions) {
			System.out.println(" Init-Action LHS: " + SnakesHelper.action(act, func, "").split("=",2).get(0))
			System.out.println(" Init-Action RHS: " + SnakesHelper.action(act, func, "").split("=",2).get(1))
			
			pnet.add_to_init_place_expression_map(
				SnakesHelper.action(act, func,"").split("=",2).get(0), 
				SnakesHelper.action(act, func,"").split("=",2).get(1)
			)
		}
		
		// populate transitions
		for(f : block.functions) {
			System.out.println(" Function-name: " + f.name)
			for(update : f.updates) 
			{
				System.out.println("  > case: " + update.name)
				var tname = f.name + "_" + update.name
				var tr = new Transition(block.name, block.name+"_"+tname)
				pnet.transitions.add(tr)
				var input_var_list = new HashMap<String,TypeDecl> // ArrayList<String>
				for(v : update.fnInp) 
				{
					// place is already added before
					System.out.println("	> in-var-name: " + block.name + "_"+ v.ref.name)
					//if(v.opt) inout_places.add(block.name+"_"+v.ref.name)
					//if(v.init) init_places.add(block.name+"_"+v.ref.name)
					
					/* commenting out the use of opt and init places: 17.02.2024 */
					/* if(v.opt) inout_places.add(v.ref.name)
					if(v.init) init_places.add(v.ref.name) */
					
					/* 23.01.24 */
					//input_var_list.put(block.name+"_"+v.ref.name, v.ref.type.type)
					input_var_list.put(v.ref.name, v.ref.type.type)
					pnet.add_input_arc(tr.name, v.ref.name)
					/* 23.01.24 */
					// pnet.add_expression(tr.name, block.name + "_" + v.ref.name, 
					//						"Variable('v_" + block.name+"_" + v.ref.name + "')", PType.IN)
					pnet.add_expression(tr.name, v.ref.name, 
											"Variable('v_" + v.ref.name + "')", PType.IN, getConstraintTxt(v))
				}
				if(update.guard!==null) {
					val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
					System.out.println("	> guard: " + SnakesHelper.expression(update.guard, fn))
					pnet.add_guard_expression(tr.name, "Expression('" + SnakesHelper.expression(update.guard, fn) + "')")	
				}
				if(update.updateOutputVar!==null) 
				{
					var isActionsPresent = false
					for(outvar : update.updateOutputVar) 
					{
						/*var decTxt = 
						'''
							«FOR v : outvar.hiddenVars»
								«v.name» = «SnakesHelper.defaultValue(v.type.type)»
							«ENDFOR»
						'''*/
						var actTxt = ''''''
						
						isActionsPresent = false
						if(outvar.act !== null) 
						{
							isActionsPresent = true // flag true: actions are present!
							for(a : outvar.act.actions) 
							{ 
								System.out.println("	> act: " + SnakesHelper.action(a, func,""))
								actTxt +=
								'''
								    «SnakesHelper.action(a, func, "")»
								'''
							}
						}
						for(v : outvar.fnOut) 
						{
							// logic for parsing output variables to Petri net places, arcs and their expressions
							var place = new String
							if(isActionsPresent)
								place = parseOutVariablesWithActions(block, map_output_input, 
										v, tr, pnet, f.name+"_"+update.name, input_var_list)
							else
								place = parseOutputVariables(block, map_output_input, v, tr, pnet)
							
							if(outvar.assert) pnet.add_to_map_transition_assertions(tr.name, place)
							
							var methodDef = 
							'''
								@staticmethod
								def execute_«f.name»_«update.name»_«place»(«FOR elm : input_var_list.keySet SEPARATOR ''','''»«elm»«ENDFOR»):
									«actTxt»
									«IF v.ref.type.type instanceof RecordTypeDecl»
										return json.dumps(«v.ref.name»)
									«ELSE»
										return «v.ref.name»
									«ENDIF»
							'''
							if(!actTxt.isEmpty) methodTxt += methodDef.trim + "\n\n"
						}
					}
				}
			}
		}
		return new Pair(pnet, methodTxt)
	}
	
	
	def getConstraintTxt(VarRef v) {
		var constraints = new ArrayList<Constraint>
		if(v.dataConstraints !== null) {
			for(c : v.dataConstraints.constr) {
				// val (String) => String fn = [s|"json.loads(v_"+s+", object_pairs_hook=Data().int_keys)"]
				val (String) => String fn = [s|s]
				constraints.add(new Constraint(c.name, SnakesHelper.expression(c.symbExpr, fn)))
			}
		}
		return constraints
	}
	
	def generateTestSCNTxt() {
		return
		'''
		import json
		import os
		
		
		class Tests:
		    list_of_test_scn = []
		
		    def __init__(self):
		        self.list_of_test_scn = []
		
		    def toJSON(self):
		        return json.dumps(self, default=lambda o: o.__dict__,
		                          sort_keys=True, indent=4)
		
		
		class TestSCN:
		    step_list = []
		    step_dependencies = []
		    map_transition_assert = {}
		    constraint_dict = {}
		
		    def __init__(self, _mapTrAssert, _constraint_dict):
		        self.step_list = []
		        self.step_dependencies = []
		        self.map_transition_assert = _mapTrAssert
		        self.constraint_dict = _constraint_dict
		
		    def generate_viz(self, idx):
		        txt = "@startuml\n"
		        if len(self.step_list) > 0:
		            # txt += "[*] --> %s : x\n" % self.step_list[0].step_name
		            for first, second in zip(self.step_list, self.step_list[1:]):
		                txt += "%s --> %s : follows\n" % (first.step_name, second.step_name)
		        if len(self.step_dependencies):
		            for elm in self.step_dependencies:
		                txt += "%s ..> %s : uses\n" % (elm.step_name, elm.depends_on)
		                txt += "note on link\n"
		                txt += "%s" % elm.payload
		                txt += "\nend note\n"
		        txt += "@enduml"
		
		        fname = "./generated_scenarios/scenario" + str(idx) + ".plantuml"
		        os.makedirs(os.path.dirname(fname), exist_ok=True)
		        with open(fname, 'w') as f:
		            f.write(txt)
		
		    def generateTSpec(self, idx):
		        txt = "abstract-test-definition\n\n"
		        txt += "Test-Scenario: S%s\n" % idx
		        for step in self.step_list:
		            if not step.is_assert:
		                name = step.step_name
		                idata = step.input_data
		                odata = step.output_data
		                txt += "step-name: %s\n" % name
		                for elm in self.step_dependencies:
		                    if elm.step_name == name:
		                        txt += "consumes-from-step: %s { " % elm.depends_on
		                        txt += elm.var_ref
		                        txt += " }\n"
		                txt += "input-binding:\n"
		                for k, v in idata.items():
		                    txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_",1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_",1)[0]]:
		                            if constr.var_ref == k and constr.dir == "IN":
		                                txt += "symbolic-input-constraint: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : %s\n" % (entry.name,entry.constr)
		                txt += "output-data:\n"
		                for k, v in odata.items():
		                    txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_",1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_",1)[0]]:
		                            if constr.var_ref == k and constr.dir == "OUT":
		                                txt += "symbolic-output-constraint: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : %s\n" % (entry.name,entry.constr)
		            else:
		                name = step.step_name
		                idata = step.input_data
		                odata = step.output_data
		                # txt += name
		                # txt += "input-binding:\n"
		                for k, v in idata.items():
		                    # txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_", 1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_", 1)[0]]:
		                            if constr.var_ref == k and constr.dir == "IN":
		                                txt += "\noutput-assertion: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : \"%s\"\n" % (entry.name, entry.constr.replace('"','\\"'))
		                for k, v in odata.items():
		                    # txt += "%s : %s\n" % (k, v)
		                    if name.rsplit("_", 1)[0] in self.constraint_dict:
		                        for constr in self.constraint_dict[name.rsplit("_", 1)[0]]:
		                            if constr.var_ref == k and constr.dir == "OUT":
		                                txt += "\nsymbolic-constraint: %s\n" % k
		                                for entry in constr.centry:
		                                    txt += "%s : \"%s\"\n" % (entry.name, entry.constr.replace('"','\\"'))
		                txt += "\n"
		        txt += '\ngenerate-file "./vfab2_scenario/"\n\n'
		        fname = "./generated_scenarios/_scenario" + str(idx) + ".tspec"
		        os.makedirs(os.path.dirname(fname), exist_ok=True)
		        with open(fname, 'w') as f:
		            f.write(txt)
		
		    def compute_dependencies(self):
		        for step in self.step_list:
		            idx = self.step_list.index(step)
		            preced = [item for i, item in enumerate(self.step_list) if idx < i < len(self.step_list)]
		            for elm in preced:
		                # print(" SRC-STEP: %s" % step.step_name)
		                # print(" DST-STEP: %s" % elm.step_name)
		                step_dep = step.compare(elm,self.map_transition_assert)
		                if step_dep:
		                    self.step_dependencies.append(step_dep)
		        # for elm in self.step_dependencies:
		        #    print("%s" % elm.step_name)
		        #    print("%s" % elm.depends_on)
		        #    print("%s" % elm.payload)
		
		
		class Step:
		    step_name = ""
		    input_data = {}
		    output_data = {}
		    is_assert = False
		
		    def __init__(self, _is_assert):
		        self.step_name = ""
		        self.input_data = {}
		        self.output_data = {}
		        self.is_assert = _is_assert
		
		    def compare(self, _step, mapTrAssert):
		        for ipdata in self.output_data:
		            for opdata in _step.input_data:
		                if self.step_name.rsplit('_', 1)[0] in mapTrAssert:
		                    if ipdata == opdata and ipdata in mapTrAssert[self.step_name.rsplit('_', 1)[0]]:
		                        # print("     Step %s depends on Step %s" % (_step.step_name, self.step_name))
		                        # print("     Matched %s - %s" % (ipdata,opdata))
		                        if _step.input_data[opdata] == self.output_data[ipdata]:
		                            # print("     Payload Matched!")
		                            step_dep = StepDependency()
		                            step_dep.step_name = _step.step_name
		                            step_dep.depends_on = self.step_name
		                            step_dep.var_ref = ipdata
		                            step_dep.payload = _step.input_data[opdata]
		                            return step_dep
		                        # else:
		                        # print("     Payload Not Matched!")
		                        # print(_step.input_data[opdata])
		                        # print(self.output_data[ipdata])
		                        # print("\n")
		        return None
		
		
		class StepDependency:
		    step_name = ""
		    depends_on = ""
		    var_ref = ""
		    payload = ""
		
		    def __init__(self):
		        self.step_name = ""
		        self.depends_on = ""
		        self.payload = ""
		
		
		class Constraint:
		    var_ref = ""
		    dir = ""
		    centry = []
		
		    def __init__(self, v, d, ce):
		        self.var_ref = v
		        self.dir = d
		        self.centry = ce
		
		
		class CEntry:
		    name = ""
		    constr = ""
		
		    def __init__(self, n, c):
		        self.name = n
		        self.constr = c
		

		'''
	}
	
	def generateVarListTxt(Map<String,TypeDecl> input_var_map) {
		return '''(«FOR elm : input_var_map.keySet SEPARATOR ''','''»«generateVarTxt(input_var_map,elm)»«ENDFOR»)'''
	}
	
	def generateVarTxt(Map<String,TypeDecl> input_var_map, String elm) {
		
		var txt = ''''''
		
		if(input_var_map.get(elm) instanceof RecordTypeDecl)
			txt += '''json.loads(v_«elm», object_pairs_hook=Data().int_keys)'''
		else 
			txt += '''v_«elm»'''
		
		return txt
	}
	
	def parseOutVariablesWithActions(Block block, HashMap<String, List<String>> map_output_input, 
									VarRef v, Transition tr, PetriNet pnet, String executeFnName, 
									Map<String,TypeDecl> input_var_list) 
	{
		System.out.println("	> out-var-name: " + block.name+"_"+v.ref.name)
		var vtype = v.ref.type.type.name
		var place = new String
		
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name))  /* 23.01.24 */ 
		{
			var outp = map_output_input.get(block.name+"_"+v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				place = p

				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, "Value(" + SnakesHelper.defaultValue(v.ref.type.type) + ")", PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", PType.OUT, getConstraintTxt(v))	
			}
		} 
		else 
		{ 
			/* 23.01.24 */
			// pnet.add_output_arc(tr.name, block.name+"_"+v.ref.name)
			pnet.add_output_arc(tr.name, v.ref.name)
			place = v.ref.name
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, "Expression('" + SnakesHelper.defaultValue(v.ref.type.type) + "')", PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, "Expression('Data().execute_" + executeFnName + "_" + place + generateVarListTxt(input_var_list) + "')", PType.OUT, getConstraintTxt(v))
		}
		
		return place
	}
	
	def parseOutputVariables(Block block, HashMap<String, List<String>> map_output_input, 
							VarRef v, Transition tr, PetriNet pnet) 
	{
		// find mapping to input place in map_output_input
		System.out.println("	> out-var-name: " + v.ref.name)
		// System.out.println("> MAP: " + map_output_input)
		var vtype = v.ref.type.type.name
		var place = new String
		// Note assumption is that all output variable mapped to input var by user
		// TODO implement validation checker!
		if(false) //map_output_input.keySet.contains(block.name+"_"+v.ref.name)) /* 23.01.24 */
		{
			var outp = map_output_input.get(v.ref.name)
			for(p : outp) 
			{
				pnet.add_output_arc(tr.name, p)
				//pnet.add_expression(tr.name, p, "Expression('1')", PType.OUT)
				if(v.ref.type.type instanceof SimpleTypeDecl)
					pnet.add_expression(tr.name, p, "Value(" + SnakesHelper.defaultValue(v.ref.type.type) + ")", PType.OUT, getConstraintTxt(v))
				else
					pnet.add_expression(tr.name, p, "Expression('Data().get_" + vtype + "()')", PType.OUT, getConstraintTxt(v))
				
				place = p
			}
		} else 
		{ 
			// can reach here if output is not mapped and then this is a dangling arc
			/* 23.01.24 */
			pnet.add_output_arc(tr.name, v.ref.name)
			
			//pnet.add_expression(tr.name, block.name+"_"+v.ref.name, "Expression('1')", PType.OUT)
			/* 23.01.24 */
			if(v.ref.type.type instanceof SimpleTypeDecl)
				pnet.add_expression(tr.name, v.ref.name, "Expression('" + SnakesHelper.defaultValue(v.ref.type.type) + "')", PType.OUT, getConstraintTxt(v))
			else
				pnet.add_expression(tr.name, v.ref.name, "Expression('Data().get_" + vtype + "()')", PType.OUT, getConstraintTxt(v))
			
			place = block.name+"_"+v.ref.name
		}
		
		return place
	}
}



/*
def toSnakesSimulation() {
		'''
		import PySimpleGUI as sg
		import PIL
		from PIL import Image
		from plantuml import PlantUML
		import os
		import base64
		from os.path import abspath
		from io import BytesIO
		
		class Simulation:
		    
		    def convert_to_bytes(self, source, size=(None, None), subsample=None, zoom=None, fill=False):
		        if isinstance(source, str):
		            image = Image.open(source)
		        elif isinstance(source, bytes):
		            image = Image.open(io.BytesIO(base64.b64decode(source)))
		        else:
		            image = PIL.Image.open(io.BytesIO(source))
		    
		        width, height = image.size
		    
		        scale = None
		        if size != (None, None):
		            new_width, new_height = size
		            scale = min(new_height/height, new_width/width)
		        elif subsample is not None:
		            scale = 1/subsample
		        elif zoom is not None:
		            scale = zoom
		    
		        resized_image = image.resize((int(width * scale), int(height * scale)), Image.ANTIALIAS) if scale is not None else image
		        if fill and scale is not None:
		            resized_image = make_square(resized_image)
		        # encode a PNG formatted version of image into BASE64
		        with BytesIO() as bio:
		            resized_image.save(bio, format="PNG")
		            contents = bio.getvalue()
		            encoded = base64.b64encode(contents)
		        return encoded
		    
		    
		    def simulateUI(self,n):
		        trList = []
		        column = [[sg.Image(key="-IMAGE-")]]
		        buttonLayout = [
		                    [sg.Button("Start"),
		                    sg.Button("ZoomIn"),
		                    sg.Button("ZoomOut"),
		                    sg.Button("Fire")],
		                    [sg.Text('Enabled-Transitions')],
		                    [sg.Combo(['empty'], enable_events=True, key='enabled',size=(60, 0))],
		                    [sg.Text('Modes')],
		                    [sg.Listbox(trList, size=(60, len(trList) + 10), horizontal_scroll = True, key='modes')],
		                    [sg.Text('Marking')],
		                    [sg.Multiline('', size=(60,10), horizontal_scroll = True, key = 'marking')]
		        ]
		        layout = [
		            [sg.Column(column, size=(700, 500), scrollable=True, key='Column', expand_x=True, expand_y=True),
		            [sg.Checkbox('block-view', default=True, key='isBlockView')],
		            sg.VSeperator(),
		            sg.Column(buttonLayout, key='bColumn', expand_x=True, expand_y=True)],
		        ]
		        window = sg.Window("Simulator", layout, resizable=True)
		        server = PlantUML(url='http://www.plantuml.com/plantuml/img/', basic_auth={}, form_auth={}, http_opts={}, request_opts={})
		        zoomin = 0
		        zoomout = 0
		        isBlockViewEnabled = False
		        while True:
		            event, values = window.read()
		            if event == sg.WINDOW_CLOSED:
		                break
		            if event == "Fire":
		                # print(values['modes'])
		                # print(values['enabled'])
		                n.transition(self.dictTrName[values['enabled']]).fire(values['modes'][0])
		                self.generatePlantUML(n,values['isBlockView'])
		                # print(self.getEnabledTransitionList(n))
		                window['enabled'].update(values=self.getEnabledTransitionList(n))
		                #window['modes'].Widget.configure(height=len(trList)+10)
		                window['modes'].update(values=[])
		                marking_txt = ''
		                for k in n.get_marking():
		                    marking_txt += ' Queue: {0}\n'.format(k)
		                    marking_txt += '     Contents: {0}\n'.format(n.get_marking()[k])
		                window['marking'].update(marking_txt)
		                # print(values)
		                filename = 'simulation.plantuml'
		                if os.path.exists(filename):
		                    server.processes_file(abspath(filename))                    
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png'))
		                    if zoomin > 1: 
		                        window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', zoom=zoomin))
		                    if zoomout > 1:
		                        window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', subsample=zoomout))
		                    window.refresh()
		                    window['Column'].contents_changed()
		            if event == "enabled":
		                # print(values['enabled'])
		                trList = []
		                for key,value in self.dictTrMode.items():
		                    if key == values['enabled']:
		                        trList.append(value)
		                window['modes'].Widget.configure(height=len(trList)+10)
		                window['modes'].update(values=trList)
		            if event == "ZoomOut":
		                zoomout = zoomout + 1
		                if zoomin > 1: 
		                    zoomin = zoomin - 1
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', zoom=zoomin))
		                else:
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', subsample=zoomout))
		                window.refresh()
		                window['Column'].contents_changed()
		            if event == "ZoomIn":
		                zoomin = zoomin + 1
		                if zoomout > 1:
		                    zoomout = zoomout - 1
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', subsample=zoomout))
		                else:
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png', zoom=zoomin))
		                window.refresh()
		                window['Column'].contents_changed()
		            if event == "Start":
		                self.generatePlantUML(n,values['isBlockView'])
		                # print(self.getEnabledTransitionList(n))
		                window['enabled'].update(values=self.getEnabledTransitionList(n))
		                marking_txt = ''
		                for k in n.get_marking():
		                    marking_txt += ' Queue: {0}\n'.format(k)
		                    marking_txt += '     Contents: {0}\n'.format(n.get_marking()[k])
		                window['marking'].update(marking_txt)
		                # print(values)
		                filename = 'simulation.plantuml'
		                if os.path.exists(filename):
		                    server.processes_file(abspath(filename))                    
		                    window["-IMAGE-"].update(self.convert_to_bytes('simulation.png'))
		                    window.refresh()
		                    window['Column'].contents_changed()
		    
		    
		    def getEnabledTransitionList(self,n):
		        trList = []
		        self.dictTrName = {}
		        self.dictTrMode = {}
		        for t in n.transition():
		            tmodes = t.modes()
		            idx = 0
		            for mode in tmodes:
		                #for key,value in mode.dict().items():
		                    #kv = ': {0}  -> {1}'.format(key,value)
		                trList.append(t.name + str(idx))
		                self.dictTrName.update({t.name + str(idx) : t.name})
		                self.dictTrMode.update({t.name + str(idx) : mode})
		                idx = idx + 1
		        return trList
		    
		    def simulate(self,n):
		        stop = False
		        while not stop:
		            dead_marking = False
		            enabled_transition_modes = {}
		            for t in n.transition():
		                tmodes = t.modes()
		                for mode in tmodes:
		                    print('\n')
		                    print(' Enabled-transition-name: ', t)
		                    print('    # with-input-modes: ')
		                    for key,value in mode.dict().items():
		                        print('      - var: ', key, '  ->  value:', value)
		                    # print('     > with mode: ', mode.dict())
		                    enabled_transition_modes[t] = mode
		    
		            if not enabled_transition_modes:
		                dead_marking = True
		    
		            choices = {}
		            idx = 0
		            for key, value in enabled_transition_modes.items():
		                choices[idx] = key, value
		                idx = idx + 1
		    
		            for k, v in choices.items():
		                print('\n')
		                print('Possible-choices: ')
		                print('    + choice: ', k, ' with-mode: ', v)
		    
		            if not dead_marking:
		                print('\n')
		                value = input(" Enter Choice: ")
		                print('\n')
		                print(' - Selected transition: ', choices.get(int(value)))
		                t, m = choices.get(int(value))
		                t.fire(m)
		                print('\n')
		                print(' [ Transition Fired! ]')
		                print('\n')
		                print(' Resulting Marking: ')
		                for k in n.get_marking():
		                    print('    + Place: ', k, ' has Token: ', n.get_marking()[k])
		                print('****************************************************************')
		                self.generatePlantUML(n,True)
		            else:
		                print('No Enabled Transitions!!')
		                stop = True
		    
		    
		    def getTransitionName(self,t,isDetailed):
		        if isDetailed:
		            return t.name
		        else:
		            return t.name.split('_')[0]
		    
		    
		    def generatePlantUML(self, n, isDetailed):
		        print('generating animation...')
		        fname = "simulation.plantuml"
		        txt = ''
		        txt += '@startuml'
		        txt += '\n'
		        placeList = []
		        transitionList = []
		        
		        for k in n.get_marking():
		            print('    + Place: ', k, ' has Token: ', n.get_marking()[k])
		            placeList.append(k)
		            # txt += 'interface {0} #yellow\n'.format(k)
		        for t in n.transition():
		            tmodes = t.modes()
		            for mode in tmodes:
		                print('\n')
		                print(' Enabled-transition-name: ', t)
		                # transitionList.append(t.name)
		                transitionList.append(self.getTransitionName(t,isDetailed))
		                # txt += 'component {0} #yellow\n'.format(self.getTransitionName(t,isDetailed))
		        
		        net_places = []
		        net_transitions = []
		        
		        for p in n.place():
		            net_places.append(p.name)
		        for t in n.transition():
		            net_transitions.append(self.getTransitionName(t,isDetailed))
		        
		        for p in sorted(net_places):
		            if p in placeList:
		                if not "local" in p:
		                    txt += 'interface {0} #yellow\n'.format(p)
		            else:
		                if not "local" in p:
		                    txt += 'interface {0} #white\n'.format(p)
		        for t in sorted(net_transitions):
		            if t in transitionList:
		                if isDetailed:
		                    txt += 'component {0} #yellow\n'.format(self.getTransitionName(n.transition(t),isDetailed))
		                else:
		                    txt += 'component {0} #yellow\n'.format(t)
		            else:
		                if isDetailed:
		                    txt += 'component {0} #white\n'.format(self.getTransitionName(n.transition(t),isDetailed))
		                else:
		                    txt += 'component {0} #white\n'.format(t)
		        
		        conn = set()
		        for t in n.transition():
		            for p in n.pre(t.name):
		                str = ''
		                if not "local" in p:
		                    str = '{0} --> [{1}]\n'.format(p,self.getTransitionName(t,isDetailed))
		                if not str in conn:
		                    if not "local" in p:
		                        txt += '{0} --> [{1}]\n'.format(p,self.getTransitionName(t,isDetailed))
		                    conn.add(str)
		            for p in n.post(t.name):
		                str = ''
		                if not "local" in p:
		                    str = '[{1}] --> {0}\n'.format(p,self.getTransitionName(t,isDetailed))
		                if not str in conn:
		                    if not "local" in p:
		                        txt += '[{1}] --> {0}\n'.format(p,self.getTransitionName(t,isDetailed))
		                    conn.add(str)
		        
		        txt += '@enduml'
		        with open(fname, 'w') as f:
		            f.write(txt)

		'''
	} 
*/