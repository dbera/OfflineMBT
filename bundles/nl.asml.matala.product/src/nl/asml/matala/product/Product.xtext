grammar nl.asml.matala.product.Product with nl.esi.comma.actions.Actions // with org.eclipse.xtext.common.Terminals

generate product "http://www.asml.nl/matala/product/Product"

import "http://www.esi.nl/comma/signature/InterfaceSignature" as sig 
import "http://www.esi.nl/comma/types/Types" as types
import "http://www.esi.nl/comma/expressions/Expression" as expr
import "http://www.esi.nl/comma/assertthat/AssertThat" as assertthat

@Override
ModelContainer returns types::ModelContainer:
	super::ModelContainer | Product
;

Product:
	imports += Import*
	(namespace += NameSpace)*
    types += TypeDecl*
	( systemDecl = SystemDecl	
	| specification = Specification)
;

@Override
NamedElement returns types::NamedElement:
	name=QualifiedName | SystemDecl
;

SystemDecl:
	'system' 'declarations' name = ID '{'
		block += Block*
		// if it works, make it recursive
	'}'
;

Specification:
	'specification' name = ID '{'
		blocks += Blocks+
		('SUT-blocks' envBlock += [Block|QualifiedName]*)?
		'depth-limits' limit = INT
	'}'
;

Blocks:
	( block = Block
	| refBlock = RefBlock
	)
;


RefBlock:
	'reference' 'system' system = [Block|QualifiedName]
;

Block:
	'system' name = ID '{'
		( // Unordered group for following items
			('inputs' invars+=Variable* )? &
			('outputs' outvars+=Variable* )? &
			('local' localvars+=Variable* )? &
			('init' initActions+=(AssignmentAction | RecordFieldAssignmentAction)*)? &
			'desc' type = STRING
		)
		functions += Function*
	'}'
;

Function:
	'action' name = ID
	updates += Update*
;

Update:
	'case' name = ID 
	('step-type' stepType = STRING 'action-type' actionType = ActionType)?
	('with-inputs' fnInp += VarRef (',' fnInp+=VarRef)*)?
	('with-guard' guard=Expression?)?
	updateOutputVar += UpdateOutVar*
;

enum ActionType:
	INTERNAL | COMPOSE | RUN
;

UpdateOutVar:
	'produces-outputs'  fnOut += VarRef (',' fnOut+=VarRef)* (assert?='assert'?) (suppress?='suppress'?)
	('updates' hiddenVars += Variable* ':' act = ActionList)?
;

VarRef:
	opt?='opt'? init?='init'? 
	ref = [expr::Variable|ID] 
	(dataConstraints = DataConstraints)?
	(dataReferences = DataReferences)? 
	(dataAssertions = DataAssertions)? 
;

DataConstraints: {DataConstraints}
	'constraints' '{' 
		constr += SymbConstraint*
	 '}'
;

DataReferences: {DataReferences}
	'references' '{' 
		constr += RefConstraint*
	 '}'
;

RefConstraint:
	name=ID ':' act = ActionList
;

SymbConstraint:
	name=ID ':' symbExpr = Expression
;

//TODO Refactor as Grammar Mixins

///// Json Grammar obtained from https://gist.github.com/nightscape/629651

JsonObject:
    '{' (members+=JsonMember) (',' members+=JsonMember)* '}'
;

JsonMember:
    key=STRING ':' value=JsonValue
;

JsonArray:
    '[' (values+=JsonValue) (',' values+=JsonValue)* ']'

;

JsonNumeric: 
    {JsonNumeric} (Expression::FLOAT | Expression::Long)
;

JsonValue:
    {JsonValue} STRING | {JsonValue} Expression::BOOL_LITERAL | JsonNumeric | JsonObject | JsonArray 
;

StringOrArray:
    item = STRING | '[' (values+=STRING) (',' values+=STRING)* ']'
;

NumericOrArray:
    item = JsonNumeric | '[' (values+=JsonNumeric) (',' values+=JsonNumeric)* ']'
;

///// assert-that DSL (et al.)

DataAssertions: {DataAssertions}
    'assertions' '{' 
        constr += AssertThatBlock*
     '}'
;

AssertThatBlock:
    'assert-that' output=ExpressionBracket
        (
              val=AssertThatValue 
            | xpath=AssertThatXPath 
            | xmlFiles=AssertThatXMLFile
        )
;

enum MARGIN_TYPE:
    ABSOLUTE='absolute'
    | RELATIVE='relative'
    | NONE='none';

MargingItem:
    type=MARGIN_TYPE '(' (marginVal=JsonNumeric)? ')';

// Assertion of Value outputs
AssertThatValue:
    'is' '{' type=AssertionValueValidationTypes '}'
;

AssertionValueValidationTypes:
    AssertEq | AssertClose | AssertMatch | AssertSize;

AssertEq:
    'equal-to' outRef=JsonValue ('within-margin' outMrg=MargingItem)? (asRegex ?= 'as-regex')?
;

AssertClose:
    'close-to' outClo=NumericOrArray ('within-margin' outMrg=MargingItem)?
;

AssertMatch:
    'match-regex' outRegex=StringOrArray
;

AssertSize:
    'of-size' itLen=INT
;

// Assertion of XPath outputs
AssertThatXPath:
    'has' '{'
    ( namespace = AssertNamespace )? 
    ( globalMargin = AssertGlobalMargin )? 
    ( globalRegex = AssertGlobalRegex )?
    'value' '{' assertRef += AssertXPathValidations+ '}'
    '}'
;

AssertNamespace: {AssertNamespace}
      'using-namespace-context' namespaceMap = JsonObject
;

AssertGlobalMargin: {AssertGlobalMargin}
    'using-global-margin' globalMrg = MargingItem
;

AssertGlobalRegex: {AssertGlobalRegex}
     globalRegex ?= 'using-all-strings-as-regex'
;

XPathItem: {XPathItem}
    'xpath' '(' xpathExpr = STRING  ( ',' 'log-id' ':=' loggingId = STRING )? ')'
;


AssertXPathValidations: {AssertXPathValidations}
    ( xpathItem = XPathItem ) validation = AssertionXPathValidationTypes
;

AssertionXPathValidationTypes:
    AssertionValueValidationTypes
;

// Assertion of XMLFile outputs
AssertThatXMLFile:
    'and' reference = ExpressionBracket
    'have' '{'
    ( namespace = AssertNamespace )? 
    ( globalMargin = AssertGlobalMargin )? 
    'value' '{' assertRef += AssertXmlValidations+ '}'
    '}'
;

AssertXmlValidations: {AssertXmlValidations}
    ( xpathItem = XPathItem ) validation = AssertionXmlValidationTypes
;

AssertionXmlValidationTypes: 
    AssertIdentical | AssertSimilar
;

AssertIdentical: {AssertIdentical}
    areIdentical ?= 'are-identical' 
;
AssertSimilar: {AssertSimilar}
    areSimilar ?= 'are-similar' ('within-margin' localMargin=MargingItem)?
;
