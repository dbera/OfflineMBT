/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.types.formatting2

import com.google.inject.Inject
import java.util.List
import nl.esi.comma.types.services.TypesGrammarAccess
import nl.esi.comma.types.types.Dimension
import nl.esi.comma.types.types.EnumElement
import nl.esi.comma.types.types.EnumTypeDecl
import nl.esi.comma.types.types.RecordField
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.TypeDecl
import nl.esi.comma.types.types.TypesModel
import nl.esi.comma.types.types.VectorTypeConstructor
import nl.esi.comma.types.types.VectorTypeDecl
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.AbstractRule
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter
import org.eclipse.xtext.formatting2.regionaccess.IComment
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1

class TypesFormatter extends AbstractFormatter2 {

	@Inject extension TypesGrammarAccess	
	
	//--------------------------------- Formatting Procedures
	
	static public final Procedure1<IHiddenRegionFormatter> oneSpaceWrap = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.oneSpace
			p.autowrap
		}
     };
     
     static public final Procedure1<IHiddenRegionFormatter> oneSpace = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.oneSpace			
		}
     };
     
     static public final Procedure1<IHiddenRegionFormatter> noSpace = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.noSpace			
		}
     };
     
     static public final Procedure1<IHiddenRegionFormatter> newLine = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.newLine			
		}
     };
     
     static public final Procedure1<IHiddenRegionFormatter> emptyLine = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.newLines = 2			
		}
     };
     
     static public final Procedure1<IHiddenRegionFormatter> indent = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.indent			
		}
     };
     
     static public final Procedure1<IHiddenRegionFormatter> doubleIndent = new Procedure1<IHiddenRegionFormatter>() {		
		override apply(IHiddenRegionFormatter p) {
			p.indent
			p.indent		
		}
     };
     
     //------------------------------------ Types
     
	def dispatch void format(TypesModel container, extension IFormattableDocument document) {
		for (typeDecl : container.types) {
			typeDecl.format;
		}
	}
	
	def dispatch void format(TypeDecl typeDecl, extension IFormattableDocument document) {
		val rFinder = typeDecl.regionFor		
		rFinder.keyword(simpleTypeDeclAccess.typeKeyword_0).prepend(newLine).append(oneSpace)		
	}

	def dispatch void format(EnumTypeDecl enumTypeDecl, extension IFormattableDocument document) {		
		val rFinder = enumTypeDecl.regionFor
		
		val kwEnum = rFinder.keyword(enumTypeDeclAccess.enumKeyword_0)
		kwEnum.prepend(newLine)
		kwEnum.append(oneSpace)
		
		val kwRecord = rFinder.keyword(recordTypeDeclAccess.recordKeyword_0) 
		kwRecord.prepend[]
		
		val brackets = rFinder.keywordPairs(enumTypeDeclAccess.leftCurlyBracketKeyword_2, enumTypeDeclAccess.rightCurlyBracketKeyword_4)?.get(0)
		if(brackets !== null) {
			brackets.interior(indent)			
			brackets.key.prepend(oneSpace)
			brackets.key.append(newLine)		
			brackets.value.prepend(newLine)
		}		
		
		enumTypeDecl.literals.forEach[format]
	}
	
	def dispatch void format(EnumElement enumElement, extension IFormattableDocument document) {
		enumElement.prepend(newLine)
		val regionFor = enumElement.regionFor
		regionFor.keyword(enumElementAccess.equalsSignKeyword_1_0)?.surround(oneSpace)
	}
	
	
	def dispatch void format(RecordTypeDecl recordTypeDecl, extension IFormattableDocument document) {
		val rFinder = recordTypeDecl.regionFor
		
		val kwRecord = rFinder.keyword(recordTypeDeclAccess.recordKeyword_0) 
		kwRecord.prepend(newLine)
		kwRecord.append(oneSpace)
		
		val allBrackets = rFinder.keywordPairs(recordTypeDeclAccess.leftCurlyBracketKeyword_3,
			recordTypeDeclAccess.rightCurlyBracketKeyword_6)		
		if (!allBrackets.empty) {
			val brackets = allBrackets.get(0)
			brackets.interior(indent)
			brackets.key.prepend(oneSpace)
			brackets.key.append(newLine)
			brackets.value.prepend(newLine)
		}		
		
		for(ISemanticRegion region : rFinder.keywords(recordTypeDeclAccess.commaKeyword_5_0)) {
			region.prepend(noSpace)
		}
		
		for (RecordField recField : recordTypeDecl.fields) {
			recField.format;
		}
	}
	
	def dispatch void format(RecordField recField, extension IFormattableDocument document) {
		recField.prepend(newLine)
	}
	
	/**
	 * The format result of the VectorTypeDecl is everything appears in one line.
	 * For instance 'vector MyV = int[][5]
	 */
	def dispatch void format(VectorTypeDecl vectorTypeDecl, extension IFormattableDocument document) {
		var regionFor = vectorTypeDecl.regionFor
		
		regionFor.keyword(vectorTypeDeclAccess.vectorKeyword_0).append(oneSpace)
		regionFor.assignment(vectorTypeDeclAccess.nameAssignment_1).append(oneSpace)	
		regionFor.keyword(vectorTypeDeclAccess.equalsSignKeyword_2).append(oneSpace)
		
		vectorTypeDecl.constructor.format
		vectorTypeDecl.append(newLine)
	}

	/**
	 * The format result of the VectorTypeConstructor is everything appears in one line
	 * and no spaces between the tokens.
	 * For instance  'int[45][3]' is valid formatted outpout. 
	 */	
	def dispatch void format(VectorTypeConstructor vectorTypeConstructor, extension IFormattableDocument document) {
		vectorTypeConstructor.append(oneSpace)		
		vectorTypeConstructor.type.append(noSpace)
		vectorTypeConstructor.dimensions.forEach[format]
	}
	
	def dispatch void format(Dimension dimension, extension IFormattableDocument document) {
		val regionFor = dimension.regionFor
		
		regionFor.keyword(dimensionAccess.leftSquareBracketKeyword_1).prepend(noSpace)
		regionFor.assignment(dimensionAccess.sizeAssignment_2).prepend(noSpace)
		regionFor.keyword(dimensionAccess.rightSquareBracketKeyword_3).prepend(noSpace)
	}
	
	
	
	//Allow extra line before multinecomments
	override createCommentReplacer(IComment comment) {
		
		val grammarElement = comment.getGrammarElement();
		if (grammarElement instanceof AbstractRule) {
			val ruleName = grammarElement.name
			if (ruleName.startsWith("ML"))
				return new MultiLineFormatter(comment, '*');				
			
		}
		super.createCommentReplacer(comment)
	}

		
	def void formatSimpleBrackets(ISemanticRegionsFinder rFinder, Keyword open, Keyword close, extension IFormattableDocument document) {
		val pairs = rFinder.keywordPairs(open, close)
		if(!pairs.empty) {
			val brackets = pairs.get(0)
			brackets.key.prepend(oneSpace) 
			brackets.value.prepend(newLine)
			brackets.interior(indent)
		} 
	}
	
	def void formatSimpleCommas(List<ISemanticRegion> commas, extension IFormattableDocument document) {
		for(ISemanticRegion comma : commas) {
			comma.prepend(noSpace).append(oneSpaceWrap)		
		}
	}
	
	def void formatTopElement(EObject obj, extension IFormattableDocument document) {
		if (obj.regionForEObject.previousSemanticRegion === null) {
			if (!this.textRegionExtensions.regionForEObject(obj).previousHiddenRegion.containsComment) {
				obj.prepend(noSpace)
			}
		} else {
			obj.append(emptyLine)
		}
	}
	
	def void indentList(EList<? extends EObject> objects, extension IFormattableDocument document) {		
		if (objects.size() != 0) {
			val first = objects.get(0);
			val last = objects.get(objects.size() - 1);
			document.set(first.previousHiddenRegion, last.nextHiddenRegion, (indent))
		}	
	}
}
