/*
 * generated by Xtext 2.10.0
 */
package nl.esi.comma.types.scoping

import nl.esi.comma.types.types.TypesPackage
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.impl.FilteringScope

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class TypesScopeProvider extends AbstractTypesScopeProvider {
    static val SIMPLE_TYPES_BASE = #{'int', 'real', 'string'}

    override getScope(EObject context, EReference reference) {
        //println(context.eClass.name + ' -> ' + reference.toPackageDeclaration)

        val scope = super.getScope(context, reference)

        return switch (reference) {
            case TypesPackage.Literals.SIMPLE_TYPE_DECL__BASE: {
                new FilteringScope(scope)[SIMPLE_TYPES_BASE.contains(name.toString)]
            }
            default: scope
        }
    }

    protected def toPackageDeclaration(EReference reference) {
        val eclassName = reference.EContainingClass.name.replaceAll('([^A-Z])([A-Z])', '$1_$2')
        val referenceName = reference.name.replaceAll('([^A-Z])([A-Z])', '$1_$2')
        return '''«reference.EContainingClass.EPackage.name.toFirstUpper»Package.Literals.«eclassName.toUpperCase»__«referenceName.toUpperCase»'''
    }
}
