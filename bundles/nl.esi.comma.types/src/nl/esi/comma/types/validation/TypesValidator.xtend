/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.10.0
 */
package nl.esi.comma.types.validation

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import java.util.LinkedHashSet
import nl.esi.comma.types.scoping.TypesImportUriGlobalScopeProvider
import nl.esi.comma.types.types.EnumTypeDecl
import nl.esi.comma.types.types.Import
import nl.esi.comma.types.types.MapTypeConstructor
import nl.esi.comma.types.types.ModelContainer
import nl.esi.comma.types.types.NamedElement
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.SimpleTypeDecl
import nl.esi.comma.types.types.Type
import nl.esi.comma.types.types.TypesModel
import nl.esi.comma.types.types.TypesPackage
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.validation.Check

import static extension nl.esi.comma.types.utilities.TypeUtilities.*
import org.eclipse.xtext.validation.EValidatorRegistrar
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.ecore.EValidator

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TypesValidator extends AbstractTypesValidator {
	
	@Inject 
	ResourceDescriptionsProvider rdp
	
	//Generic method to detect name duplications in a collection of a named elements
    protected def checkForNameDuplications(Iterable<? extends NamedElement> elements, String desc, String code, String... issueData) {
        checkForNameDuplicationsVerbose(elements, desc, null, code, issueData)
    }

	protected def checkForNameDuplicationsVerbose(Iterable<? extends NamedElement> elements, String desc, String namePrefix, String code, String... issueData) {
		val multiMap = HashMultimap.create()
		for (e : elements)
			multiMap.put(e.name, e)
  		for (entry : multiMap.asMap.entrySet) {
  			val duplicates = entry.value
  			if (duplicates.size > 1) {
  				for (d : duplicates) {
  				    var error = "Duplicate " + desc + " name"
  				    if (namePrefix !== null) {
  				        error += ": " + namePrefix + d.name
  				    }
  					error(error, d, TypesPackage.Literals.NAMED_ELEMENT__NAME, code, issueData)
				}
  			}
  		}
  	}				
  	
  	//Used because the resource with the predefined types is somehow not loaded by the resource description provider
  	protected def placePredefinedTypes(HashMultimap<String, Object> multiMap){
  		multiMap.put("int", null)
  		multiMap.put("bool", null)
  		multiMap.put("real", null)
  		multiMap.put("string", null)
  		multiMap.put("void", null)
  		multiMap.put("any", null)
  		multiMap.put("bulkdata", null)
  		multiMap.put("id", null)
  	}
  	
  	/*
  	 * Constraints:
  	 * - imported type definitions have unique names
  	 */
  	def HashMultimap<String, Object> checkDuplicationsInImportedTypes(ModelContainer decl){
  		var LinkedHashSet<URI> knownURIs = new LinkedHashSet<URI>(5);
  		knownURIs.add(decl.eResource.URI)
		val importedURIs = TypesImportUriGlobalScopeProvider.traverseImportedURIs(decl.eResource, knownURIs)
		val HashMultimap<String, Object> multiMap = HashMultimap.create()
		val index = rdp.getResourceDescriptions(decl.eResource)    
		
		for(uri : importedURIs){ 
			for(ed : index.getResourceDescription(uri).getExportedObjectsByType(TypesPackage.Literals.TYPE_DECL)){
				multiMap.put(ed.name.toString, ed)
			}
		}
		placePredefinedTypes(multiMap)
		
		//Check the union of imports for duplications
		for (entry : multiMap.asMap.entrySet) {
  			val duplicates = entry.value    
  			if (duplicates.size > 1) {
  				error("Imports contain duplicate type with name " + entry.key, decl, TypesPackage.Literals.MODEL_CONTAINER__IMPORTS, 0)
  			}
  		}
  		multiMap
  	}
  	
  	/*
  	 * Constraints:
  	 * - local type definitions do not duplicate imported type definitions
  	 */		
  	@Check
  	def checkLocalTypesForDuplications(TypesModel decl){
  		val multiMap = checkDuplicationsInImportedTypes(decl)
  		//Check the local types
  		for(tDecl : decl.types){
  			if(multiMap.containsKey(tDecl.name))
  				error("Type with the same name is already imported", tDecl, TypesPackage.Literals.NAMED_ELEMENT__NAME)
  		}
  	}					
  	
    /*
     * Constraints:
     * - At least one enum literal
     */             
    @Check
    def checkMinimumEnumLiterals(EnumTypeDecl type) {
        if (type.literals.isEmpty) {
            error('''Expected at least 1 literal for enum «type.name»''', TypesPackage.Literals.ENUM_TYPE_DECL__LITERALS)
        }
    }

    /*
     * Constraints:
     * - At least one record field
     */             
    @Check
    def checkMinimumRecordFields(RecordTypeDecl type) {
        if (type.fields.isEmpty) {
            error('''Expected at least 1 field for record «type.name»''', TypesPackage.Literals.RECORD_TYPE_DECL__FIELDS)
        }
    }

  	/*
  	 * Constraints:
  	 * - record fields have unique names
  	 */				
  	@Check
	def checkDuplicatedRecordFields(RecordTypeDecl type) {
		checkForNameDuplicationsVerbose(type.fields, "record field", type.name + ".", null)
	}
	
	/*
	 * Constraints:
	 * - record extension hierarchy has no cycles
	 */
	@Check
	def checkCircularHierarchy(RecordTypeDecl type){
		if(type.getAllParents.contains(type)){
			error("Cycle in the extension hierarchy", TypesPackage.Literals.RECORD_TYPE_DECL__PARENT)
		}
	}
	
	/*
	 * Constraints:
	 * - no overriding of inherited record fields
	 */
	@Check
	def checkOverridenRecordFields(RecordTypeDecl type){
		if(type.parent !== null){
			val inheritedFields = type.parent.getAllFields
			for(f : type.fields){
				if(!inheritedFields.filter(ff | ff.name.equals(f.name)).empty){
					error("Local field overrides inherited field", f, TypesPackage.Literals.NAMED_ELEMENT__NAME)
				}
			}
		}
	}
	
	/*
	 * Constraints:
	 * - enum literals are unique
	 */
	@Check
	def checkDuplicatedEnumElements(EnumTypeDecl type) {
		checkForNameDuplicationsVerbose(type.literals, "enumeration literal", type.name + ".", null)
	}
	
	/*
	 * Constraints:
	 * - enum literal values (when given) are increasing
	 */
	@Check
	def checkEnumLiteralValues(EnumTypeDecl type){
		var currentValue = -1
		for(l : type.literals){
			if(l.value === null){
				currentValue++
			}
			else{
				if(l.value.value <= currentValue){
					error("Enum value has to be greater than the previous value", l, TypesPackage.Literals.NAMED_ELEMENT__NAME);
					return
				}
				else {
					currentValue = l.value.value
				}
			}
		}
	}
	
	/*
	 * Constraints:
	 * - type definitions in a given types model have unique names 
	 */
	@Check
	def checkDuplicatedTypeDeclarations(TypesModel typedecl) {
		checkForNameDuplicationsVerbose(typedecl.types, "type declaration", "", null)
	}
	
	/*
	 * Constrains:
	 * - imports are valid URIs
	 * - imported resources are type models
	 */
	@Check
	def checkImportForValidity(Import imp){
		
		if(! EcoreUtil2.isValidUri(imp, URI.createURI(imp.importURI)))
			error("Invalid resource", imp, TypesPackage.Literals.IMPORT__IMPORT_URI)
		else{
			val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
			if(! (r.allContents.head.eClass == TypesPackage.eINSTANCE.typesModel))
				error("Only imports for type definitions are allowed", imp, TypesPackage.Literals.IMPORT__IMPORT_URI)
		}
	}
	
	/*
	 * Constraints:
	 * - any, void and id cannot be directly used in type models
	 */
	 //TODO consider removing any type from the definitions types.types
	@Check
	def checkForAnyType(Type t){
		if(t.type instanceof SimpleTypeDecl && (t.type.name.equals("any"))){
			error("Usage of type any is not allowed", TypesPackage.Literals.TYPE__TYPE)
		}
	}
	
//	@Check
//	def checkForVoidType(Type t){
//		if(t.type instanceof SimpleTypeDecl && (t.type.name.equals("void"))){
//			error("Usage of type void is not allowed", TypesPackage.Literals.TYPE__TYPE)
//		}
//	}
	
	@Check
	def checkForIdType(Type t){
		if(t.type instanceof SimpleTypeDecl && (t.type.name.equals("id"))){
			error("Usage of type id is not allowed", TypesPackage.Literals.TYPE__TYPE)
		}
	}
	
	/*
	 * Constraints:
	 * - key type of maps is an enum or a simple type
	 * Rationale: semantics of equality of structured types needs further investigation
	 */
	 @Check
	 def checkKeyType(MapTypeConstructor mtc){
	 	if(!(mtc.keyType instanceof EnumTypeDecl) && !(mtc.keyType instanceof SimpleTypeDecl)){
	 		error("The type of map keys has to be enumeration or simple type", TypesPackage.Literals.TYPE__TYPE)
	 	}
	 }
	
	/*
	 * Constraints:
	 * - The following is implemented in the scope provider:
	 *   only int, string and real can be used as base types of user-defined simple types.
	 *   Note: it can be implemented alternatively: allow any simple type to be used as a base and
	 *   make then a validation check in this class.
	 * - TODO non-implemented constraints:
	 *   + the graph of transitive imports does not contain cycles. Note: the importing algorithm detects cycles
	 *     and does not traverse them more than once. This constraint is needed to avoid potential cyclic imports/
	 *     includes when code (e.g. C++) is generated from type models
	 *   + the chain of dependencies induced by record fields contains no cycles.
	 *     Clarification: record R1 with field A of type R2, R2 with field b of type R1 is not allowed.
	 *     Fields of vector types with base another record type should also be considered.
	 *     In ComMA, records are treated as values. The structure mentioned above can never be created.
	 */
	 
	 /*
	  * This methods implements the mechanism for registering third-party extensions to the 
	  * validators of the ComMA languages.
	  * All languages that directly or indirectly extend Types language inherit it.
	  */
	  
	 @Inject
	 override register(EValidatorRegistrar registrar) {
	 	super.register(registrar)
    	val VALIDATOR_ID = "nl.esi.comma.types.commaValidator"
    	val reg = Platform.getExtensionRegistry()
    	if(reg !== null){
    		val extensions = reg.getConfigurationElementsFor(VALIDATOR_ID)
        	for(e : extensions){
        		val o = e.createExecutableExtension("class")
        		if(this.class.simpleName.startsWith(e.getAttribute("language"))){
        			for (ePackage : this.EPackages) {
    					registrar.register(ePackage, o as EValidator)
  					}
        		}
        	}	
    	}
    }
}
