/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.ide.contentassist

import com.google.inject.Inject
import nl.esi.comma.expressions.expression.ExpressionMap
import nl.esi.comma.expressions.expression.ExpressionVector
import nl.esi.comma.expressions.expression.Field
import nl.esi.comma.expressions.expression.MapTypeConstructor
import nl.esi.comma.expressions.expression.Pair
import nl.esi.comma.expressions.expression.TypeAnnotation
import nl.esi.comma.expressions.services.ExpressionGrammarAccess
import nl.esi.comma.expressions.validation.ExpressionFunction
import nl.esi.comma.types.types.EnumTypeDecl
import nl.esi.comma.types.types.Type
import nl.esi.comma.types.types.TypeReference
import nl.esi.comma.types.utilities.TypeUtilities
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ParserRule
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry
import org.eclipse.xtext.ide.editor.contentassist.IIdeContentProposalAcceptor
import org.eclipse.xtext.util.TextRegion

import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType

/**
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
class ExpressionIdeProposalProvider extends AbstractExpressionIdeProposalProvider {
    @Inject
    ExpressionGrammarAccess grammarAccess

    override protected _createProposals(Assignment assignment, ContentAssistContext context,
        IIdeContentProposalAcceptor acceptor) {
        super._createProposals(assignment, context, acceptor)

        val feature = assignment.feature
        switch (object: context.currentModel) {
            Field case feature == 'exp': {
                createDefaultValue(object.recordField.type, object.recordField.name, context, acceptor)
            }
            ExpressionVector case feature == 'elements': {
                createDefaultValueEntry(object.typeAnnotation, null, context, acceptor)
            }
            ExpressionMap case feature == 'key': {
                createDefaultValueEntry(object.typeAnnotation, null, context, acceptor)
            }
            Pair case feature == 'value': {
                val container = object.eContainer
                if (container instanceof ExpressionMap) {
                    val mapType = container.typeAnnotation.type as MapTypeConstructor
                    createDefaultValue(mapType.valueType, null, context, acceptor)
                }
            }
            case feature == 'functionName': {
                for (func : ExpressionFunction.values) {
                    val proposal = proposalCreator.createProposal(func.name + '()', context, [ entry |
                        entry.kind = ContentAssistEntry.KIND_FUNCTION
                        entry.label = func.name
                        entry.description = 'Function'
                        entry.documentation = func.documentation
                        entry.editPositions +=
                            new TextRegion(context.offset + func.name.length + 1, entry.proposal.length - 2)
                    ])
                    if (proposal !== null) {
                        acceptor.accept(proposal, proposalPriorities.getDefaultPriority(proposal))
                    }
                }
            }
        }
    }

    override protected _createProposals(RuleCall ruleCall, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        switch (ruleCall.getContainerOfType(ParserRule)) {
            case grammarAccess.expressionConstantBoolRule,
            case grammarAccess.expressionConstantIntRule,
            case grammarAccess.expressionConstantRealRule,
            case grammarAccess.expressionConstantStringRule,
            case grammarAccess.expressionFunctionCallRule: {
                return
            }
        }
        super._createProposals(ruleCall, context, acceptor)
    }

    protected def createDefaultValueEntry(TypeAnnotation typeAnn, String targetName, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        val typeObj = TypeUtilities.getTypeObject(typeAnn.type)
        if (TypeUtilities::isVectorType(typeObj) && TypeUtilities::getElementType(typeObj) instanceof EnumTypeDecl) {
            createEnumValues(TypeUtilities::getElementType(typeObj) as EnumTypeDecl, context, acceptor)
            return;
        }

        try {
            val defaultValue = ProposalHelper.defaultValue(typeAnn, targetName)
            val proposal = proposalCreator.createProposal(defaultValue, context, [ entry |
                entry.kind = ContentAssistEntry.KIND_SNIPPET
                entry.label = ProposalHelper.getTypeName(typeAnn)
                entry.description = 'Default Value'
                entry.documentation = defaultValue
            ])
            if (proposal !== null) {
                acceptor.accept(proposal, TEMPLATE_DEFAULT_PRIORITY);
            }
        } catch (UnsupportedTypeException e) {
            // Ignore
        }
    }

    protected def createDefaultValue(Type type, String targetName, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        if (type instanceof TypeReference && type.type instanceof EnumTypeDecl) {
            createEnumValues(type.type as EnumTypeDecl, context, acceptor)
            return;
        }

        try {
            val defaultValue = ProposalHelper.defaultValue(type, targetName)
            val proposal = proposalCreator.createProposal(defaultValue, context, [ entry |
                entry.kind = ContentAssistEntry.KIND_SNIPPET
                entry.label = ProposalHelper.getTypeName(type)
                entry.description = 'Default Value'
                entry.documentation = defaultValue
            ])
            if (proposal !== null) {
                acceptor.accept(proposal, TEMPLATE_DEFAULT_PRIORITY);
            }
        } catch (UnsupportedTypeException e) {
            // Ignore
        }
    }

    protected def createEnumValues(EnumTypeDecl type, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        for (literal : type.literals) {
            val value = '''«type.name»::«literal.name»'''
            val proposal = proposalCreator.createProposal(value, context, [ entry |
                entry.kind = ContentAssistEntry.KIND_FIELD
                entry.label = value
            ])
            if (proposal !== null) {
                acceptor.accept(proposal, TEMPLATE_DEFAULT_PRIORITY);
            }
        }
    }

//    override completeExpressionTypeAnnotated_Elements(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//       super.completeExpressionTypeAnnotated_Elements(model, assignment, context, acceptor)
//       if(model instanceof ExpressionVector){
//           if(model.typeAnnotation.type.type instanceof RecordTypeDecl){
//               acceptRecord(model, assignment, context, acceptor)
//           }
//       }
//    }
//    
//    def acceptRecord(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//        if (object instanceof ExpressionVector) {
//            var type = object.typeAnnotation.type.type
//            if (type instanceof RecordTypeDecl) {
//                var fields = type.fields
//                val prop = '''
//                        «type.name» {«FOR field : fields SEPARATOR ","»«field.name» = «ProposalHelper.defaultValue(field.type)»«ENDFOR»}
//                '''
//                acceptor.accept(createTemplate("Record "+type.name, prop, "", 0, context, 1000, -1, -1))
//            }
//        }
//    }
}
