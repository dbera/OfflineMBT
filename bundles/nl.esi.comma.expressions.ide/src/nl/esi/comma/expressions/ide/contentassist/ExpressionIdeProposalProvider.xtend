/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.expressions.ide.contentassist

import com.google.inject.Inject
import nl.esi.comma.expressions.expression.ExpressionMap
import nl.esi.comma.expressions.expression.ExpressionVector
import nl.esi.comma.expressions.expression.Field
import nl.esi.comma.expressions.expression.MapTypeConstructor
import nl.esi.comma.expressions.expression.Pair
import nl.esi.comma.expressions.expression.TypeAnnotation
import nl.esi.comma.expressions.services.ExpressionGrammarAccess
import nl.esi.comma.expressions.validation.ExpressionFunction
import nl.esi.comma.types.types.Type
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ParserRule
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry
import org.eclipse.xtext.ide.editor.contentassist.IIdeContentProposalAcceptor
import org.eclipse.xtext.util.TextRegion

import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType

/**
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
class ExpressionIdeProposalProvider extends AbstractExpressionIdeProposalProvider {
    @Inject
    ExpressionGrammarAccess grammarAccess

    override protected _createProposals(Assignment assignment, ContentAssistContext context,
        IIdeContentProposalAcceptor acceptor) {
        super._createProposals(assignment, context, acceptor)

        val feature = assignment.feature
        switch (object: context.currentModel) {
            Field case feature == 'exp': {
                createDefaultValue(object.recordField.type, context, acceptor)
            }
            ExpressionVector case feature == 'elements': {
                createDefaultValueEntry(object.typeAnnotation, context, acceptor)
            }
            ExpressionMap case feature == 'key': {
                createDefaultValueEntry(object.typeAnnotation, context, acceptor)
            }
            Pair case feature == 'value': {
                val container = object.eContainer
                if (container instanceof ExpressionMap) {
                    val mapType = container.typeAnnotation.type as MapTypeConstructor
                    createDefaultValue(mapType.valueType, context, acceptor)
                }
            }
            case feature == 'functionName': {
                for (func : ExpressionFunction.values) {
                    val proposal = proposalCreator.createProposal(func.name + '()', context, [ entry |
                        entry.kind = ContentAssistEntry.KIND_FUNCTION
                        entry.label = func.name
                        entry.description = 'Function'
                        entry.documentation = func.documentation
                        entry.editPositions +=
                            new TextRegion(context.offset + func.name.length + 1, entry.proposal.length - 2)
                    ])
                    if (proposal !== null) {
                        acceptor.accept(proposal, proposalPriorities.getDefaultPriority(proposal))
                    }
                }
            }
        }
    }

    override protected _createProposals(RuleCall ruleCall, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        switch (ruleCall.getContainerOfType(ParserRule)) {
            case grammarAccess.expressionConstantBoolRule,
            case grammarAccess.expressionConstantIntRule,
            case grammarAccess.expressionConstantRealRule,
            case grammarAccess.expressionConstantStringRule,
            case grammarAccess.expressionFunctionCallRule: {
                return
            }
        }
        super._createProposals(ruleCall, context, acceptor)
    }

    protected def createDefaultValueEntry(TypeAnnotation typeAnn, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        val defaultValue = ProposalHelper.defaultValue(typeAnn)
        val proposal = proposalCreator.createProposal(defaultValue, context, [ entry |
            entry.kind = ContentAssistEntry.KIND_SNIPPET
            entry.label = ProposalHelper.getTypeName(typeAnn)
            entry.description = 'Default Value'
            entry.documentation = defaultValue
        ])
        if (proposal !== null) {
            acceptor.accept(proposal, TEMPLATE_DEFAULT_PRIORITY);
        }
    }

    protected def createDefaultValue(Type type, ContentAssistContext context, IIdeContentProposalAcceptor acceptor) {
        val defaultValue = ProposalHelper.defaultValue(type)
        val proposal = proposalCreator.createProposal(defaultValue, context, [ entry |
            entry.kind = ContentAssistEntry.KIND_SNIPPET
            entry.label = ProposalHelper.getTypeName(type)
            entry.description = 'Default Value'
            entry.documentation = defaultValue
        ])
        if (proposal !== null) {
            acceptor.accept(proposal, TEMPLATE_DEFAULT_PRIORITY);
        }
    }

//    override completeExpressionTypeAnnotated_Elements(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//       super.completeExpressionTypeAnnotated_Elements(model, assignment, context, acceptor)
//       if(model instanceof ExpressionVector){
//           if(model.typeAnnotation.type.type instanceof RecordTypeDecl){
//               acceptRecord(model, assignment, context, acceptor)
//           }
//       }
//    }
//    
//    def acceptRecord(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//        if (object instanceof ExpressionVector) {
//            var type = object.typeAnnotation.type.type
//            if (type instanceof RecordTypeDecl) {
//                var fields = type.fields
//                val prop = '''
//                        «type.name» {«FOR field : fields SEPARATOR ","»«field.name» = «ProposalHelper.defaultValue(field.type)»«ENDFOR»}
//                '''
//                acceptor.accept(createTemplate("Record "+type.name, prop, "", 0, context, 1000, -1, -1))
//            }
//        }
//    }
}
