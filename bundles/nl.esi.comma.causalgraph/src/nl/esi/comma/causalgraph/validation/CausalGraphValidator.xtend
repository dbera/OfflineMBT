/**
 * Copyright (c) 2024, 2025 TNO-ESI
 * 
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 * 
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 * 
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.36.0
 */
package nl.esi.comma.causalgraph.validation

import java.util.List
import java.util.Map
import java.util.TreeMap
import nl.esi.comma.causalgraph.causalGraph.CausalGraph
import nl.esi.comma.causalgraph.causalGraph.CausalGraphPackage
import nl.esi.comma.causalgraph.causalGraph.ScenarioDecl
import nl.esi.comma.causalgraph.causalGraph.ScenarioStep
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import nl.esi.comma.causalgraph.causalGraph.Node
import nl.esi.comma.causalgraph.causalGraph.ControlFlowEdge
import nl.esi.comma.causalgraph.causalGraph.GraphType

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CausalGraphValidator extends AbstractCausalGraphValidator {

    public static val NODE_NAME_UNIQUE = 'NodeNameUnique'
    public static val NODE_STEP_UNIQUE = 'NodeStepUnique'
    public static val SCENARIO_STEP_NR_FIRST = 'ScenarioStepNumberFirst'
    public static val SCENARIO_STEP_NR_DUPLICATE = 'ScenarioStepNumberDuplicate'
    public static val SCENARIO_STEP_NR_SEQUENCE = 'ScenarioStepNumberSequence'
    public static val SCENARIO_STEP_CONTROL_FLOW = 'ScenarioStepControlFlow'
    public static val CONTROL_FLOW_SUPERFLUOUS = 'ControlFlowSuperFluous'

    @Check
    def checkUniqueNodeNames(CausalGraph _graph) {
        val duplicates = _graph.nodes.groupBy[name].values.filter[size > 1].flatten
        duplicates.forEach [ node |
            error('Node name should be unique', node,
                CausalGraphPackage.Literals.NODE__NAME, NODE_NAME_UNIQUE)
        ]
    }

    @Check
    def checkUniqueNodeSteps(CausalGraph _graph) {
        if (_graph.type == GraphType::UCG || _graph.type == GraphType::BDDUCG) {
            return;
        }

        val duplicates = _graph.nodes.groupBy[stepType -> stepName].values.filter[size > 1].flatten
        duplicates.forEach [ node |
            error('The combination of step-name and step-type should be unique', node,
                CausalGraphPackage.Literals.NODE__STEP_NAME, NODE_STEP_UNIQUE)
        ]
    }

    @Check
    def checkScenarioSteps(ScenarioDecl _scenario) {
        val graph = EcoreUtil2.getContainerOfType(_scenario, CausalGraph)
        if (graph === null) {
            warning('Scenario should be contained by graph', null)
        }
        val stepNr2Steps = new TreeMap(graph.nodes.flatMap[steps].filter[scenario == _scenario].groupBy[stepNumber])
        if (stepNr2Steps.isEmpty) {
            warning('There are no steps defined for this scenario', null)
        } else if (stepNr2Steps.firstKey != 1) {
            stepNr2Steps.firstEntry.value.forEach [ step |
                error('The first scenario step should be step number 1', step,
                    CausalGraphPackage.Literals.SCENARIO_STEP__STEP_NUMBER, SCENARIO_STEP_NR_FIRST)
            ]
        }

        var Map.Entry<Integer, List<ScenarioStep>> previousEntry = null
        for (currentEntry : stepNr2Steps.entrySet) {
            if (currentEntry.value.size > 1) {
                for (step : currentEntry.value) {
                    error('Scenario step number should be unique', step,
                        CausalGraphPackage.Literals.SCENARIO_STEP__STEP_NUMBER, SCENARIO_STEP_NR_DUPLICATE)
                }
            }

            if (previousEntry !== null) {
                if (previousEntry.key != currentEntry.key - 1) {
                    for (step : currentEntry.value) {
                        error('''Expected step number «previousEntry.key + 1»''', step,
                            CausalGraphPackage.Literals.SCENARIO_STEP__STEP_NUMBER, SCENARIO_STEP_NR_SEQUENCE)
                    }
                } else if (previousEntry.value.size == 1 && currentEntry.value.size == 1) {
                    val previousNode = EcoreUtil2.getContainerOfType(previousEntry.value.head, Node)
                    val currentNode = EcoreUtil2.getContainerOfType(currentEntry.value.head, Node)

                    if (!graph.edges.filter(ControlFlowEdge).exists[source == previousNode && target == currentNode]) {
                        error('No control flow found between previous step and this step', currentEntry.value.head,
                            null, SCENARIO_STEP_CONTROL_FLOW, previousNode.name, currentNode.name)
                    }
                }
            }
            previousEntry = currentEntry
        }
    }

    @Check
    def checkControlFlow(ControlFlowEdge _edge) {
        val requiresControlFlow = _edge.source.steps.exists[sourceStep | _edge.target.steps.exists[targetStep |
            sourceStep.scenario == targetStep.scenario && sourceStep.stepNumber + 1 == targetStep.stepNumber
        ]]
        if (!requiresControlFlow) {
            error('No control flow required between these steps', null, CONTROL_FLOW_SUPERFLUOUS)
        }
    }
}
