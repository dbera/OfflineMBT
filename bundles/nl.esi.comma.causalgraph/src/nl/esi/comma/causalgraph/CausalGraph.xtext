/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
 
grammar nl.esi.comma.causalgraph.CausalGraph with nl.esi.comma.actions.Actions

generate causalGraph "http://www.esi.nl/comma/causalgraph/CausalGraph"

import "http://www.esi.nl/comma/types/Types" as types
import "http://www.esi.nl/comma/expressions/Expression" as expr

@Override
ModelContainer returns types::ModelContainer:
    super | CausalGraph
;

@Override
NamedElement returns types::NamedElement:
    super | CausalGraph | RequirementDecl | ScenarioDecl | Node
;

@Override
TypeDecl returns types::TypeDecl:
    super | AliasTypeDecl
;

// The graph type is not used in the grammar, but defines the 
// file-extensions for the different graph types, see also 
// nl.esi.comma.causalgraph.utilities.CausalGraphQueries#getType(nl.esi.comma.causalgraph.causalGraph.CausalGraph)
enum GraphType:
    cg = 'CausalGraph' |
    rcg = 'ReducedCausalGraph' |
    ucg = 'UnifiedCausalGraph' |
    bdducg = 'BDDUnifiedCausalGraph'
;

enum StepType:
    none = 'None' |
    given = 'Given' |
    when = 'When' |
    then = 'Then'
;

CausalGraph:
    imports += Import*
    requirements += RequirementDecl+
    scenarios += ScenarioDecl+
    'graph' name=ID ':'
        ('language' ':' language = STRING)?
        ('header' ':' header = BODY)?
        ('types' ':' types += TypeDecl+)?
        ('functions' ':' functions += FunctionDecl+)?
        ('variables' ':' variables += Variable+)?
        ('initializations' ':' assignments += AssignmentAction+)?
        nodes += Node+
        ('edges' ':' edges += Edge+)?
;

RequirementDecl:
    'requirement' name = ID ( ':'
        ('description' ':' description = STRING)?
    )?
;

ScenarioDecl:
    'scenario' name = ID ':'
        'requirements' ':' requirements += [RequirementDecl|ID]+
        ('description' ':' description = STRING)?
;

AliasTypeDecl:
    'alias' name = ID alias = STRING
;

Node:
    'node' name=ID ':'
    'step-name' ':' (function?='function')? stepName = STRING
    ('step-type' ':' stepType = StepType)?
    ('step-parameters' ':' stepParameters += Variable+)?
    ('step-body' ':' stepBody = StepBody)?
    steps += ScenarioStep+
;

ScenarioStep:
    'scenario' scenario=[ScenarioDecl|ID] 'step' stepNumber = INT ( ':'
        ('step-arguments' ':' stepArguments += AssignmentAction+)?
        ('step-variables' ':' stepVariables += StepVariable+)?
        ('step-body' ':' stepBody = StepBody)?
    )?
;

StepVariable:
    access = VariableAccess variable = [expr::Variable | ID]
;

enum VariableAccess:
    READ = 'read' | WRITE = 'write' | READ_WRITE = 'read-write'
;

StepBody:
    ActionsBody | LanguageBody
;

ActionsBody:
    actions += Action+
;

LanguageBody:
    body = BODY
;

Edge:
    ControlFlowEdge | DataFlowEdge
;

ControlFlowEdge:
    source = [Node|ID] '->' target = [Node|ID]
;

DataFlowEdge: 
    source = [Node|ID] '-' '{' dataReferences += DataReference (',' dataReferences += DataReference)* '}' '->' target = [Node|ID]
;

DataReference:
    scenario = [ScenarioDecl|ID] ':' (variables += [expr::Variable|ID] | '[' variables += [expr::Variable|ID] (',' variables += [expr::Variable|ID])* ']')
;

terminal BODY: '«' ( ('»»') | !('»') )* '»';