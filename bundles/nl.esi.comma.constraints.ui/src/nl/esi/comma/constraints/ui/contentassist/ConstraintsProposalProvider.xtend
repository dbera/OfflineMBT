/*
 * generated by Xtext 2.19.0
 */
package nl.esi.comma.constraints.ui.contentassist

import nl.esi.comma.constraints.constraints.Constraints
import nl.esi.comma.steps.step.Steps
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.jface.resource.ImageDescriptor
import org.eclipse.jface.viewers.StyledString
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import nl.esi.comma.types.utilities.CommaUtilities
import nl.esi.comma.constraints.constraints.ConstraintsPackage
import nl.esi.comma.constraints.constraints.StepSequenceDef
import nl.esi.comma.constraints.constraints.ActSequenceDef
import nl.esi.comma.constraints.constraints.Act

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class ConstraintsProposalProvider {
//	
//	protected Image templateIcon
//	final int TEMPLATE_DEFAULT_PRIORITY = 600
//	
//	new() {
//		templateIcon = ImageDescriptor.createFromURL(
//			ConstraintsProposalProvider.getResource("/icons/icon_template.png")).createImage();
//	}
//	
//	override completeAct_DataRow(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		var header = newArrayList
//		if (model instanceof Act){
//			for(dataTable: model.act.data){
//				for(head : dataTable.heading.cells){
//					header.add(head.value.replaceAll("\\|","").replaceAll("\\s+", ""))
//				}
//				var index = 0
//				for(row : dataTable.rows){
//					var prop = ''''''
//					for(var i = 0; i < row.cells.size; i++){
//						prop += '''«header.get(i)» : "«row.cells.get(i).value.replaceAll("\\|","").replaceAll("\\s+", "")»",'''
//					}
//					prop = prop.substring(0, prop.length-1)
//					val info = '''
//					Data instance «index+1» defined in the table
//					'''
//					acceptor.accept(createTemplate(prop, prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+100-index, -1, -1))
//					index++
//				}
//			}
//		}
//	}
//	
//	override completeStepSequenceDef_StepList(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeStepSequenceDef_StepList(model, assignment, context, acceptor)
//		complete_Steps(model, assignment, context, acceptor)
//	}
//	
//	override completeRefStepSequence_Seq(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeRefStepSequence_Seq(model, assignment, context, acceptor)
//		complete_StepSeq(model, assignment, context, acceptor)
//	}
//	
//	def complete_StepSeq(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		if (!context.prefix.equals("")){
//			var prefix = context.prefix
//			var stepSeqList = getAllStepSequences(object)
//			for (sseq : stepSeqList) {
//				if (sseq instanceof StepSequenceDef) {
//					if (matchKeywords(prefix, sseq.name)) {
//						acceptor.accept(
//							doCreateProposal(sseq.name, new StyledString(sseq.name), null, 1500, context))
//					}
//				}
//			}
//		}
//	}
//	
//	def getAllStepSequences(EObject context) {
//		var seqs = CommaUtilities::resolveProxy(context, this.scopeProvider.getScope(context, ConstraintsPackage.Literals.REF_STEP_SEQUENCE__SEQ).allElements)
//			.filter[it.eContainer instanceof Constraints]
//		return seqs
//	}
//	
//	override completeRefActSequence_Seq(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeRefActSequence_Seq(model, assignment, context, acceptor)
//		complete_ActSeq(model, assignment, context, acceptor)
//	}
//	
//	def complete_ActSeq(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		if (!context.prefix.equals("")){
//			var prefix = context.prefix
//			var actSeqList = getAllActSequences(object)
//			for (aseq : actSeqList) {
//				if (aseq instanceof ActSequenceDef) {
//					if (matchKeywords(prefix, aseq.name)) {
//							acceptor.accept(
//								doCreateProposal(aseq.name, new StyledString(aseq.name), null, 1500, context))
//					}
//				}
//			}
//		}
//	}
//	
//	def getAllActSequences(EObject context) {
//		var seqs = CommaUtilities::resolveProxy(context, this.scopeProvider.getScope(context, ConstraintsPackage.Literals.REF_ACT_SEQUENCE__SEQ).allElements)
//			.filter[it.eContainer instanceof Constraints]
//		return seqs
//	}
//	
//	override completeConstraints_CommonFeatures(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeConstraints_CommonFeatures(model, assignment, context, acceptor)
//	}
//	
//	override completeConstraints_Composition(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeConstraints_Composition(model, assignment, context, acceptor)
//		acceptCompositionTemplate(model, assignment, context, acceptor)
//	}
//	
//	override completeRefStep_Step(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeRefStep_Step(model, assignment, context, acceptor)
//		complete_Steps(model, assignment, context, acceptor)
//	}
//	
//	override completeRefAction_Act(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeRefAction_Act(model, assignment, context, acceptor)
//		complete_ActionAct(model, assignment, context, acceptor)
//	}
//	
//	def acceptCompositionTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		val prop = '''
//		constraint compositionID
//		is-composed-of { 
//			//list of the constraint IDs
//		}
//		description "description of the composition"
//		'''
//		val info = '''
//		Define a group of Constraints
//		'''
//		acceptor.accept(createTemplate("Constraint Composition", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY, -1, -1))
//	}
//	
//	// TODO
//	override completeDependencies_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeDependencies_Type(model, assignment, context, acceptor)
//		acceptSuccessionTemplate(model, assignment, context, acceptor)
//		acceptCoExistanceTemplate(model, assignment, context, acceptor)
//		acceptAlternateSuccessionTemplate(model, assignment, context, acceptor)
//		acceptChainSuccessionTemplate(model, assignment, context, acceptor)
//		acceptRespondedExistenceTemplate(model, assignment, context, acceptor)
//		acceptNotSuccessionTemplate(model, assignment, context, acceptor)
//		acceptNotCoExistanceTemplate(model, assignment, context, acceptor)
//		acceptNotChainSuccessionTemplate(model, assignment, context, acceptor)
//	}
//	
//	override completePast_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completePast_Type(model, assignment, context, acceptor)
//		acceptPrecedenceTemplate(model, assignment, context, acceptor)
//		acceptAlternatePrecedenceTemplate(model, assignment, context, acceptor)
//		acceptChainPrecedenceTemplate(model, assignment, context, acceptor)
//	}
//	
//	override completeFuture_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeFuture_Type(model, assignment, context, acceptor)
//		acceptResponseTemplate(model, assignment, context, acceptor)
//		acceptAlternateResponseTemplate(model, assignment, context, acceptor)
//		acceptChainResponseTemplate(model, assignment, context, acceptor)
//	}
//	
//	override completeChoice_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeChoice_Type(model, assignment, context, acceptor)
//		acceptSimpleChoiceTemplate(model, assignment, context, acceptor)
//		acceptExclusiveChoiceTemplate(model, assignment, context, acceptor)
//	}
//	
//	def acceptExclusiveChoiceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does
//				either step A
//				or step B 
//				eventually, 
//				but-never-in-the-same-context
//				'''
//			} else {
//				prop = '''
//				step-seq A or step-seq B eventually-occur, but-never-together
//				//act-seq A or act-seq B eventually-occur, but-never-together
//				//step A or step B eventually-occur, but-never-together
//				//act A or act B eventually-occur, but-never-together
//				'''
//			}
//		} 
//		val info = '''
//		A and B eventually occur but not together
//		'''
//		acceptor.accept(createTemplate("ExclusiveChoice Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+1, -1, -1))
//	}
//	
//	def acceptSimpleChoiceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does
//				step A
//				eventually
//				'''
//			} else {
//				prop = '''
//				step-seq A eventually-occur
//				//act-seq A eventually-occur
//				//step A eventually-occur
//				//act A eventually-occur
//				'''
//			}
//		}
//		
//		val info = '''
//		A must occur eventually 
//		'''
//		acceptor.accept(createTemplate("SimpleChoice Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY, -1, -1))
//	}
//		
//	def acceptChainPrecedenceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				<	  
//				      whenever actor triggers step A
//					  then step B should have-been triggered 
//					  by the actor immediately-before
//				'''
//			} else {
//				prop = '''
//				<       whenever step-seq B occurs then step-seq A must have-occurred-immediately-before
//				//<     whenever act-seq B occurs then act-seq A must have-occurred-immediately-before
//				//<     whenever step B occurs then step A must have-occurred-immediately-before
//				//<     whenever act B occurs then act A must have-occurred-immediately-before
//				'''
//			}
//		}
//
//		val info = '''
//		Each time B occurs, then A must have occured immediately before
//		'''
//		acceptor.accept(createTemplate("ChainPrecedence Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY, -1, -1))
//	}
//	
//	def acceptAlternatePrecedenceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				<!     
//				       whenever the actor triggers
//					   step B 
//					   then step A
//					   must have-been performed by actor before,
//					   with no step C in-between
//				'''
//			} else {
//				prop = '''
//				<!      whenever step-seq B occurs then step-seq A must-have-occurred-before, with no step-seq C in-between
//				//<!    whenever act-seq B occurs then act-seq A must-have-occurred-before, with no act-seq C in-between
//				//<!	whenever step B occurs then step A must-have-occurred-before, with no step C in-between
//				//<!	whenever act B occurs then act A must-have-occurred-before, with no act C in-between
//				
//				'''
//			}
//		}
//		val info = '''
//		Each time B occurs, then A must have occured before with no C in between
//		'''
//		acceptor.accept(createTemplate("AlternatePrecedence Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+1, -1, -1))
//	}
//	
//	def acceptPrecedenceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				<-     
//				       whenever the actor performs
//					   step B 
//					   then step A
//					   should have-been performed by the actor before
//				'''
//			} else {
//				prop = '''
//				<-	    whenever step-seq B occurs then step-seq A must have-occurred-before
//				//<-	whenever act-seq B occurs then act-seq A must have-occurred-before
//				//<-	whenever step B occurs then step A must have-occurred-before
//				//<-	whenever act B occurs then act A must have-occurred-before
//				'''
//			}
//		}
//		val info = '''
//		Each time B occurs, then A must have occured before
//		'''
//		acceptor.accept(createTemplate("Precedence Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+2, -1, -1))
//	}
//	
//	def acceptChainResponseTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				>      
//				       if the actor performs step A 
//					   then step B
//					   should be done by the actor immediately-after
//				'''
//			} else {
//				prop = '''
//				>	    if step-seq A occurs then step-seq B must immediately-follow
//				//>	    if act-seq A occurs then act-seq B must immediately-follow
//				//>	    if step A occurs then step B must immediately-follow
//				//>	    if act A occurs then act B must immediately-follow
//				'''
//			}
//		}
//		val info = '''
//		If A occurs, then B should follow immediately
//		'''
//		acceptor.accept(createTemplate("ChainResponse Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+2, -1, -1))
//	}
//	
//	def acceptAlternateResponseTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				!>     
//				       if actor does step A 
//					   then step B 
//					   must be done by the actor eventually, with 
//					   no step C in-between
//				'''
//			} else {
//				prop = '''
//				!>      if step-seq A occurs then step-seq B must-follow, with no step-seq C in-between
//				//!>	if act-seq A occurs then act-seq B must-follow, with no act-seq C in-between
//				//!>	if step A occurs then step B must-follow, with no step C in-between
//				//!>	if act A occurs then act B must-follow, with no act C in-between
//				'''
//			}
//		}
//		val info = '''
//		If A occurs then B must follow with no (only) A (OR|AND X...) and C (OR|AND Z...) in between
//		'''
//		acceptor.accept(createTemplate("AlternateResponse Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+3, -1, -1))
//	}
//	
//	def acceptResponseTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				->	   
//				       if the actor performs step B 
//					   then step A 
//					   should be triggered by actor eventually
//				'''
//			} else {
//				prop = '''
//				->      if step-seq A occurs then step-seq B must eventually-follow
//				//->    if act-seq A occurs then act-seq B must eventually-follow
//				//->	if step A occurs then step B must eventually-follow
//				//->	if act A occurs then act B must eventually-follow
//				'''
//			}
//		}
//		val info = '''
//		If A occurs, then B must eventually follow
//		'''
//		acceptor.accept(createTemplate("Response Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+4, -1, -1))
//	}
//	
//	def acceptRespondedExistenceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				-|-	   
//				        if the actor performs step A 
//				        then the actor can trigger step B 
//				        in-the-same-context-as-well
//				'''
//			} else {
//				prop = '''
//				-|-	    if step-seq A occurs then step-seq B occurs-as-well
//				//-|-	if act-seq A occurs then act-seq B occurs-as-well
//				//-|-	if step A occurs then step B occurs-as-well
//				//-|-	if act A occurs then act B occurs-as-well
//				'''
//			}
//		}
//		val info = '''
//		If A occurs, then B must occur at least once
//		'''
//		acceptor.accept(createTemplate("RespondedExistence Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+5, -1, -1))
//	}
//		
//	def acceptNotChainSuccessionTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				!<>	   
//				       if the actor does step A  
//					   then step B will not-be 
//					   performed by actor immediately-after, and vice-versa
//				'''
//			} else {
//				prop = '''
//				!<>	    if step-seq A then step-seq B must-not immediately-follow, and vice-versa
//				//!<>	if act-seq A then act-seq B must-not immediately-follow, and vice-versa
//				//!<>	if step A then step B must-not immediately-follow, and vice-versa
//				//!<>	if act A then act B must-not immediately-follow, and vice-versa
//				'''
//			}
//		}
//		val info = '''
//		A occurs if and only if not followed immediately by B
//		'''
//		acceptor.accept(createTemplate("NotChainSuccession Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY, -1, -1))
//	}
//	
//	def acceptNotCoExistanceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				!-	   
//				       The actor does-not perform
//					   step A 
//					   step B 
//					   in-the-same-context 
//				'''
//			} else {
//				prop = '''
//				!-	    step-seq A step-seq B do-not-occur-together
//				//!-	act-seq A act-seq B do-not-occur-together
//				//!-	step A step B do-not-occur-together
//				//!-	act A act B do-not-occur-together
//				'''
//			}
//		}
//		val info = '''
//		A and B do not occur together
//		'''
//		acceptor.accept(createTemplate("NotCoExistance Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+1, -1, -1))
//	}
//	
//	def acceptNotSuccessionTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				!<-->	
//				        if the actor does step A  
//					    then step B
//					    should not-be performed 
//					    by actor eventually, and vice-versa
//				'''
//			} else {
//				prop = '''
//				!<-->	    if step-seq A then step-seq B must-not eventually-follow, and vice-versa
//				//!<-->	    if act-seq A then act-seq B must-not eventually-follow, and vice-versa
//				//!<-->	    if step A then step B must-not eventually-follow, and vice-versa
//				//!<-->	    if act A then act B must-not eventually-follow, and vice-versa
//				'''
//			}
//		}
//		val info = '''
//		A  occurs if and only if not followed by B
//		'''
//		acceptor.accept(createTemplate("NotSuccession Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+2, -1, -1))
//	}
//	
//	def acceptChainSuccessionTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				<>  
//				       if the actor does step A
//					   then step B
//					   should be performed 
//					   by actor immediately-after, and vice-versa
//				'''
//			} else {
//				prop = '''
//				<>	    if step-seq A then step-seq B must-immediately-follow, and vice-versa
//				//<>	if act-seq A then act-seq B must-immediately-follow, and vice-versa
//				//<>	if step A then step B must-immediately-follow, and vice-versa
//				//<>	if act A then act B must-immediately-follow, and vice-versa
//				'''
//			}
//		}
//		val info = '''
//		A occurs if and only if followed immediately by B
//		'''
//		acceptor.accept(createTemplate("ChainSuccession Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY, -1, -1))
//	}
//		
//	def acceptAlternateSuccessionTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				<!>	   
//				       if the actor performs step A 
//					   then step B
//					   should be performed by actor eventually, and vice-versa,
//					   with no step C in-between
//				'''
//			} else {
//				prop = '''
//				<!>	    if step-seq A then step-seq B must-follow, and vice-versa, with no step-seq C in-between
//				//<!>	if act-seq A then act-seq B must-follow, and vice-versa, with no act-seq C in-between
//				//<!>	if step A then step B must-follow, and vice-versa, with no step C in-between
//				//<!>	if act A then act B must-follow, and vice-versa, with no act C in-between
//				'''
//			}
//		}
//		val info = '''
//		A occurs if and only if followed by B with no C in between
//		'''
//		acceptor.accept(createTemplate("AlternateSuccession Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY-1, -1, -1))
//	}
//		
//	def acceptSuccessionTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				<-->	
//				        if the actor performs step A 
//					    then step B should be performed 
//					    by the actor eventually, and vice-versa
//				'''
//			} else {
//				prop = '''
//				<-->	   if step-seq A then step-seq B must-eventually-follow, and vice-versa
//				//<-->	   if act-seq A then act-seq B must-eventually-follow, and vice-versa
//				//<-->	   if step A then step B must-eventually-follow, and vice-versa
//				//<-->	   if act A then act B must-eventually-follow, and vice-versa
//				'''
//			}
//		}
//		val info = '''
//		A occurs if and only if it is followed by B
//		'''
//		acceptor.accept(createTemplate("Succession Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+1, -1, -1))
//	}
//		
//	def acceptCoExistanceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				-	   
//				       The actor must perform 
//					   step A 
//					   step B 
//					   in-the-same-context
//				'''
//			} else {
//				prop = '''
//				-	    step-seq A step-seq B occur-together
//				//-	    act-seq A act-seq B occur-together
//				//-	    step A step B occur-together
//				//-	    act A act B occur-together
//				'''
//			}
//		}
//		val info = '''
//		A and B occur together
//		'''
//		acceptor.accept(createTemplate("CoExistance Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+2, -1, -1))
//	}
//	
//	override completeExistential_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		super.completeExistential_Type(model, assignment, context, acceptor)
//		acceptParticipationTemplate(model, assignment, context, acceptor)
//		acceptAtMostOneTemplate(model, assignment, context, acceptor)
//		acceptInitTemplate(model, assignment, context, acceptor)
//		acceptEndTemplate(model, assignment, context, acceptor)
//		acceptExactTemplate(model, assignment, context, acceptor)
//	}
//	
//	def acceptExactTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does step A exactly 1 time
//				'''
//			} else {
//				prop = '''
//				step-seq A occurs-exactly 1 time
//				//act-seq A occurs-exactly 1 time
//				//step A occurs-exactly 1 time
//				//act A occurs-exactly 1 time
//				'''
//			}
//		}
//		val info = '''
//		A occurs exactly
//		'''
//		acceptor.accept(createTemplate("Exact Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+3, -1, -1))
//	}
//		
//	def acceptEndTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does step A in-the-end
//				'''
//			} else {
//				prop = '''
//				step-seq A occurs-last
//				//act-seq A occurs-last
//				//step A occurs-last
//				//act A occurs-last
//				'''
//			}
//		}
//		val info = '''
//		A occurs last
//		'''
//		acceptor.accept(createTemplate("End Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+2, -1, -1))
//	}
//		
//	def acceptInitTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does step A first
//				'''
//			} else {
//				prop = '''
//				step-seq A occurs-first
//				//act-seq A occurs-first
//				//step A occurs-first
//				//act A occurs-first
//				'''
//			}
//		}
//		val info = '''
//		A occurs first
//		'''
//		acceptor.accept(createTemplate("Init Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY+1, -1, -1))
//	}
//		
//	def acceptAtMostOneTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does step A at-most 1 time
//				'''
//			} else {
//				prop = '''
//				step-seq A occurs-at-most 1 time
//				//act-seq A occurs-at-most 1 time
//				//step A occurs-at-most 1 time
//				//act A occurs-at-most 1 time
//				'''
//			}
//		}
//		val info = '''
//		A occurs at most once
//		'''
//		acceptor.accept(createTemplate("AtMostOne Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY, -1, -1))
//	}
//		
//	def acceptParticipationTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		var root = context.rootModel
//		var prop = ''''''
//		if (root instanceof Constraints) {
//			if (root.sclTemplates) {
//				prop = '''
//				The actor does step A at-least 1 time
//				'''
//			} else {
//				prop = '''
//				step-seq A occurs-at-least 1 times
//				//act-seq A occurs-at-least 1 times
//				//step A occurs-at-least 1 times
//				//act A occurs-at-least 1 times
//				'''
//			}
//		}
//		val info = '''
//		A occurs at least once
//		'''
//		acceptor.accept(createTemplate("AtLeastOne Constraint", prop, info, 0, context, TEMPLATE_DEFAULT_PRIORITY-1, -1, -1))
//	}
//	
//	override completeTemplates_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
//		/*context is empty then provide keywords,
//		 * context is not empty then provide steps
//		*/
//		if (!context.prefix.equals("")){
//			complete_Steps(model, assignment, context, acceptor)
//		} else {
//			super.completeTemplates_Type(model, assignment, context, acceptor)
//		}
//	}
//	
//	def complete_Steps(EObject model, Assignment assignment, ContentAssistContext context,
//		ICompletionProposalAcceptor acceptor) {
//		// super.completeConstraints_Steps(model, assignment, context, acceptor)
//		// get imported Actions
//		if (!context.prefix.equals("")){
//			var prefix = context.prefix
//			var stepList = getImportedSteps(context.rootModel as Constraints)
//			for (action : stepList) {
//				if (matchKeywords(prefix, action.name)) {
//						acceptor.accept(
//							doCreateProposal(action.name, new StyledString(action.name), null, 2000, context))
//				}
//			}
//		}
//	}
//	
//	def complete_ActionAct(EObject model, Assignment assignment, ContentAssistContext context,
//		ICompletionProposalAcceptor acceptor){
//		if (!context.prefix.equals("")){
//			var prefix = context.prefix
//			var actList = getImportedActions(context.rootModel as Constraints)
//			for (action : actList) {
//				if (matchKeywords(prefix, action.name)) {
//						acceptor.accept(
//							doCreateProposal(action.name, new StyledString(action.name), null, 2000, context))
//				}
//			}
//		}
//	}
//	
//	def getImportedSteps(Constraints model){
//		val stepList = newArrayList
//		for (imp : (model as Constraints).imports) {
//			val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
//			val root = r.allContents.head
//			if (root instanceof Steps) {
//				stepList.addAll(root.actionList.acts)
//				root.actionList.acts.forEach[s | stepList.add(s.stepWithOutData)]
//			}
//		}
//		return stepList
//	}
//	
//	def getImportedActions(Constraints model){
//		val actList = newArrayList
//		if (!model.actions.isNullOrEmpty){
//			actList.addAll(model.actions.get(0).act)
//		}
//		
//		for (imp : (model as Constraints).imports) {
//			val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
//			val root = r.allContents.head
//			if (root instanceof Constraints) {
//				if (!root.actions.isNullOrEmpty){
//					actList.addAll(root.actions.get(0).act)
//				}
//			}
//		}
//		return actList
//	}
//
//	def matchKeywords(String keyword, String label) {
//		if (keyword.contains("_")) {
//			var searchwords = keyword.split("_")
//			var matchAll = true
//			for(sw : searchwords){
//				if(!label.contains(sw) && !label.toLowerCase.contains(sw)){
//					matchAll = false
//				}
//			}
//			return matchAll
//		} else {
//			if (label.contains(keyword) ||
//				label.toLowerCase.contains(keyword)) {
//					return true
//			}
//		}
//		return false
//	}
//	
//	override completeConstraints_Templates(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		super.completeConstraints_Templates(model, assignment, context, acceptor)
//		//accept four main cases
//		if (context.prefix == ""){
//			acceptDependenciesTemplate(model, assignment, context, acceptor)
//			acceptPastTemplate(model, assignment, context, acceptor)
//			acceptFutureTemplate(model, assignment, context, acceptor)
//			acceptChoiceTemplate(model, assignment, context, acceptor)
//			acceptExistentialTemplate(model, assignment, context, acceptor)
//		}
//	}
//		
//	def acceptExistentialTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		val prop = '''
//		
//		E
//		'''
//		acceptor.accept(createTemplate("Existential Constraint Group", prop, "Existential Constraint Group", 0, context, TEMPLATE_DEFAULT_PRIORITY+100, -1, -1))
//	}
//		
//	def acceptDependenciesTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		val prop = '''
//		
//		PF
//		'''
//		acceptor.accept(createTemplate("Dependency Constraint Group", prop, "Dependency Constraint Group", 0, context, TEMPLATE_DEFAULT_PRIORITY+200, -1, -1))
//	}
//		
//	def acceptPastTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		val prop = '''
//		
//		P
//		'''
//		acceptor.accept(createTemplate("Past Constraint Group", prop, "Past Constraint Group", 0, context, TEMPLATE_DEFAULT_PRIORITY+300, -1, -1))
//	}
//		
//	def acceptFutureTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		val prop = '''
//		
//		F
//		'''
//		acceptor.accept(createTemplate("Future Constraint Group", prop, "Future Constraint Group", 0, context, TEMPLATE_DEFAULT_PRIORITY+400, -1, -1))
//	}
//	
//	def acceptChoiceTemplate(EObject object, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		val prop = '''
//		
//		C
//		'''
//		acceptor.accept(createTemplate("Choice Constraint Group", prop, "Choice Constraint Group", 0, context, TEMPLATE_DEFAULT_PRIORITY+500, -1, -1))
//	}
//	
//	override
//	protected def createTemplate(String name, String content, String additionalInfo, Integer nrIndents,
//		ContentAssistContext context, int priority, int selection, int length) {
//// DB commented to remove error. 23.07.2024 
////		if (nrIndents == 0) {
////			createProposal(name, content, additionalInfo, context, priority, selection, length)
////		} else {
////			var indent = "";
////			for (var i = 0; i < nrIndents; i++) {
////				indent += "\t";
////			}
////			var indentedContent = content.replace("\n", "\n" + indent)
////			indentedContent = "\n" + indent + indentedContent
////			createProposal(name, indentedContent, additionalInfo, context, priority, selection, length)
////		}
//
//	}
//
//	private def createProposal(String name, String content, String additionalInfo, ContentAssistContext context,
//		int priority, int selection, int length) {
//
//		var finalAdditionalInfo = content
//		val proposal = createHtmlCompletionProposal(content, new StyledString(name), templateIcon,
//			TEMPLATE_DEFAULT_PRIORITY, context);
//
//		if (proposal instanceof ConfigurableCompletionProposal) {
//			while (finalAdditionalInfo.startsWith("\n") || finalAdditionalInfo.startsWith("\r")) {
//				finalAdditionalInfo = finalAdditionalInfo.substring(1);
//			}
//			finalAdditionalInfo = "<html><body bgcolor=\"#FFFFE1\"><style> body { font-size:9pt; font-family:'Segoe UI' }</style><pre>" +
//				finalAdditionalInfo + "</pre>";
//			if (additionalInfo !== null) {
//				finalAdditionalInfo = finalAdditionalInfo + "<p>" + additionalInfo + "</p>";
//			}
//			finalAdditionalInfo = finalAdditionalInfo + "</body></html>"
//			proposal.additionalProposalInfo = finalAdditionalInfo
//			proposal.proposalContextResource = context.resource			
//			proposal.priority = priority
//			proposal.selectionStart = context.offset + selection
//			proposal.selectionLength = length			
//		}
//		proposal
//	}
//	
//	private def createHtmlCompletionProposal(String proposal, StyledString displayString, Image image, int priority,
//		ContentAssistContext context) {
//		if (isValidProposal(proposal, context.getPrefix(), context)) {
//			return doCreateHtmlCompletionProposal(proposal, displayString, image, priority, context);
//		}
//		return null;
//	}
//	
//	private def doCreateHtmlCompletionProposal(String proposal, StyledString displayString, Image image, int priority,
//		ContentAssistContext context) {
//		val replacementOffset = context.getReplaceRegion().getOffset();
//		val replacementLength = context.getReplaceRegion().getLength();
//		val result = new HtmlConfigurableCompletionProposal(proposal, replacementOffset, replacementLength,
//			proposal.length(), image, displayString, null, null);
//
//		result.priority = priority
//		result.matcher = context.matcher
//		result.replaceContextLength = context.replaceContextLength
//		result;
//	}
}
