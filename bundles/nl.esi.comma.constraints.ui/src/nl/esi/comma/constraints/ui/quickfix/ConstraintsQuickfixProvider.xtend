/*
 * generated by Xtext 2.19.0
 */
package nl.esi.comma.constraints.ui.quickfix

import com.google.inject.Inject
import java.util.ArrayList
import java.util.List
import java.util.regex.Pattern
import javax.inject.Provider
import nl.esi.comma.constraints.constraints.Actions
import nl.esi.comma.constraints.constraints.Constraints
import nl.esi.comma.types.ui.quickfix.TypesQuickfixProvider
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification
import org.eclipse.xtext.ui.editor.quickfix.IssueResolution
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class ConstraintsQuickfixProvider extends TypesQuickfixProvider {

	@Inject
	Provider<IssueResolutionAcceptor> issueResolutionAcceptorProvider
	
	static val Pattern actionIssuePattern = Pattern.compile("^Couldn't resolve reference to Action '([a-zA-Z0-9_\\-]+)'\\.$")
	static val Pattern actSeqIssuePattern = Pattern.compile("^Couldn't resolve reference to ActSequenceDef '([a-zA-Z0-9_\\-]+)'\\.$")
	static val Pattern stepSeqIssuePattern = Pattern.compile("^Couldn't resolve reference to StepSequenceDef '([a-zA-Z0-9_\\-]+)'\\.$")
	override List<IssueResolution> getResolutionsForLinkingIssue(Issue issue) {
		val List<IssueResolution> finalResolutions = new ArrayList<IssueResolution>();
		var List<IssueResolution> originalResolutions = super.getResolutionsForLinkingIssue(issue);
		var IssueResolutionAcceptor issueResolutionAcceptor = null
		var issueMatcher = actionIssuePattern.matcher(issue.getMessage())
		if (issueMatcher.find){
			issueResolutionAcceptor = getActionResolution(issue, issueMatcher.group(1))
			finalResolutions.addAll(issueResolutionAcceptor.getIssueResolutions());
		}
		issueMatcher = actSeqIssuePattern.matcher(issue.getMessage())
		if (issueMatcher.find){
			issueResolutionAcceptor = getActSeqResolution(issue, issueMatcher.group(1))
			finalResolutions.addAll(issueResolutionAcceptor.getIssueResolutions());
		}
		issueMatcher = stepSeqIssuePattern.matcher(issue.getMessage())
		if (issueMatcher.find){
			issueResolutionAcceptor = getStepSeqResolution(issue, issueMatcher.group(1))
			finalResolutions.addAll(issueResolutionAcceptor.getIssueResolutions());
		}
		finalResolutions.addAll(originalResolutions);
		return finalResolutions;
	}
	
	def IssueResolutionAcceptor getStepSeqResolution(Issue issue, String triggerName){
		val IssueResolutionAcceptor issueResolutionAcceptor = issueResolutionAcceptorProvider.get();
		val ISemanticModification modiStepSeq = new ISemanticModification {
			
			override apply(EObject element, IModificationContext context) throws Exception {
				val root = EcoreUtil2.getContainerOfType(element, Constraints)
				val lastActSeq = root.ssequences.last
				var offset = 0
				if (lastActSeq !== null) {
					offset = getOffset(lastActSeq)
				} else {
					if (root.actions.size > 0){
						offset = getOffset(root.actions.last) + 3
					} else {
						if (root.actors.size > 0){
							offset = getOffset(root.actors.last)
						} else {
							if (root.imports.size > 0){
								offset = getOffset(root.imports.last)
							} else {
								offset = 0
							}
						}
					}
				}
				val fix = "\nStep-Sequence-Def " + triggerName + " {\n}"
				context.getXtextDocument().replace(offset, 0, fix)
			}
			
		}
		issueResolutionAcceptor.accept(issue, "Add Step Sequence " + triggerName,
				"Add Step Sequence", "upcase.png", modiStepSeq)
		return issueResolutionAcceptor
	}
	def IssueResolutionAcceptor getActSeqResolution(Issue issue, String triggerName){
		val IssueResolutionAcceptor issueResolutionAcceptor = issueResolutionAcceptorProvider.get();
		val ISemanticModification modiActSeq = new ISemanticModification {
			
			override apply(EObject element, IModificationContext context) throws Exception {
				val root = EcoreUtil2.getContainerOfType(element, Constraints)
				val lastActSeq = root.asequences.last
				var offset = 0
				if (lastActSeq !== null) {
					offset = getOffset(lastActSeq)
				} else {
					if (root.ssequences.size > 0){
						offset = getOffset(root.ssequences.last)
					} else {
						if (root.actions.size > 0){
							offset = getOffset(root.actions.last) + 3
						} else {
							if (root.actors.size > 0){
								offset = getOffset(root.actors.last)
							} else {
								if (root.imports.size > 0){
									offset = getOffset(root.imports.last)
								} else {
									offset = 0
								}
							}
						}
					}
				}
				val fix = "\nAct-Sequence-Def " + triggerName + " {\n}"
				context.getXtextDocument().replace(offset, 0, fix)
			}
			
		}
		issueResolutionAcceptor.accept(issue, "Add Action Sequence " + triggerName,
				"Add Action Sequence", "upcase.png", modiActSeq)
		return issueResolutionAcceptor
	}
	def IssueResolutionAcceptor getActionResolution(Issue issue, String triggerName){
		val IssueResolutionAcceptor issueResolutionAcceptor = issueResolutionAcceptorProvider.get();
		val ISemanticModification modifTrgr = new ISemanticModification() {	
			override apply(EObject element, IModificationContext context) throws Exception {
				val root = EcoreUtil2.getContainerOfType(element, Constraints)
				var offset = 0
				var fix = ""
				if (root.actions.size > 0) {
					val lastAction = (root.actions.get(0) as Actions).act.last
					if (lastAction !== null) {
						offset = getOffset(lastAction)
					} else {
						offset = getOffset(root.actions.get(0))
					}
					fix = "\n\tTrigger " + triggerName + " \""+ getDescription(triggerName) +"\""
				} else {
					if (root.actors.size > 0){
						offset = getOffset(root.actors.last)
					} else {
						if (root.imports.size > 0){
							offset = getOffset(root.imports.last)
						}
					}
					fix = "\naction-list: {\n\tTrigger " + triggerName + " \""+ getDescription(triggerName) +"\"\n}\n"
				}
				
				System.out.println(fix);
				context.getXtextDocument().replace(offset, 0, fix)
			}
		};
		issueResolutionAcceptor.accept(issue, "Add Action " + triggerName + " as Trigger",
				"Add Action as Trigger", "upcase.png", modifTrgr)
				
		val ISemanticModification modifObsv = new ISemanticModification() {
			override void apply(EObject element, IModificationContext context) throws Exception {
				val root = EcoreUtil2.getContainerOfType(element, Constraints)
				var offset = 0
				var fix = ""
				if (root.actions.size > 0) {
					val lastAction = (root.actions.get(0) as Actions).act.last
					//System.out.println(lastAction.getName());
					if (lastAction !== null) {
						offset = getOffset(lastAction)
					} else {
						offset = getOffset(root.actions.get(0))
					}
					fix = "\n\tObservable " + triggerName + " \""+ getDescription(triggerName) +"\""
				} else {
					if (root.actors.size > 0){
						offset = getOffset(root.actors.last)
					} else {
						if (root.imports.size > 0){
							offset = getOffset(root.imports.last)
						}
					}
					fix = "\naction-list: {\n\tObservable " + triggerName + " \""+ getDescription(triggerName) +"\"\n}\n"
				}
				System.out.println(fix);
				context.getXtextDocument().replace(offset, 0, fix);
			}
		};
		issueResolutionAcceptor.accept(issue, "Add Action " + triggerName + " as Observable",
				"Add Action as Observable", "upcase.png", modifObsv)
				
		val ISemanticModification modifPred = new ISemanticModification() {
			override void apply(EObject element, IModificationContext context) throws Exception {
				val root = EcoreUtil2.getContainerOfType(element, Constraints)
				var offset = 0
				var fix = ""
				if (root.actions.size > 0) {
					val lastAction = (root.actions.get(0) as Actions).act.last
					//System.out.println(lastAction.getName());
					if (lastAction !== null) {
						offset = getOffset(lastAction)
					} else {
						offset = getOffset(root.actions.get(0))
					}
					fix = "\n\tPre-condition " + triggerName + " \""+ getDescription(triggerName) +"\""
				} else {
					if (root.actors.size > 0){
						offset = getOffset(root.actors.last)
					} else {
						if (root.imports.size > 0){
							offset = getOffset(root.imports.last)
						}
					}
					fix = "\naction-list: {\n\tPre-condition " + triggerName + " \""+ getDescription(triggerName) +"\"\n}\n"
				}
				System.out.println(fix);
				context.getXtextDocument().replace(offset, 0, fix);
			}
		};
		issueResolutionAcceptor.accept(issue, "Add Action " + triggerName + " as Pre-condition",
				"Add Action as Pre-condition", "upcase.png", modifPred)
		return issueResolutionAcceptor
	}
	
	def String getDescription(String actionName) {
		var result = splitCamelCase(actionName);
		if(result.contains("_")) {
			result = actionName.replace("_", " ");
		}
		return result;
	}
	
	def static String splitCamelCase(String s) {
		return s.replaceAll(
			String.format("%s|%s|%s",
			"(?<=[A-Z])(?=[A-Z][a-z])",
			"(?<=[^A-Z])(?=[A-Z])",
			"(?<=[A-Za-z])(?=[^A-Za-z])"),
		" ");
	}
	
	def int getOffset(EObject context){
		var offset = 0
		if (context instanceof Actions){
			offset = NodeModelUtils.findActualNodeFor(context).getEndOffset() - 3
		} else {
			offset = NodeModelUtils.findActualNodeFor(context).getEndOffset();
		}
		return offset
	}
}
