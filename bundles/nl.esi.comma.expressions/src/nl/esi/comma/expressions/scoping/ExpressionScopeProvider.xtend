/*
 * generated by Xtext 2.10.0
 */
package nl.esi.comma.expressions.scoping

import java.util.ArrayList
import java.util.List
import nl.esi.comma.expressions.expression.ExpressionBinary
import nl.esi.comma.expressions.expression.ExpressionEnumLiteral
import nl.esi.comma.expressions.expression.ExpressionPackage
import nl.esi.comma.expressions.expression.ExpressionRecord
import nl.esi.comma.expressions.expression.ExpressionRecordAccess
import nl.esi.comma.expressions.expression.ExpressionVector
import nl.esi.comma.expressions.expression.Field
import nl.esi.comma.expressions.validation.ExpressionValidator
import nl.esi.comma.signature.interfaceSignature.Signature
import nl.esi.comma.types.types.EnumTypeDecl
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.TypeDecl
import nl.esi.comma.types.types.TypeObject
import nl.esi.comma.types.utilities.CommaUtilities
import nl.esi.comma.types.utilities.TypeUtilities
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

import static org.eclipse.xtext.scoping.Scopes.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ExpressionScopeProvider extends AbstractExpressionScopeProvider {

    override getScope(EObject context, EReference reference) {
        val contextType = context.getContextType(reference)
        switch (context) {
            case contextType instanceof EnumTypeDecl  && reference == ExpressionPackage.Literals.EXPRESSION_ENUM_LITERAL__LITERAL: {
                return scopeFor((contextType as EnumTypeDecl).literals)
            }
            ExpressionRecord case reference == ExpressionPackage.Literals.FIELD__RECORD_FIELD: {
                return scopeFor(TypeUtilities::getAllFields(context.type))
            }
            ExpressionRecordAccess case reference == ExpressionPackage.Literals.EXPRESSION_RECORD_ACCESS__FIELD: {
                val type = ExpressionValidator.typeOf(context.record)
                return type instanceof RecordTypeDecl ? scopeFor(TypeUtilities::getAllFields(type)) : IScope.NULLSCOPE
            }
            Field case reference == ExpressionPackage.Literals.FIELD__RECORD_FIELD: {
                val rec = context.eContainer
                return rec instanceof ExpressionRecord ? scopeFor(TypeUtilities::getAllFields(rec.type)) : IScope.NULLSCOPE
            }
            case reference.name == 'type': {
                val interfaces = context.eClass.EAllReferences.filter[name == 'interface']
                if (!interfaces.empty) {
                    val Signature i = context.eGet(interfaces.head) as Signature
                    return scope_forType(context, i, reference)
                }
            }
        }

        return super.getScope(context, reference)
    }

    override getContextType(EObject context, EStructuralFeature reference) {
        var TypeObject type = switch (context) {
            Field case reference != ExpressionPackage.Literals.FIELD__RECORD_FIELD: {
                context.recordField?.type?.type
            }
            ExpressionEnumLiteral case reference == ExpressionPackage.Literals.EXPRESSION_ENUM_LITERAL__LITERAL: {
                context.type
            }
            ExpressionBinary case reference != ExpressionPackage.Literals.EXPRESSION_BINARY__LEFT: {
                ExpressionValidator.typeOf(context.left)
            }
            ExpressionVector: {
                val vct = ExpressionValidator.typeOf(context)
                vct === null ? null : TypeUtilities::getElementType(vct)
            }
        }
        return type
    }

    protected def scope_forEnum(TypeObject type, EReference ref) {
        return if (type instanceof EnumTypeDecl && ref == ExpressionPackage.Literals.EXPRESSION_ENUM_LITERAL__LITERAL) {
            Scopes.scopeFor((type as EnumTypeDecl).literals)
        } else  {
            IScope.NULLSCOPE
        }
    }

    def scope_forType(EObject context, Signature i, EReference ref) {
        if(i !== null) return scopeFor(i.types)
        var List<TypeDecl> types = new ArrayList<TypeDecl>

        for (i1 : findVisibleInterfaces(context)) {
            types.addAll(i1.types);
        }
        return scopeFor(types, super.getScope(context, ref))
    }

    def List<Signature> findVisibleInterfaces(EObject context) {
        CommaUtilities::resolveProxy(context,
            getScope(context, ExpressionPackage.Literals.INTERFACE_AWARE_TYPE__INTERFACE).allElements)
    }
}
