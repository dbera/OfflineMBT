/*
 * generated by Xtext 2.10.0
 */
package nl.esi.comma.expressions.scoping

import java.util.ArrayList
import java.util.List
import nl.esi.comma.expressions.expression.ExpressionEnumLiteral
import nl.esi.comma.expressions.expression.ExpressionFunctionCall
import nl.esi.comma.expressions.expression.ExpressionPackage
import nl.esi.comma.expressions.expression.ExpressionRecord
import nl.esi.comma.expressions.expression.ExpressionRecordAccess
import nl.esi.comma.expressions.expression.Field
import nl.esi.comma.expressions.validation.ExpressionValidator
import nl.esi.comma.signature.interfaceSignature.Signature
import nl.esi.comma.types.types.EnumTypeDecl
import nl.esi.comma.types.types.RecordTypeDecl
import nl.esi.comma.types.types.TypeDecl
import nl.esi.comma.types.types.TypesPackage
import nl.esi.comma.types.utilities.CommaUtilities
import nl.esi.comma.types.utilities.TypeUtilities
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.FilteringScope

import static org.eclipse.xtext.scoping.Scopes.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ExpressionScopeProvider extends AbstractExpressionScopeProvider {

    override getScope(EObject context, EReference reference) {
        switch (context) {
            ExpressionEnumLiteral case reference == ExpressionPackage.Literals.EXPRESSION_ENUM_LITERAL__LITERAL: {
                return scopeFor(context.type.literals)
            }
            ExpressionRecord case reference == ExpressionPackage.Literals.FIELD__RECORD_FIELD: {
                return scopeFor(TypeUtilities::getAllFields(context.type))
            }
            ExpressionRecordAccess case reference == ExpressionPackage.Literals.EXPRESSION_RECORD_ACCESS__FIELD: {
                val type = ExpressionValidator.typeOf(context.record)
                return type instanceof RecordTypeDecl ? scopeFor(TypeUtilities::getAllFields(type)) : IScope.NULLSCOPE
            }
            Field case reference == ExpressionPackage.Literals.FIELD__RECORD_FIELD: {
                val rec = context.eContainer
                return rec instanceof ExpressionRecord ? scopeFor(TypeUtilities::getAllFields(rec.type)) : IScope.NULLSCOPE
            }
            Field case reference == ExpressionPackage.Literals.EXPRESSION_ENUM_LITERAL__LITERAL: {
                val enumTypeDecl = context.recordField?.type?.type
                return enumTypeDecl instanceof EnumTypeDecl ? scopeFor(enumTypeDecl.literals) : IScope.NULLSCOPE
            }
            Field case reference.isTypeDeclReference: {
                return new FilteringScope(super.getScope(context, reference)) [ desc |
                    ExpressionValidator.subTypeOf(context.recordField?.type?.type, desc.EObjectOrProxy as TypeDecl)
                ]
            }
            ExpressionFunctionCall case reference.isTypeDeclReference: {
                return IScope.NULLSCOPE
            }
            case reference.name == 'type': {
                val interfaces = context.eClass.EAllReferences.filter[name == 'interface']
                if (!interfaces.empty) {
                    val Signature i = context.eGet(interfaces.head) as Signature
                    return scope_forType(context, i, reference)
                }
            }
        }

        return super.getScope(context, reference)
    }

    protected def isTypeDeclReference(EReference reference) {
        return reference.EType instanceof EClass && TypesPackage.Literals.TYPE_DECL.isSuperTypeOf(reference.EType as EClass)
    }

    def scope_forType(EObject context, Signature i, EReference ref) {
        if(i !== null) return scopeFor(i.types)
        var List<TypeDecl> types = new ArrayList<TypeDecl>

        for (i1 : findVisibleInterfaces(context)) {
            types.addAll(i1.types);
        }
        return scopeFor(types, super.getScope(context, ref))
    }

    def List<Signature> findVisibleInterfaces(EObject context) {
        CommaUtilities::resolveProxy(context,
            getScope(context, ExpressionPackage.Literals.INTERFACE_AWARE_TYPE__INTERFACE).allElements)
    }
}
