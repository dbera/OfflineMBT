/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.inputspecification.scoping

import nl.esi.comma.expressions.expression.ExpressionPackage
import nl.esi.comma.inputspecification.inputSpecification.InputSpecificationPackage
import nl.esi.comma.inputspecification.inputSpecification.Tail
import nl.esi.comma.signature.utilities.InterfaceUtilities
import nl.esi.comma.types.utilities.CommaUtilities
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope

import static org.eclipse.xtext.scoping.Scopes.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class InputSpecificationScopeProvider extends AbstractInputSpecificationScopeProvider {
	override getScope(EObject context, EReference reference) {

		/*if (context instanceof EventData && reference == InputSpecificationPackage.Literals.EVENT_DATA__STATE) {
			return scope_State(context as EventData, reference)
		}

		if (context instanceof Body && reference == InputSpecificationPackage.Literals.BODY__EVENT) {
			return scope_Event(context as Body, reference)
		}*/

		if (context instanceof Tail && reference == InputSpecificationPackage.Literals.TAIL__NI_EVENT) {
			return scope_Event(context as Tail, reference)
		}
		
		// In Progress DB
		/*if(context instanceof EventData && reference == InputSpecificationPackage.Literals.EVENT_DATA__INSTANCE) {
			return scope_Event_Instance(context as EventData, reference)
		}*/
		
		/*if(context instanceof EventData && reference == InputSpecificationPackage.Literals.EVENT_DATA__CLAUSE) {
			return scope_Event_Clause(context as EventData, reference)
		}*/
				
		return super.getScope(context, reference);
	}

	/*def scope_State(EventData body, EReference reference) {
		val machines = CommaUtilities::resolveProxy(body,
			getScope(body, BehaviorPackage.Literals.ABSTRACT_BEHAVIOR__MACHINES).getAllElements)
		var listOfStates = new ArrayList<State>

		for (m : machines)
			listOfStates.addAll((m as StateMachine).states)
		return scopeFor(listOfStates)
	}

	def scope_Event(Body body, EReference reference) {
		val intf = CommaUtilities::resolveProxy(body,
			getScope(body, ExpressionPackage.Literals.INTERFACE_AWARE_TYPE__INTERFACE).getAllElements)
		if(intf.empty) {
			return IScope.NULLSCOPE
		} else {
			return scopeFor(InterfaceUtilities::getAllInterfaceEvents(intf.head))
		}		
	}*/

	def scope_Event(Tail tail, EReference reference) {
		val intf = CommaUtilities::resolveProxy(tail,
			getScope(tail, ExpressionPackage.Literals.INTERFACE_AWARE_TYPE__INTERFACE).getAllElements)
		if(intf.empty) {
			return IScope.NULLSCOPE
		} else {
			return scopeFor(InterfaceUtilities::getAllInterfaceEvents(intf.head))
		}		
	}

	// In Progress: DB	
	//var SimpleAnyType wrapper = XMLTypeFactory.eINSTANCE.createSimpleAnyType();
	//wrapper.setInstanceType(EcorePackage.eINSTANCE.getEInt());
	//wrapper.setValue(new Integer(42));
	/*
	def scope_Event_Instance(EventData data, EReference reference) {
		val machines = CommaUtilities::resolveProxy(data, 
			getScope(data, BehaviorPackage.Literals.ABSTRACT_BEHAVIOR__MACHINES).getAllElements)
		// how to determine which event this is?
		val body = EcoreUtil2.getContainerOfType(data, Body);
		System.out.println("Test SCOPE (event name): "+body.event.name)
		System.out.println("Test SCOPE (state name): "+data.state.name)
		
		var listOfStates = new ArrayList<TriggeredTransition>
		for(m : machines)
		{
			for(s : (m as StateMachine).states) {
				var idx = 0
				var command_map = getCommandsMapForState(m, s)
				if(command_map.containsKey(body.event.name)) {
					for(evt : command_map.get(body.event.name)) {
						idx++
						listOfStates.add(evt as TriggeredTransition)
						System.out.println("Test SCOPE (transition): "+(evt as TriggeredTransition).trigger.name)
					}
				}
			}
		}
		return scopeFor(listOfStates)
	}*/

	/*def scope_Event_Clause(EventData data, EReference reference) {
		val machines = CommaUtilities::resolveProxy(data, 
			getScope(data, BehaviorPackage.Literals.ABSTRACT_BEHAVIOR__MACHINES).getAllElements)
	}*/
}
