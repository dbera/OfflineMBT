/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.inputspecification.scoping

import java.util.ArrayList
import java.util.HashMap
import nl.esi.comma.behavior.behavior.BehaviorPackage
import nl.esi.comma.behavior.behavior.State
import nl.esi.comma.behavior.behavior.StateMachine
import nl.esi.comma.behavior.behavior.Transition
import nl.esi.comma.behavior.behavior.TriggeredTransition
import nl.esi.comma.behavior.utilities.StateMachineUtilities
import nl.esi.comma.expressions.expression.ExpressionPackage
//import nl.esi.comma.inputspecification.inputSpecification.Body
//import nl.esi.comma.inputspecification.inputSpecification.EventData
import nl.esi.comma.inputspecification.inputSpecification.InputSpecificationPackage
import nl.esi.comma.signature.interfaceSignature.Command
import nl.esi.comma.signature.utilities.InterfaceUtilities
import nl.esi.comma.types.utilities.CommaUtilities
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference

import static org.eclipse.xtext.scoping.Scopes.*
import org.eclipse.xtext.scoping.IScope
import nl.esi.comma.inputspecification.inputSpecification.Tail

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class InputSpecificationScopeProvider extends AbstractInputSpecificationScopeProvider {
	override getScope(EObject context, EReference reference) {

		/*if (context instanceof EventData && reference == InputSpecificationPackage.Literals.EVENT_DATA__STATE) {
			return scope_State(context as EventData, reference)
		}

		if (context instanceof Body && reference == InputSpecificationPackage.Literals.BODY__EVENT) {
			return scope_Event(context as Body, reference)
		}*/

		if (context instanceof Tail && reference == InputSpecificationPackage.Literals.TAIL__NI_EVENT) {
			return scope_Event(context as Tail, reference)
		}
		
		// In Progress DB
		/*if(context instanceof EventData && reference == InputSpecificationPackage.Literals.EVENT_DATA__INSTANCE) {
			return scope_Event_Instance(context as EventData, reference)
		}*/
		
		/*if(context instanceof EventData && reference == InputSpecificationPackage.Literals.EVENT_DATA__CLAUSE) {
			return scope_Event_Clause(context as EventData, reference)
		}*/
				
		return super.getScope(context, reference);
	}

	/*def scope_State(EventData body, EReference reference) {
		val machines = CommaUtilities::resolveProxy(body,
			getScope(body, BehaviorPackage.Literals.ABSTRACT_BEHAVIOR__MACHINES).getAllElements)
		var listOfStates = new ArrayList<State>

		for (m : machines)
			listOfStates.addAll((m as StateMachine).states)
		return scopeFor(listOfStates)
	}

	def scope_Event(Body body, EReference reference) {
		val intf = CommaUtilities::resolveProxy(body,
			getScope(body, ExpressionPackage.Literals.INTERFACE_AWARE_TYPE__INTERFACE).getAllElements)
		if(intf.empty) {
			return IScope.NULLSCOPE
		} else {
			return scopeFor(InterfaceUtilities::getAllInterfaceEvents(intf.head))
		}		
	}*/

	def scope_Event(Tail tail, EReference reference) {
		val intf = CommaUtilities::resolveProxy(tail,
			getScope(tail, ExpressionPackage.Literals.INTERFACE_AWARE_TYPE__INTERFACE).getAllElements)
		if(intf.empty) {
			return IScope.NULLSCOPE
		} else {
			return scopeFor(InterfaceUtilities::getAllInterfaceEvents(intf.head))
		}		
	}


	// In progress: DB
	def static HashMap<String, ArrayList<Transition>> getCommandsMapForState(StateMachine sm, State s) 
	{
		var commands_map = new HashMap<String, ArrayList<Transition>>
		var ArrayList<Transition> list_of_command_transitions
		
		for(transition : StateMachineUtilities::transitionsForState(sm, s)) 
		{
			// if(transition.trigger !== null)
			if(transition instanceof TriggeredTransition) 
			{
				if(transition.trigger instanceof Command) 
				{
					val transitionName = transition.trigger.name
					if(commands_map.containsKey(transitionName)) {
						list_of_command_transitions = commands_map.get(transitionName) }
					else {
						list_of_command_transitions = new ArrayList<Transition> }

					list_of_command_transitions.add(transition)
					commands_map.put(transitionName, list_of_command_transitions)
				}
			}
		}
		
		commands_map
	}
	
	// In Progress: DB	
	//var SimpleAnyType wrapper = XMLTypeFactory.eINSTANCE.createSimpleAnyType();
	//wrapper.setInstanceType(EcorePackage.eINSTANCE.getEInt());
	//wrapper.setValue(new Integer(42));
	/*
	def scope_Event_Instance(EventData data, EReference reference) {
		val machines = CommaUtilities::resolveProxy(data, 
			getScope(data, BehaviorPackage.Literals.ABSTRACT_BEHAVIOR__MACHINES).getAllElements)
		// how to determine which event this is?
		val body = EcoreUtil2.getContainerOfType(data, Body);
		System.out.println("Test SCOPE (event name): "+body.event.name)
		System.out.println("Test SCOPE (state name): "+data.state.name)
		
		var listOfStates = new ArrayList<TriggeredTransition>
		for(m : machines)
		{
			for(s : (m as StateMachine).states) {
				var idx = 0
				var command_map = getCommandsMapForState(m, s)
				if(command_map.containsKey(body.event.name)) {
					for(evt : command_map.get(body.event.name)) {
						idx++
						listOfStates.add(evt as TriggeredTransition)
						System.out.println("Test SCOPE (transition): "+(evt as TriggeredTransition).trigger.name)
					}
				}
			}
		}
		return scopeFor(listOfStates)
	}*/

	/*def scope_Event_Clause(EventData data, EReference reference) {
		val machines = CommaUtilities::resolveProxy(data, 
			getScope(data, BehaviorPackage.Literals.ABSTRACT_BEHAVIOR__MACHINES).getAllElements)
	}*/
}
