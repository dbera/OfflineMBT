/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.project.standard.generator

import nl.asml.matala.product.generator.ProductGenerator
import nl.asml.matala.product.product.Product
import nl.esi.comma.project.standard.standardProject.OfflineGenerationBlock
import nl.esi.comma.project.standard.standardProject.OfflineGenerationTarget
import nl.esi.comma.project.standard.standardProject.Project
import nl.esi.comma.project.standard.standardProject.TargetConfig
import nl.esi.comma.testspecification.generator.FromAbstractToConcrete
import nl.esi.comma.testspecification.generator.FromConcreteToFast
import nl.esi.comma.testspecification.generator.MergeConcreteDataAssigments
import nl.esi.comma.types.types.Import
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension nl.esi.comma.types.utilities.EcoreUtil3.*
import static extension nl.esi.comma.types.utilities.FileSystemAccessUtil.*
import java.util.HashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StandardProjectGenerator extends AbstractGenerator {
    override doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
        for (project : res.contents.filter(Project)) {
            for (task : project.offlineBlocks) {
                doGenerate(task, res.resourceSet, fsa.createFolderAccess(task.name), ctx)
            }

            for (task : project.statemachineBlocks) {
                (new StateMachineGenerator()).doGenerate(task, fsa.createFolderAccess(task.name), ctx)
            }
        }
    }

    def doGenerate(OfflineGenerationBlock task, ResourceSet rst, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
        val productURI = if (task.bpmn.nullOrEmpty) {
            task.eResource.resolveUri(task.product)
        } else {
            val bpmnUri = task.eResource.resolveUri(task.bpmn)
            val simulator = (task.target == OfflineGenerationTarget::SIMULATOR)
            val numTests = task.numTests <= 0 ? 1 : task.numTests
            val depthLimit = task.depthLimit <= 0 ? 300 : task.depthLimit
            val pspecFsa = fsa.createFolderAccess('pspec')

            (new Bpmn4sToPspecGenerator(simulator, numTests, depthLimit))
                .doGenerate(rst, bpmnUri, pspecFsa, ctx)

            pspecFsa.getURI(bpmnUri.trimFileExtension.appendFileExtension('ps').lastSegment)
        }

        // Load and validate the (generated) product
        val productRes = rst.getResource(productURI, true)
        val product = productRes.contents.filter(Product).findFirst[specification !== null]
        if (product === null) {
            throw new Exception('No product found in resource: ' + productURI)
        }
        productRes.resolveAll()
        product.imports.forEach[productRes.getResource(importURI).validate()]
        productRes.validate()

        // PspecToPetriNetGenerator
        // Generate CPNServer (a.k.a. abstract Tspec generator) and Petri-nets
        (new ProductGenerator).doGenerate(productRes, fsa, ctx)

        if (task.target == OfflineGenerationTarget.SIMULATOR) {
            return
        }

        // Generate abstract tspec from petri-net
        val petriNetURI = fsa.getURI('''CPNServer/«product.specification.name»/«product.specification.name».py''')
        val absTspecFsa = fsa.createFolderAccess('tspec_abstract')
        (new PetriNetToAbstractTspecGenerator(task.pythonExe)).doGenerate(rst, petriNetURI, absTspecFsa, ctx)

        for (absTspecFileName : absTspecFsa.list(ROOT_PATH).filter[endsWith('.tspec')]) {
            val absTspecRes = absTspecFsa.loadResource(absTspecFileName, rst)

            // Fix the pspec import
            val productImportURI = productURI.deresolve(absTspecRes.URI)
            absTspecRes.allContents.filter(Import).filter[importURI == productURI.lastSegment].forEach [
                importURI = productImportURI.toString
            ]
            absTspecRes.save(null)
            // Validate the generated abstract tspec
            absTspecRes.validate()


            // Generate concrete tspec
            val conTspecFsa = fsa.createFolderAccess('tspec_concrete')

            val renamingRules = task.renamingRules !== null? createPropertiesMap(task.renamingRules): new HashMap()
            val generatorParams = task.generatorParams !== null? createPropertiesMap(task.generatorParams): new HashMap()
            val fromAbstractToConcreteGen = new FromAbstractToConcrete(renamingRules, generatorParams)
            fromAbstractToConcreteGen.doGenerate(absTspecRes, conTspecFsa, ctx)

            val conTspecRes = conTspecFsa.loadResource(absTspecFileName, rst)
            MergeConcreteDataAssigments.transform(conTspecRes)
            conTspecRes.save(null)
            conTspecRes.validate()

            if (task.target == OfflineGenerationTarget.FAST) {
                // Generate FAST testcases
                val fastFsa = fsa.createFolderAccess('FAST')
                fromAbstractToConcreteGen.doGenerateFAST(absTspecRes, fastFsa, ctx)
                (new FromConcreteToFast()).doGenerate(conTspecRes, fastFsa, ctx)
            }
        }
    }

    def createPropertiesMap(TargetConfig tgtConfig) {
        var props = new HashMap<String, String>()
        for (elem : tgtConfig.item) {
        	props.put(elem.key,elem.^val)
        }
        return props
    }

}
