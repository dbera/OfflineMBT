/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.project.standard.generator

import nl.asml.matala.product.generator.ProductGenerator
import nl.asml.matala.product.product.Product
import nl.esi.comma.project.standard.standardProject.Project
import nl.esi.comma.testspecification.generator.FromAbstractToConcrete
import nl.esi.comma.testspecification.generator.TestspecificationGenerator
import nl.esi.comma.testspecification.testspecification.AbstractTestDefinition
import nl.esi.comma.testspecification.testspecification.TSMain
import nl.esi.comma.types.types.Import
import org.eclipse.emf.common.util.BasicDiagnostic
import org.eclipse.emf.common.util.Diagnostic
import org.eclipse.emf.common.util.DiagnosticException
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.Diagnostician
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension nl.esi.comma.project.standard.generator.FileSystemAccessUtil.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StandardProjectGenerator extends AbstractGenerator {
    override doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
        val resourceSet = res.resourceSet

        for (productCfg : res.contents.filter(Project).flatMap[products]) {
            val productFsa = fsa.createFolderAccess(productCfg.taskname)

            var productURI = URI.createURI(productCfg.product).resolve(res.URI)
            val productName = productURI.trimFileExtension.lastSegment
            val productFileName = '''«productName».ps'''
            val outputPath = productName

            // TODO: Don't detect file extension, but introduce new syntax keyword for bpmn input
            if ('bpmn'.equalsIgnoreCase(productURI.fileExtension)) {
                val pspecFsa = productFsa.createFolderAccess('pspec')

                (new Bpmn4sToPspecGenerator(productCfg.simulator))
                    .doGenerate(resourceSet, productURI, pspecFsa, ctx)

                productURI = pspecFsa.getURI(productFileName)
            }

            // Load and validate the (generated) product
            val productRes = resourceSet.getResource(productURI, true)
            val product = productRes.contents.filter(Product).findFirst[specification !== null]
            if (product === null) {
                throw new Exception('No product found in resource: ' + productURI)
            }
            validate(product)

            // PspecToPetriNetGenerator
            // Generate CPNServer (a.k.a. abstract Tspec generator) and Petri-nets
            (new ProductGenerator).doGenerate(productRes, productFsa, ctx)

            if (!productCfg.simulator) {
                // Generate abstract tspec from petri-net
                val petriNetURI = productFsa.getURI('''CPNServer/«product.specification.name»/«product.specification.name».py''')
                val absTspecFsa = productFsa.createFolderAccess('tspec_abstract')
                (new PetriNetToAbstractTspecGenerator()).doGenerate(resourceSet, petriNetURI, absTspecFsa, ctx)

                val conTspecFsa = productFsa.createFolderAccess('tspec_concrete')
                val fastFsa = productFsa.createFolderAccess('FAST')

                for (absTspecFileName : absTspecFsa.list(ROOT_PATH).filter[endsWith('.tspec')]) {
                    val absTspecRes = absTspecFsa.loadResource(absTspecFileName, resourceSet)

                    // Fix the pspec import
                    val productImportURI = productURI.deresolve(absTspecRes.URI)
                    absTspecRes.allContents.filter(Import).filter[importURI == productFileName].forEach [
                        importURI = productImportURI.toString
                    ]
                    absTspecRes.save(null)

                    // Generate concrete tspec
                    val typesImports = TestspecificationGenerator.getTypesImports(absTspecRes)
                    for (absTestDef : absTspecRes.contents.filter(TSMain).map[model].filter(AbstractTestDefinition)) {
                        val atd = new FromAbstractToConcrete(absTestDef)
                        for (sys : atd.getSystems()) {
                            conTspecFsa.generateFile('''types/«sys».types''',
                                atd.generateTypesFile(sys, typesImports))
                            conTspecFsa.generateFile('''parameters/«sys».params''',
                                atd.generateParamsFile(sys))
                        }
                        conTspecFsa.generateFile('''«absTspecFileName»''', atd.generateConcreteTest())
//                        conTspecFsa.generateFile('''data.kvp''', atd.__generateConcreteTest())

                        // Generate FAST testcases
                        (new ConcreteToFastGenerator()).doGenerate(conTspecFsa.loadResource(absTspecFileName, resourceSet), fastFsa, ctx)
                    }
                }
            }
        }
    }

    def void validate(EObject eObject) {
        val result = Diagnostician.INSTANCE.validate(eObject)
        if (result.severity == Diagnostic.ERROR) {
            val details = result.children.filter[severity == Diagnostic.ERROR].map['''- «message»'''].join('\n')
            throw new Exception(result.message + '\n' + details, new DiagnosticException(result));
        }
    }

    def void validate(Resource resource) {
        val result = new BasicDiagnostic(class.name, 0, 'Validation of ' + resource.URI, #[resource]);
        resource.contents.forEach[Diagnostician.INSTANCE.validate(it, result)]
        if (result.severity == Diagnostic.ERROR) {
            val details = result.children.filter[severity == Diagnostic.ERROR].map['''- «message»'''].join('\n')
            throw new Exception(result.message + '\n' + details, new DiagnosticException(result));
        }
    }
}
