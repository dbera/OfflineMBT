/**
 * Copyright (c) 2024, 2025 TNO-ESI
 * 
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 * 
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 * 
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.project.standard.generator

import java.util.HashMap
import nl.asml.matala.product.generator.ProductGenerator
import nl.asml.matala.product.product.Product
import nl.esi.comma.abstracttestspecification.generator.to.concrete.FromAbstractToConcrete
import nl.esi.comma.project.standard.standardProject.OfflineGenerationBlock
import nl.esi.comma.project.standard.standardProject.OfflineGenerationTarget
import nl.esi.comma.project.standard.standardProject.Project
import nl.esi.comma.project.standard.standardProject.TargetConfig
import nl.esi.comma.testspecification.generator.to.fast.FromConcreteToFast
import nl.esi.comma.testspecification.generator.utils.MergeConcreteDataAssigments
import nl.esi.comma.types.types.Import
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension nl.esi.comma.types.utilities.EcoreUtil3.*
import static extension nl.esi.comma.types.utilities.FileSystemAccessUtil.*
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StandardProjectGenerator extends AbstractGenerator {
    override doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
        for (project : res.contents.filter(Project)) {
            for (task : project.offlineBlocks) {
                doGenerate(task, res.resourceSet, fsa.createFolderAccess(task.name), ctx)
            }

            for (task : project.statemachineBlocks) {
                (new StateMachineGenerator()).doGenerate(task, fsa.createFolderAccess(task.name), ctx)
            }
        }
    }

    def doGenerate(OfflineGenerationBlock task, ResourceSet rst, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
        val productURI = if (task.bpmn.nullOrEmpty) {
                task.eResource.resolveUri(task.product)
            } else {
                val bpmnUri = task.eResource.resolveUri(task.bpmn)
                val simulator = (task.target == OfflineGenerationTarget::SIMULATOR)
                val numTests = task.numTests <= 0 ? 1 : task.numTests
                val depthLimit = task.depthLimit <= 0 ? 300 : task.depthLimit
                val pspecFsa = fsa.createFolderAccess('pspec')

                (new Bpmn4sToPspecGenerator(simulator, numTests, depthLimit)).doGenerate(rst, bpmnUri, pspecFsa, ctx)

                pspecFsa.getURI(bpmnUri.trimFileExtension.appendFileExtension('ps').lastSegment)
            }

        // Load and validate the (generated) product
        val productRes = rst.getResource(productURI, true)
        val product = productRes.contents.filter(Product).findFirst[specification !== null]
        if (product === null) {
            throw new Exception('No product found in resource: ' + productURI)
        }
        productRes.resolveAll()
        product.imports.forEach[productRes.getResource(importURI).validate()]
        productRes.validate()

        // PspecToPetriNetGenerator
        // Generate CPNServer (a.k.a. abstract Tspec generator) and Petri-nets
        (new ProductGenerator).doGenerate(productRes, fsa, ctx)

        if (task.target == OfflineGenerationTarget.SIMULATOR) {
            return
        }

        // Generate abstract tspec from petri-net
        val specName = product.specification.name
        val petriNetURI = fsa.getURI('''CPNServer/«specName»/«specName».py''')
        val absTspecFsa = fsa.createFolderAccess('tspec_abstract')
        (new PetriNetToAbstractTspecGenerator(task.pythonExe)).doGenerate(rst, petriNetURI, absTspecFsa, ctx)

        for (absTspecFileName : absTspecFsa.list(ROOT_PATH).filter[endsWith('.atspec')]) {
            val tspecName = absTspecFileName.replaceAll('\\.atspec$', '')
            val absTspecRes = absTspecFsa.loadResource(absTspecFileName, rst)

            // Fix the pspec import
            val productImportURI = productURI.deresolve(absTspecRes.URI)
            absTspecRes.allContents.filter(Import).filter[importURI == productURI.lastSegment].forEach [
                importURI = productImportURI.toString
            ]
            absTspecRes.save(null)
            // Validate the generated abstract tspec
            absTspecRes.validate()

            // Generate concrete tspec
            val conTspecFsa = fsa.createFolderAccess('tspec_concrete/' + tspecName)
            val fromAbstractToConcreteGen = new FromAbstractToConcrete()
            fromAbstractToConcreteGen.doGenerate(absTspecRes, conTspecFsa, ctx)

            val conTspecFileName = tspecName + '.tspec'
            val conTspecRes = conTspecFsa.loadResource(conTspecFileName, rst)
            //TODO Uncomment this once Yuri fixes merging
            //MergeConcreteDataAssigments.transform(conTspecRes)
            conTspecRes.save(null)
            conTspecRes.validate()

            if (task.target == OfflineGenerationTarget.FAST) {
                // TODO fetch these FAST configuration parameters from somewhere else (e.g., .prj task)
                val renamingRules = task.renamingRules !== null ? createPropertiesMap(task.renamingRules) : new HashMap
                val genParams = task.generatorParams !== null ? createPropertiesMap(task.generatorParams) : new HashMap
                genParams.put('prefixPath', './vfab2_scenario/FAST/testcases/' + specName + '_' + tspecName + '/') // TODO fetch this from somewhere else
                // Generate FAST testcase
                val fromConcreteToFastGen = new FromConcreteToFast(renamingRules, genParams)
                fromConcreteToFastGen.doGenerate(conTspecRes, fsa, ctx)
            }
        }
    }

    def createPropertiesMap(TargetConfig tgtConfig) {
        var props = new HashMap<String, String>()
        for (elem : tgtConfig.item) {
            props.put(elem.key, elem.^val)
        }
        return props
    }

}
