/**
 * Copyright (c) 2024, 2025 TNO-ESI
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available
 * under the terms of the MIT License which is available at
 * https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 */
/*
 * generated by Xtext 2.10.0
 */
package nl.esi.comma.signature.validation

import com.google.inject.Inject
import nl.esi.comma.signature.comments.InterfaceEventComment
import nl.esi.comma.signature.interfaceSignature.DIRECTION
import nl.esi.comma.signature.interfaceSignature.InterfaceEvent
import nl.esi.comma.signature.interfaceSignature.InterfaceSignatureDefinition
import nl.esi.comma.signature.interfaceSignature.InterfaceSignaturePackage
import nl.esi.comma.signature.interfaceSignature.Notification
import nl.esi.comma.signature.interfaceSignature.Signal
import nl.esi.comma.signature.interfaceSignature.Signature
import nl.esi.xtext.common.lang.base.BasePackage
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.documentation.IEObjectDocumentationProvider
import org.eclipse.xtext.validation.Check

import static extension nl.esi.comma.signature.utilities.InterfaceUtilities.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */

class InterfaceSignatureValidator extends AbstractInterfaceSignatureValidator {
	
	@Inject IEObjectDocumentationProvider documentationProvider
	
	/*
	 * Constraints:
	 * - the file name of the signature is different from the file names of the imported type models
	 */
	@Check
	def checkNamesImportedTypeModels(InterfaceSignatureDefinition root){
		val sigFilename = root.eResource.URI.trimFileExtension.lastSegment
		for(import : root.imports){
			val importedFilename = URI.createURI(import.importURI).trimFileExtension.lastSegment
			if(importedFilename.equals(sigFilename))
				error("Imported type file should have a different name than the current signature file.", import, BasePackage.Literals.IMPORT__IMPORT_URI)
		}
	}
	
	/*
	 * Constraints:
	 * - type definitions in the signature have unique names
	 */	
	@Check
	def checkDuplicatedTypeNamesInInterface(Signature s){
			checkForNameDuplications(s.types, "type declaration", null)
	}
	
	/*
	 * Constraints:
	 * - imported type definitions have unique names
	 * - local type definitions do not duplicate imported type definitions
	 * - interface event names do not duplicate type names
	 */
	@Check
    def checkLocalTypesForDuplications(InterfaceSignatureDefinition decl) {
        val importedTypes = checkDuplicationsInImportedTypes(decl)
        val events = decl.signature.getAllInterfaceEvents

        for (tLocal : decl.signature.types) {
            // Check if the local type duplicates an imported type
            if (!importedTypes.add(tLocal.name)) {
                error("Type with the same name is already imported", tLocal, BasePackage.Literals.NAMED_ELEMENT__NAME)
            }
        }
        for (ev : events) {
            // Check if the interface event has a name that duplicates type name
            if (importedTypes.contains(ev.name)) {
                error("Interface event duplicates type name", ev, BasePackage.Literals.NAMED_ELEMENT__NAME)
            }
        }
    }
	
	/*
	 * Constraints:
	 * - parameter names of interface events are unique
	 */
	@Check
	def checkDuplicatedParameters(InterfaceEvent e){
		checkForNameDuplications(e.parameters, "parameter", null)
	}
	
	/*
	 * Constraints:
	 * - only commands may have inout and out parameters
	 */
	@Check
	def checkParameterDirection(InterfaceEvent e){
		if(e instanceof Notification || e instanceof Signal){
			for(p : e.parameters){
				if(p.direction != DIRECTION::IN)
					error('Direction of parameters in notifications and signals must be IN', 
						InterfaceSignaturePackage.Literals.INTERFACE_EVENT__PARAMETERS, 
						e.parameters.indexOf(p)
					)
			}
		}
	}
	
	/*
	 * Constraints:
	 * - interface event names are unique in the context of the signature
	 */
	@Check
	def checkDuplicatedInterfaceEvents(Signature s) {
		checkForNameDuplications(s.getAllInterfaceEvents, "interface event", null)
	}
	
	/*
	 * Constraints:
	 * - interface events are properly documented by using comments:
	 *   descriptions of: the event, the parameters, the returned value if any
	 */
	@Check
	def checkComment(InterfaceEvent ev){
		val InterfaceEventComment evComment = new InterfaceEventComment(ev, documentationProvider.getDocumentation(ev))
		if(!evComment.valid){
			warning(evComment.errorMessage, ev, BasePackage.Literals.NAMED_ELEMENT__NAME)
		}
	}
	
	/*
	 * Constraints:
	 * - void type can only be used as a return type of commands
	 */
//	@Check
//	override checkForVoidType(Type t){
//		if(t.type instanceof SimpleTypeDecl && (t.type.name.equals("void"))){
//			if( !(t.eContainer instanceof Command) )
//				error("Usage of type void is not allowed", TypesPackage.Literals.TYPE__TYPE)
//		}
//	}
	
	/*
	 * Constraints.
	 * The following constraints are inherited from the language for type definitions:
	 * - any type is not allowed to be directly used
	 * - imports have valid URIs and are type models
	 */
}
