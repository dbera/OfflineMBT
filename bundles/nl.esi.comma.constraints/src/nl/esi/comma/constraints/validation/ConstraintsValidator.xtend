/*
 * generated by Xtext 2.19.0
 */
package nl.esi.comma.constraints.validation

import com.google.inject.Inject
import com.google.inject.Provider
import java.io.File
import java.io.FileFilter
import java.io.FilenameFilter
import java.util.ArrayList
import java.util.HashSet
import java.util.List
import java.util.Set
import nl.esi.comma.constraints.constraints.Act
import nl.esi.comma.constraints.constraints.ActSequenceDef
import nl.esi.comma.constraints.constraints.ActionData
import nl.esi.comma.constraints.constraints.Constraints
import nl.esi.comma.constraints.constraints.ConstraintsPackage
import nl.esi.comma.constraints.constraints.DataTable
import nl.esi.comma.constraints.constraints.ExampleCell
import nl.esi.comma.constraints.constraints.Import
import nl.esi.comma.constraints.constraints.Ref
import nl.esi.comma.constraints.constraints.RefActSequence
import nl.esi.comma.constraints.constraints.RefAction
import nl.esi.comma.constraints.constraints.RefStep
import nl.esi.comma.constraints.constraints.RefStepSequence
import nl.esi.comma.constraints.constraints.StepSequenceDef
import nl.esi.comma.steps.step.Steps
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import nl.esi.comma.constraints.constraints.Action
import nl.esi.comma.constraints.constraints.Init
import nl.esi.comma.constraints.constraints.ActionType
import nl.esi.comma.constraints.constraints.Existential

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ConstraintsValidator extends AbstractConstraintsValidator {
	
	@Inject extension Provider<ResourceSet> resourceSetProvider
	Set<RefStepSequence> refStepSeq = new HashSet<RefStepSequence>
	Set<RefActSequence> refActSeq = new HashSet<RefActSequence>
	Set<Act> refAct = new HashSet<Act>
	Set<RefStep> refStep = new HashSet<RefStep>
	
	@Check
	def checkImportForValidity(Import imp){
		if (! EcoreUtil2.isValidUri(imp, URI.createURI(imp.importURI))){
			error("Invalid resource", imp, ConstraintsPackage.eINSTANCE.import_ImportURI)
		} else {
			val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
			val root = r.allContents.head
			if (! (root instanceof Steps || root instanceof Constraints) )
				error("The imported resource is not a valid step or constraints definition.", imp,
					ConstraintsPackage.eINSTANCE.import_ImportURI)
		}
	}
	
	@Check
	def checkActionData(Act act) {
		if (act.dataRow.size > 0){
			var dataRow = act.dataRow
			if (act.act.data.size > 0) {
				var dataTable = act.act.data.get(0)
				if (!validateData(dataTable, dataRow)){
					error('Action Data is not valid. Please check the data table.', ConstraintsPackage.eINSTANCE.act_Act)
				}
			} else {
				error('The Action does not have any data.', ConstraintsPackage.eINSTANCE.act_Act)
			}
		}
	}
	
	@Check
	def checkStepSequenceIsEmpty(StepSequenceDef sseq){
		if (sseq.stepList.size == 0){
			warning('The step sequence is empty.', ConstraintsPackage.eINSTANCE.stepSequenceDef_Name)
		}
	}
	
	@Check
	def checkActSequenceIsEmpty(ActSequenceDef aseq){
		if (aseq.actList.size == 0){
			warning('The action sequence is empty.', ConstraintsPackage.eINSTANCE.actSequenceDef_Name)
		}
	}
	
	/* warning on unused Action */
	@Check
	def checkActionIsUsed(Constraints constraints){
		val sclmodels = getAllRootModelFromProject(constraints)
		val refList = newHashSet
		// check local ref
		EcoreUtil2.getAllContentsOfType(constraints, RefAction).forEach[
			refList.add(it.act.act.name)
		]
		// ref in action sequence
		EcoreUtil2.getAllContentsOfType(constraints, ActSequenceDef).forEach[
			it.actList.forEach[ref|
				refList.add(ref.act.name)
			]
		]
		//check import models
		if (!refAct.nullOrEmpty) {
			refAct.toList.forEach[ref|
				if (ref.act.name !== null){
					refList.add(ref.act.name)
				} else {
					if (!sclmodels.nullOrEmpty){
						sclmodels.toList.forEach[
							var refAct = EcoreUtil.resolve(ref, it) as Act
							if (refAct.act.name !== null){
								refList.add(refAct.act.name)
							}
							EcoreUtil2.getAllContentsOfType(it, ActSequenceDef).forEach[
								it.actList.forEach[act|
									refList.add(act.act.name)
								]
							]
						]
					}
					
				}
			]
			
		}
		
		constraints.actions.forEach[
			act.forEach[
				if (!refList.contains(it.name)) {
					warning("Unused action: " + it.name, it, ConstraintsPackage.eINSTANCE.action_Name,
						"unused_action", it.name)
				}
			]
		]
	}
	
	/* warning on unused Step Sequence */
	@Check
	def checkStepSequenceIsUsed(Constraints constraints){
		val sclmodels = getAllRootModelFromProject(constraints)
		val refList = newHashSet
		if (!refStepSeq.nullOrEmpty) {
			refStepSeq.toList.forEach[ref|
				if (ref.seq.name !== null){
					refList.add(ref.seq.name)
				} else {
					if (!sclmodels.nullOrEmpty){
						sclmodels.toList.forEach[
							var refSseq = EcoreUtil.resolve(ref, it) as RefStepSequence
							if (refSseq.seq.name !== null){
								refList.add(refSseq.seq.name)
							}
						]
					}
				}
			]
		}
		
		constraints.ssequences.forEach[
			if (!refList.contains(it.name)) {
				warning("Unused step sequence: " + it.name, it, ConstraintsPackage.eINSTANCE.stepSequenceDef_Name,
						"unused_step_sequence", it.name)}
		]
	}
	
	/* warning on unused Action Sequence */
	@Check
	def checkActSequenceIsUsed(Constraints constraints){
		val sclmodels = getAllRootModelFromProject(constraints)
		val refList = newHashSet
		if (!refActSeq.nullOrEmpty) {
			refActSeq.toList.forEach[ref|
				if (ref.seq.name !== null){
					refList.add(ref.seq.name)
				} else {
					if (!sclmodels.nullOrEmpty){
						sclmodels.toList.forEach[
							var refAseq = EcoreUtil.resolve(ref, it) as RefActSequence
							if (refAseq.seq.name !== null){
								refList.add(refAseq.seq.name)
							}
						]
					}
				}
			]
		}
		
		constraints.asequences.forEach[
			if (!refList.contains(it.name)) {
				warning("Unused action sequence: " + it.name, it, ConstraintsPackage.eINSTANCE.actSequenceDef_Name,
						"unused_act_sequence", it.name)}
		]
	}
	
	/* warning for step already exists in sequence, user may use the sequence instead of the step  */
	@Check
	def checkStepUsedInSequence(Constraints constraints){
		val Set<RefStep> usedSteps = new HashSet<RefStep>()
		var warning = false
		var Set<String> sseqs = newHashSet
		var sclmodels = getAllRootModelFromProject(constraints)
		EcoreUtil2.getAllContentsOfType(constraints, RefStep).forEach[usedSteps.add(it)]
		for (step : usedSteps){
			if (!sclmodels.nullOrEmpty){
				for (model : sclmodels){
					for (sseq : model.ssequences){
						for (s : sseq.stepList){
							if (s.name.equals(step.step.name)){
								warning = true
								sseqs.add(sseq.name)
							}
						}
					}
				}
			}
			if (warning){
				var message = "The step <" + step.step.name + "> is used in the following Step Sequence\r\n"
				for(sseq : sseqs){
					message += sseq + "\r\n"
				}
				warning(message, step, ConstraintsPackage.eINSTANCE.refStep_Step,
							"step_seq_defined", "")
			}
			warning = false
		}
	}
	
	/* warning for action already exists in sequence, user may use the sequence instead of the action  */
	@Check
	def checkActUsedInSequence(Constraints constraints){
		val Set<RefAction> usedActions = new HashSet<RefAction>()
		var warning = false
		var Set<String> aseqs = newHashSet
		var sclmodels = getAllRootModelFromProject(constraints)
		EcoreUtil2.getAllContentsOfType(constraints, RefAction).forEach[usedActions.add(it)]
		for (action : usedActions){
			if (!sclmodels.nullOrEmpty){
				for (model : sclmodels){
					for (aseq : model.asequences){
						for (act : aseq.actList){
							if (act.act.name.equals(action.act.act.name)){
								warning = true
								aseqs.add(aseq.name)
							}
						}
					}
				}
			}
			if (warning){
				var message = "The action <" + action.act.act.name + "> is used in the following Action Sequence\r\n"
				for(aseq : aseqs){
					message += aseq + "\r\n"
				}
				warning(message, action, ConstraintsPackage.eINSTANCE.refAction_Act,
							"act_seq_defined", "")
			}
			warning = false
		}
	}
	
	/*check duplicate names for step seq */
	@Check
	def checkDuplicateNameStepSequence(Constraints constraints){
		val Set<StepSequenceDef> sseqs = new HashSet<StepSequenceDef>()
		EcoreUtil2.getAllContentsOfType(constraints, StepSequenceDef).forEach[sseqs.add(it)]
		for (sseqDef: sseqs) {
			var index = 0
			if (!constraints.imports.nullOrEmpty){
				for (imp : constraints.imports){
					val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
					if (r !== null){
						val root = r.allContents.head
						if (root instanceof Constraints) {
							for (stepSeq : root.ssequences){
								if (sseqDef.name.equals(stepSeq.name)){
									index++
								}
							}
						}
					}
				}
			}
			if (index > 0){
				error('Duplicate names.', sseqDef, ConstraintsPackage.eINSTANCE.stepSequenceDef_Name)
			}
		}
	}
	/*check duplicate names for action seq */
	@Check
	def checkDuplicateNameActSequence(Constraints constraints){
		val Set<ActSequenceDef> aseqs = new HashSet<ActSequenceDef>()
		EcoreUtil2.getAllContentsOfType(constraints, ActSequenceDef).forEach[aseqs.add(it)]
		for (aseqDef: aseqs) {
			var index = 0
			if (!constraints.imports.nullOrEmpty){
				for (imp : constraints.imports){
					val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
					if (r !== null){
						val root = r.allContents.head
						if (root instanceof Constraints) {
							for (actSeq : root.asequences){
								if (aseqDef.name.equals(actSeq.name)){
									index++
								}
							}
						}
					}
				}
			}
			if (index > 0){
				error('Duplicate names.', aseqDef, ConstraintsPackage.eINSTANCE.actSequenceDef_Name)
			}
		}
	}
	/*check duplicate names for action */
	@Check
	def checkDuplicateNameAction(Constraints constraints){
		val Set<Action> actions = new HashSet<Action>()
		EcoreUtil2.getAllContentsOfType(constraints, Action).forEach[actions.add(it)]
		for(action:actions){
			var index = 0
			if (!constraints.imports.nullOrEmpty){
				for (imp : constraints.imports){
					val Resource r = EcoreUtil2.getResource(imp.eResource, imp.importURI)
					if (r !== null){
						val root = r.allContents.head
						if (root instanceof Constraints) {
							for (acts : root.actions){
								for(act: acts.act){
									if (act.name.equals(action.name)){
										index++
									}
								}
							}
						}
					}
				}
			}
			if (index > 0){
				error('Duplicate names.', action, ConstraintsPackage.eINSTANCE.action_Name)
			}
		}
	}
	
	def getAllRootModelFromProject(Constraints constraints) {
		refStepSeq = new HashSet<RefStepSequence>
		refActSeq = new HashSet<RefActSequence>
		refAct = new HashSet<Act>
		refStep = new HashSet<RefStep>
		var ArrayList<Constraints> constraintsModel = newArrayList
		val platformString = constraints.eResource.URI.toPlatformString(true);
		val file = ResourcesPlugin.workspace.root.findMember(platformString) as IFile
		val project = file.project
		val constraintsName = constraints.eResource.URI.toPlatformString(true).split("/").last
		
		for (member : project.members) {
			var ext = member.getFileExtension
			if (ext === null) {
				var uri = member.locationURI
				var dir = new File(uri)
				if (dir.exists && dir.isDirectory) {
					constraintsModel.addAll(getConstraintModelFromDir(dir, constraints, constraintsName))
				}
			}
			if ( ext !== null && ext.equals("constraints")){
				var path = member.getLocation().toString();
				var uri = URI.createFileURI(path)
				val res = resourceSetProvider.get.getResource(uri, true)
				if (res !== null && res.allContents.head instanceof Constraints) {
					constraintsModel.add(res.allContents.head as Constraints)
				}
			}
		}
		for (res : constraintsModel){
			EcoreUtil2.getAllContentsOfType(res, RefStepSequence).forEach[
				refStepSeq.add(it)
			]
			EcoreUtil2.getAllContentsOfType(res, RefActSequence).forEach[
				refActSeq.add(it)
			]
			EcoreUtil2.getAllContentsOfType(res, Act).forEach[
				refAct.add(it)
			]
			EcoreUtil2.getAllContentsOfType(res, RefStep).forEach[
				refStep.add(it)
			]
		}
		return constraintsModel
	}
	
	def getRelatedModelsFromProject(Constraints context) {
		var constraintsModel = new HashSet<Constraints>
		//add itself to the set
		constraintsModel.add(context)
		val platformString = context.eResource.URI.toPlatformString(true);
		val file = ResourcesPlugin.workspace.root.findMember(platformString) as IFile
		val project = file.project
		
		for (member : project.members) {
			var ext = member.getFileExtension
			if ( ext !== null && ext.equals("constraints")){
				var path = member.getLocation().toString();
				var uri = URI.createFileURI(path)
				val res = resourceSetProvider.get.getResource(uri, true)
				var model = res.allContents.head
				if (res !== null && model instanceof Constraints) {
					var constraintsName = (model as Constraints).eResource.URI.toString.split("/").last
					//consider imports
					for (imp : context.imports){
						var fileName = imp.importURI.split("/").last
						if (fileName.equals(constraintsName)){
							constraintsModel.add(res.allContents.head as Constraints)
						}
					}
				}
			}
			if (ext === null) {
				var uri = member.locationURI
				var dir = new File(uri)
				if (dir.exists && dir.isDirectory) {
					constraintsModel.addAll(getConstraintModelFromDir(dir, context))
				}
			}
		}
		return constraintsModel
	}
	
	def validateData(DataTable dataTable, List<ActionData> data){
		if(data.size !== dataTable.heading.cells.size){
			return false
		}
		for (row : dataTable.rows) {
			if(matchDataRow(row.cells, data)){
				return true
			}
		}
		return false
	}
	
	def matchDataRow(List<ExampleCell> cells, List<ActionData> data){
		for (var i =0; i<cells.size; i++){
			if (!cells.get(i).value.replaceAll("\\|","").replaceAll("\\s+", "").equals(data.get(i).value)){
				return false
			}
		}
		return true
	}
	
	def static resolveUri(Resource context, String path) {
		val contextURI = context.getURI();
		var uri = URI.createFileURI(path)
		if (contextURI.isHierarchical() && !contextURI.isRelative() && (uri.isRelative() && !uri.isEmpty())) {
			uri = uri.resolve(contextURI);
		}		
		return uri;
	}
	
	//for validation of usage, check all models that has imported the context
	def List<Constraints> getConstraintModelFromDir(File dir, Constraints context, String constraintsName){
		var ArrayList<Constraints> constraintsModel = new ArrayList<Constraints>
		val filter = new FilenameFilter() {
			override accept(File dir, String name) {
				(name.endsWith(".constraints"))
			}
		}
		var dirfilter = new FileFilter(){
			override accept(File file) {
				var isFile = file.isFile
				if (isFile) {
					return false
				} else {
					return true
				}
			}
		}
		for (file : dir.listFiles(filter)) {
			val res = context.eResource.resourceSet.getResource(URI.createFileURI(file.path), true)
			if(res !== null) {
				//check if the model has imported the context
				var model = res.allContents.head as Constraints
				for (imp : model.imports){
					var fileName = imp.importURI.split("/").last
					if (fileName.equals(constraintsName)){
						constraintsModel.add(res.allContents.head as Constraints)
					}
				}
			}
		}
		for (file : dir.listFiles(dirfilter)) {
			constraintsModel.addAll(getConstraintModelFromDir(file, context, constraintsName))
		}
		return constraintsModel
	}
	
	//for validation for duplicate names, check all model imported to the context
	def List<Constraints> getConstraintModelFromDir(File dir, Constraints context){
		var ArrayList<Constraints> constraintsModel = new ArrayList<Constraints>
		val filter = new FilenameFilter() {
			override accept(File dir, String name) {
				(name.endsWith(".constraints"))
			}
		}
		var dirfilter = new FileFilter(){
			override accept(File file) {
				var isFile = file.isFile
				if (isFile) {
					return false
				} else {
					return true
				}
			}
		}
		for (file : dir.listFiles(filter)) {
			val res = context.eResource.resourceSet.getResource(URI.createFileURI(file.path), true)
			if(res !== null) {
				//check if the context has imported the model
				var model = res.allContents.head as Constraints
				var constraintsName = model.eResource.URI.toString.split("/").last
				for (imp : context.imports){
					var fileName = imp.importURI.split("/").last
					if (fileName.equals(constraintsName)){
						constraintsModel.add(res.allContents.head as Constraints)
					}
				}
			}
		}
		for (file : dir.listFiles(dirfilter)) {
			constraintsModel.addAll(getConstraintModelFromDir(file, context))
		}
		return constraintsModel
	}
	
	//validation for initial action
	@Check
	def checkActionType(Constraints constraints){
	    if (constraints.actions.size > 0){
	        for(action : constraints.actions){
	            for(template: constraints.templates){
	                for(type: template.type){
	                    if(type instanceof Existential){
	                        for(subType:type.type){
	                            if(subType instanceof Init){
	                                for(ref:subType.ref){
	                                    if (ref instanceof RefAction){
                                            var act = action.act.get(0)
                                            if(ref.act.act.name.equals(act.name)){
                                                if (act.act.equals(ActionType.OBSERVABLE)||act.act.equals(ActionType.CONJUNCTION)){
                                                    error('Initial action should have either Pre-condition or Trigger as Type.', act, ConstraintsPackage.eINSTANCE.action_Name)
                                                }
                                            }
                                        }
	                                }
	                            }
	                        }	                
	                    }
	                }
	            }
	        }
	    }
	}
	
}
