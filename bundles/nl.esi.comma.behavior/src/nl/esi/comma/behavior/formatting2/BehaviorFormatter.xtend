/*
 * generated by Xtext 2.12.0
 */
package nl.esi.comma.behavior.formatting2

import com.google.inject.Inject
import nl.esi.comma.actions.actions.CommandReply
import nl.esi.comma.actions.formatting2.ActionsFormatter
import nl.esi.comma.behavior.behavior.AbstractBehavior
import nl.esi.comma.behavior.behavior.BracketFormula
import nl.esi.comma.behavior.behavior.Clause
import nl.esi.comma.behavior.behavior.ConditionalFollow
import nl.esi.comma.behavior.behavior.ConditionedAbsenceOfEvent
import nl.esi.comma.behavior.behavior.ConditionedEvent
import nl.esi.comma.behavior.behavior.Conjunction
import nl.esi.comma.behavior.behavior.Connector
import nl.esi.comma.behavior.behavior.ConstraintSequence
import nl.esi.comma.behavior.behavior.DataConstraint
import nl.esi.comma.behavior.behavior.DataConstraintEvent
import nl.esi.comma.behavior.behavior.DataConstraintUntilOperator
import nl.esi.comma.behavior.behavior.DataConstraintsBlock
import nl.esi.comma.behavior.behavior.Disjunction
import nl.esi.comma.behavior.behavior.ESDisjunction
import nl.esi.comma.behavior.behavior.EventInState
import nl.esi.comma.behavior.behavior.EventInterval
import nl.esi.comma.behavior.behavior.EventSelector
import nl.esi.comma.behavior.behavior.FollowUpEvent
import nl.esi.comma.behavior.behavior.GenericConstraint
import nl.esi.comma.behavior.behavior.GenericConstraintsBlock
import nl.esi.comma.behavior.behavior.GroupTimeConstraint
import nl.esi.comma.behavior.behavior.Implication
import nl.esi.comma.behavior.behavior.InAllStatesBlock
import nl.esi.comma.behavior.behavior.NegationFormula
import nl.esi.comma.behavior.behavior.NonTriggeredTransition
import nl.esi.comma.behavior.behavior.PeriodicEvent
import nl.esi.comma.behavior.behavior.ProvidedPort
import nl.esi.comma.behavior.behavior.RequiredPort
import nl.esi.comma.behavior.behavior.Sequence
import nl.esi.comma.behavior.behavior.SequenceElement
import nl.esi.comma.behavior.behavior.SingleTimeConstraint
import nl.esi.comma.behavior.behavior.State
import nl.esi.comma.behavior.behavior.StateMachine
import nl.esi.comma.behavior.behavior.TimeConstraint
import nl.esi.comma.behavior.behavior.TimeConstraintsBlock
import nl.esi.comma.behavior.behavior.TimeInterval
import nl.esi.comma.behavior.behavior.Transition
import nl.esi.comma.behavior.behavior.TriggeredTransition
import nl.esi.comma.behavior.services.BehaviorGrammarAccess
import nl.esi.comma.expressions.expression.Variable
import nl.esi.comma.types.types.Import
import nl.esi.comma.types.types.ModelContainer
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import nl.esi.comma.behavior.behavior.FeatureExpression

class BehaviorFormatter extends ActionsFormatter {
	
	@Inject extension BehaviorGrammarAccess
	
	def dispatch void format(ModelContainer modelContainer, extension IFormattableDocument document) {
		for (Import _import : modelContainer.imports) {
			_import.format;
		}
	}
	
	def dispatch void format(AbstractBehavior abstractBehavior, extension IFormattableDocument document) {		
		abstractBehavior.formatAbstractBehavior(document)
	}
	
	def formatAbstractBehavior(AbstractBehavior abstractBehavior, extension IFormattableDocument document) {
		for (variable : abstractBehavior.vars) {
			variable.prepend(newLine)
			variable.format;
		}
		for (action : abstractBehavior.initActions) {
			action.prepend(newLine)
			action.format;
		}
		abstractBehavior.fragments.forEach[
			pcFragmentDefinition |
			pcFragmentDefinition.prepend(newLine)
			pcFragmentDefinition.format
		]
		for (stateMachine : abstractBehavior.machines) {
			stateMachine.format;
		}
		abstractBehavior.timeConstraintsBlock?.format;
		abstractBehavior.dataConstraintsBlock?.format;
		abstractBehavior.genericConstraintsBlock?.format;
	}

	def dispatch void format(Import _import, extension IFormattableDocument document) {
		if (_import.regionForEObject.previousSemanticRegion === null) {
			if (this.textRegionExtensions.regionForEObject(_import).previousHiddenRegion.containsComment) {
				_import.prepend(newLine)
			} else {
				_import.prepend(noSpace)
			}
		} else {
			_import.prepend(newLine)
		}
		_import.regionFor.keyword(importAccess.importKeyword_0).append(oneSpace)
	}
	
	def dispatch void format(ProvidedPort providedPort, extension IFormattableDocument document) {
		val rFinder = providedPort.regionFor
		rFinder.keyword(providedPortAccess.providedKeyword_0).append(oneSpace)
		rFinder.keyword(providedPortAccess.portKeyword_1).append(oneSpace)
		rFinder.assignment(providedPortAccess.interfaceAssignment_2).append(oneSpace)
	}
	
	def dispatch void format(RequiredPort requiredPort, extension IFormattableDocument document) {
		val rFinder = requiredPort.regionFor
		rFinder.keyword(requiredPortAccess.requiredKeyword_0).append(oneSpace)
		rFinder.keyword(requiredPortAccess.portKeyword_1).append(oneSpace)
		rFinder.assignment(requiredPortAccess.interfaceAssignment_2).append(oneSpace)
	}

	def dispatch void format(StateMachine stateMachine, extension IFormattableDocument document) {
		val rFinder = stateMachine.regionFor
		stateMachine.prepend(emptyLine)

		rFinder.keyword(stateMachineAccess.machineKeyword_0).append(oneSpace)
		formatSimpleBrackets(rFinder, stateMachineAccess.leftCurlyBracketKeyword_2,
			stateMachineAccess.rightCurlyBracketKeyword_5, document)

		stateMachine.getInAllStates.forEach[format]
		for (State state : stateMachine.getStates()) {
			state.format;
		}
	}
		
	def dispatch void format(InAllStatesBlock allStates, extension IFormattableDocument document) {
		val rFinder = allStates.regionFor

		allStates.prepend(emptyLine)
		rFinder.keyword(inAllStatesBlockAccess.allKeyword_2).prepend(oneSpace)
		rFinder.keyword(inAllStatesBlockAccess.statesKeyword_3).prepend(oneSpace)
		
		val kwExcept = rFinder.keyword(inAllStatesBlockAccess.exceptKeyword_4_0)
		if(kwExcept !== null) {
			kwExcept.surround(oneSpace)			
			rFinder.keywords(inAllStatesBlockAccess.commaKeyword_4_2_0).forEach[prepend(noSpace).append(oneSpaceWrap)]
		}				
		
		formatSimpleBrackets(rFinder, inAllStatesBlockAccess.leftCurlyBracketKeyword_5,
			inAllStatesBlockAccess.rightCurlyBracketKeyword_7, document)

		for (Transition transition : allStates.transitions) {
			transition.format
		}
	}

	def dispatch void format(State state, extension IFormattableDocument document) {
		val rFinder = state.regionFor
		state.prepend(emptyLine)

		val kwState = rFinder.keyword(stateAccess.stateKeyword_1);
		if (state.isInitial) {
			kwState.prepend(oneSpace)
		}
		kwState.append(oneSpace)
		formatSimpleBrackets(rFinder, stateAccess.leftCurlyBracketKeyword_3, stateAccess.rightCurlyBracketKeyword_5,
			document)

		for (Transition transition : state.transitions) {
			transition.format
		}
	}
	
	def dispatch void format(TriggeredTransition transition, extension IFormattableDocument document) {
		val rFinder = transition.regionFor
		transition.prepend(emptyLine)
				
		val kwOr = rFinder.keywords(triggeredTransitionAccess.ORKeyword_7_0)
		val kwguard = rFinder.keyword(triggeredTransitionAccess.guardKeyword_4_0)

		if (transition.trigger !== null) {
			val kwTrigger = rFinder.keyword(triggeredTransitionAccess.triggerKeyword_1)
			kwTrigger.prepend(oneSpace)
			transition.trigger.prepend(oneSpace)			
		}
		
		for (Variable variable : transition.parameters) {
			variable.format
		}
		
		formatSimpleCommas(rFinder.keywords(triggeredTransitionAccess.commaKeyword_3_2_0), document)
		rFinder.keyword(triggeredTransitionAccess.leftParenthesisKeyword_3_0).prepend(noSpace)
		rFinder.keyword(triggeredTransitionAccess.rightParenthesisKeyword_3_3).prepend(noSpace)

		if (kwguard !== null) {
			kwguard.prepend(newLine)
			transition.guard.prepend(oneSpace)
			transition.guard.interior(doubleIndent)
			transition.guard.format
			document.set(kwguard.previousHiddenRegion, transition.clauses.last.nextHiddenRegion, (indent));
		} else if (kwOr.size != 0) {
			transition.clauses.indentList(document)
		}
		for (ISemanticRegion region : kwOr) {
			region.prepend(newLine)
		}

		transition.parameters
		for (Clause clause : transition.clauses) {
			clause.format
		}
		transition.configs.format
	}
	
	def dispatch void format(NonTriggeredTransition transition, extension IFormattableDocument document) {
		val rFinder = transition.regionFor
		transition.prepend(emptyLine)
		
		val kwOr = rFinder.keywords(nonTriggeredTransitionAccess.ORKeyword_4_0)
		val kwguard = rFinder.keyword(nonTriggeredTransitionAccess.guardKeyword_1_0)

		if (kwguard !== null) {
			kwguard.prepend(newLine)
			transition.guard.prepend(oneSpace)
			transition.guard.interior(doubleIndent)
			transition.guard.format
			document.set(kwguard.previousHiddenRegion, transition.clauses.last.nextHiddenRegion, (indent));
		} else if (kwOr.size != 0) {
			transition.clauses.indentList(document)
		}
		
		for (ISemanticRegion region : kwOr) {
			region.prepend(newLine)
		}

		for (Clause clause : transition.clauses) {
			clause.format
		}
		transition.configs.format
	}

	override dispatch void format(Variable variable, extension IFormattableDocument document) {		
		if(variable.type !== null && variable.name !== null) {
			variable.type.append(oneSpace)			
		}		
	}

	def dispatch void format(Clause clause, extension IFormattableDocument document) {
		val rFinder = clause.regionFor

		val kwDo = rFinder.keyword(clauseAccess.doKeyword_1_0)
		val kwNext = rFinder.keyword(clauseAccess.nextKeyword_2_0)
		kwDo.prepend(newLine)
		kwNext.prepend(newLine)

		rFinder.keyword(clauseAccess.stateKeyword_2_1).prepend(oneSpace).append(oneSpace)

		if (kwDo !== null) {
			document.set(kwDo.previousHiddenRegion, clause.nextHiddenRegion, (indent))
		} else {
			document.set(kwNext.previousHiddenRegion, clause.nextHiddenRegion, (indent))
		}

		if (clause.actions !== null) {
			for (var i = 0; i < clause.actions.actions.size; i++) {
				val cl = clause.actions.actions.get(i)
				if (i == 0 && !(cl instanceof CommandReply)) {
					cl.prepend(oneSpace)
				} else {
					cl.prepend(newLine)
				}
				cl.format
			}
		}
		clause.configs.format
	}
	
	def dispatch void format(FeatureExpression featureExpression, extension IFormattableDocument document) {
		val rFinder = featureExpression.regionFor
		val kwConfig = rFinder.keyword(featureExpressionAccess.featureExprKeyword_0)
		
		if (kwConfig !== null) {
			kwConfig.prepend(newLine)
			featureExpression.featureExpr.prepend(oneSpace)
			featureExpression.featureExpr.interior(indent)
		}
	}

	// --------------------- Constraints
	def dispatch void format(SingleTimeConstraint singleTimeConstraint, extension IFormattableDocument document) {
		singleTimeConstraint.prepend(newLine)
		singleTimeConstraint.constraint.prepend(oneSpace)
		singleTimeConstraint.constraint.format
	}

	def dispatch void format(GroupTimeConstraint groupTimeConstraint, extension IFormattableDocument document) {
		val rFinder = groupTimeConstraint.regionFor

		val group = rFinder.keyword(groupTimeConstraintAccess.groupKeyword_0)
		val end = rFinder.keyword(groupTimeConstraintAccess.endKeyword_4)

		group.prepend(emptyLine)
		end.prepend(newLine)
		rFinder.keyword(groupTimeConstraintAccess.groupKeyword_5).prepend(oneSpace)
		interior(group, end, (indent))

		groupTimeConstraint.first.prepend(newLine)

		groupTimeConstraint.first.format
		for (constraint : groupTimeConstraint.followups) {
			constraint.prepend(newLine)
			constraint.format
		}
	}

	def dispatch void format(FollowUpEvent followup,
		extension IFormattableDocument document) {
		val rFinder = followup.regionFor

		rFinder.keyword(followUpEventAccess.hyphenMinusKeyword_0).append(oneSpace)
		rFinder.keyword(followUpEventAccess.hyphenMinusGreaterThanSignKeyword_2).surround(oneSpace)
		followup.interval.format
		followup.event.format
	}

	def dispatch void format(TimeConstraintsBlock timeBlock, extension IFormattableDocument document) {
		val rFinder = timeBlock.regionFor		
		rFinder.keyword(timeConstraintsBlockAccess.timingKeyword_0).prepend(emptyLine)
		rFinder.keyword(timeConstraintsBlockAccess.constraintsKeyword_1).prepend(oneSpace)
		
		for (TimeConstraint timeConstraint : timeBlock.timeConstraints) {
			timeConstraint.format;
		}
	}

	def dispatch void format(DataConstraintsBlock dataBlock, extension IFormattableDocument document) {
		val rFinder = dataBlock.regionFor		

		rFinder.keyword(dataConstraintsBlockAccess.dataKeyword_0).prepend(emptyLine)
		rFinder.keyword(dataConstraintsBlockAccess.constraintsKeyword_1).prepend(oneSpace)		
		rFinder.keyword(dataConstraintsBlockAccess.variablesKeyword_2_0).prepend(newLine)

		dataBlock.vars.forEach[v|v.prepend(newLine).format]

		if (!dataBlock.vars.empty && !dataBlock.dataConstraints.empty) {
			dataBlock.dataConstraints.head.prepend(emptyLine)
		}

		dataBlock.dataConstraints.forEach[ dc | dc.format]
	}

	def dispatch void format(GenericConstraintsBlock genericBlock, extension IFormattableDocument document) {
		val rFinder = genericBlock.regionFor		

		rFinder.keyword(genericConstraintsBlockAccess.genericKeyword_0).prepend(emptyLine)
		rFinder.keyword(genericConstraintsBlockAccess.constraintsKeyword_1).prepend(oneSpace)
		rFinder.keyword(genericConstraintsBlockAccess.variablesKeyword_2_0).prepend(emptyLine)

		for (GenericConstraint constraint : genericBlock.genericConstraints) {
			constraint.prepend(newLine)
			constraint.format
		}
		for (Variable variable : genericBlock.vars) {
			variable.prepend(newLine)
			variable.format
		}
	}

	def dispatch void format(DataConstraint dataConstraint, extension IFormattableDocument document) {
		val rFinder = dataConstraint.regionFor

		rFinder.keyword(dataConstraintAccess.whereKeyword_3).surround(oneSpace);
		rFinder.keyword(dataConstraintAccess.semicolonKeyword_2_0)?.prepend(noSpace).append(noSpace);
		dataConstraint.condition.format
		dataConstraint.steps.forEach[format]
	}

	def dispatch void format(GenericConstraint genericConstraint, extension IFormattableDocument document) {		
		genericConstraint.formula.prepend(oneSpace).format
	}

	def dispatch void format(EventInState event, extension IFormattableDocument document) {
		val rFinder = event.regionFor
		rFinder.keyword(eventInStateAccess.stateKeyword_0_1).surround(oneSpace)
		formatSimpleCommas(rFinder.keywords(eventInStateAccess.commaKeyword_0_3_0), document)
		event.event.format
	}

	// -------------- TimeConstraintExpression Events
	def dispatch void format(EventInterval eventInterval, extension IFormattableDocument document) {
		val rFinder = eventInterval.regionFor

		rFinder.keyword(timeConstraintExpressionAccess.andKeyword_1_0_1).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.hyphenMinusGreaterThanSignKeyword_1_0_3).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.betweenKeyword_1_0_5).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.eventsKeyword_1_0_6).prepend(oneSpace)

		eventInterval.condition.format
		eventInterval.event.format
		eventInterval.interval.format
	}

	def dispatch void format(ConditionedEvent conditionedEvent, extension IFormattableDocument document) {
		val rFinder = conditionedEvent.regionFor

		rFinder.keyword(timeConstraintExpressionAccess.hyphenMinusKeyword_1_1_1).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.hyphenMinusGreaterThanSignKeyword_1_1_3).surround(oneSpace)
		conditionedEvent.condition.format
		conditionedEvent.event.format
		conditionedEvent.interval.format
	}

	def dispatch void format(ConditionedAbsenceOfEvent AbsenceEvent, extension IFormattableDocument document) {
		val rFinder = AbsenceEvent.regionFor

		rFinder.keyword(timeConstraintExpressionAccess.hyphenMinusGreaterThanSignKeyword_1_2_1).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.absentKeyword_1_2_2).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.inKeyword_1_2_4).surround(oneSpace)

		AbsenceEvent.condition.format
		AbsenceEvent.event.format
		AbsenceEvent.interval.format
	}

	def dispatch void format(PeriodicEvent periodicEvent, extension IFormattableDocument document) {
		val rFinder = periodicEvent.regionFor

		rFinder.keyword(timeConstraintExpressionAccess.thenKeyword_1_3_1).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.withKeyword_1_3_3).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.periodKeyword_1_3_4).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.msKeyword_1_3_6).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.jitterKeyword_1_3_7).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.msKeyword_1_3_9).surround(oneSpace)
		rFinder.keyword(timeConstraintExpressionAccess.untilKeyword_1_3_10_0)?.surround(oneSpace)

		periodicEvent.condition.format
		periodicEvent.event.format
		periodicEvent.jitter.format
		periodicEvent.period.format
		periodicEvent.stopEvent.format
	}

	def dispatch void format(TimeInterval timeInterval, extension IFormattableDocument document) {
		val rFinder = timeInterval.regionFor

		rFinder.keyword(timeIntervalAccess.leftSquareBracketKeyword_1).append(oneSpace)
		rFinder.keyword(timeIntervalAccess.msKeyword_2_0_1)?.prepend(oneSpace)
		rFinder.keyword(timeIntervalAccess.msKeyword_2_0_3_1)?.prepend(oneSpace)
		rFinder.keyword(timeIntervalAccess.fullStopFullStopKeyword_2_0_2).surround(oneSpace)
		rFinder.keyword(timeIntervalAccess.rightSquareBracketKeyword_3)?.prepend(oneSpace)

		timeInterval.begin?.format
		timeInterval.end?.format
	}

	def dispatch void format(DataConstraintUntilOperator untilOperator, extension IFormattableDocument document) {
		untilOperator.regionFor.keyword(dataConstraintStepAccess.untilKeyword_1_1).surround(oneSpace)
		untilOperator.body.format
		untilOperator.stop.format
	}

	def dispatch void format(DataConstraintEvent eventStep, extension IFormattableDocument document) {
		val rFinder = eventStep.regionFor
		rFinder.keyword(dataConstraintEventAccess.leftSquareBracketKeyword_0_1)?.prepend(oneSpace).append(noSpace) 
		rFinder.keyword(dataConstraintEventAccess.rightSquareBracketKeyword_0_3)?.prepend(noSpace)
		eventStep.event.format
	}

	// -------------------------- Formula ---------------------------------------
	def dispatch void format(Conjunction conj, extension IFormattableDocument document) {
		conj.regionFor.keyword(formulaAccess.ANDKeyword_1_0_1).surround(oneSpace)
		conj.left.format
		conj.right.format
	}

	def dispatch void format(Disjunction disj, extension IFormattableDocument document) {
		disj.regionFor.keyword(formulaAccess.ORKeyword_1_1_1).surround(oneSpace)
		disj.left.format
		disj.right.format
	}

	def dispatch void format(Implication impl, extension IFormattableDocument document) {
		impl.regionFor.keyword(formulaAccess.hyphenMinusGreaterThanSignKeyword_1_2_1).surround(oneSpace)
		impl.left.format
		impl.right.format
	}

	def dispatch void format(ConditionalFollow condFollow, extension IFormattableDocument document) {
		condFollow.regionFor.keyword(formulaAccess.CFKeyword_1_3_1).surround(oneSpace)
		condFollow.left.format
		condFollow.right.format
	}

	def dispatch void format(ConstraintSequence constraintSequence, extension IFormattableDocument document) {
		constraintSequence.regionFor.keyword(formulaAccess.whereKeyword_1_4_1).surround(oneSpace)		
		constraintSequence.left.format
		constraintSequence.cond.format
	}

	def dispatch void format(NegationFormula negationFormula, extension IFormattableDocument document) {
		negationFormula.regionFor.keyword(negationFormulaAccess.NOTKeyword_0).prepend(oneSpace)
		negationFormula.sub.format
	}

	def dispatch void format(BracketFormula bracketFormula, extension IFormattableDocument document) {
		val rFinder = bracketFormula.regionFor
		rFinder.keyword(bracketFormulaAccess.leftCurlyBracketKeyword_0).append(oneSpace)
		rFinder.keyword(bracketFormulaAccess.rightCurlyBracketKeyword_2).prepend(oneSpace)
		bracketFormula.sub.format
	}

	def dispatch void format(Sequence sequence, extension IFormattableDocument document) {
		val rFinder = sequence.regionFor

		rFinder.keyword(sequenceAccess.ampersandKeyword_2_0)?.surround(oneSpace)
		for (ISemanticRegion  region : rFinder.keywords(sequenceAccess.semicolonKeyword_1_0)) {
			region.prepend(noSpace).append(oneSpace)
		}
		for (SequenceElement element : sequence.steps) {
			element.format
		}
		sequence.condition?.format
	}

	def dispatch void format(Connector connector, extension IFormattableDocument document) {
		connector.left.append(oneSpace)
		connector.right.prepend(oneSpace)

		connector.left.format
		connector.conOperator.format
		connector.right.format
	}

	def dispatch void format(ESDisjunction disjunction, extension IFormattableDocument document) {
		disjunction.regionFor.keyword(stepAccess.verticalLineKeyword_1_1).surround(oneSpace)
		disjunction.left.format
		disjunction.right.format
	}

	def dispatch void format(EventSelector eventSelector, extension IFormattableDocument document) {
		val rFinder = eventSelector.regionFor

		rFinder.keyword(eventSelectorAccess.lessThanSignKeyword_0).append(oneSpace)
		rFinder.keyword(eventSelectorAccess.greaterThanSignKeyword_7).prepend(oneSpace)
		rFinder.keyword(eventSelectorAccess.commaKeyword_2).prepend(noSpace).append(oneSpace)
		rFinder.keyword(eventSelectorAccess.commaKeyword_3_1)?.prepend(noSpace).append(oneSpace)
		rFinder.keyword(eventSelectorAccess.negatedExclamationMarkKeyword_4_0)?.append(noSpace)
		rFinder.keyword(eventSelectorAccess.commaKeyword_6_0)?.prepend(noSpace).append(oneSpace)

		eventSelector.timestamp.format
		eventSelector.counter?.format
		eventSelector.event?.format
		eventSelector.condition?.format
	}
	

}
